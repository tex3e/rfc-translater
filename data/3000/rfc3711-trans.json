{
  "title": {
    "text": "RFC 3711 - The Secure Real-time Transport Protocol (SRTP)",
    "ja": "RFC 3711 - 安全なリアルタイムトランスポートプロトコル（SRTP）"
  },
  "number": 3711,
  "created_at": "2021-04-10 09:18:33.120129+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         M. Baugher\nRequest for Comments: 3711                                     D. McGrew\nCategory: Standards Track                            Cisco Systems, Inc.\n                                                              M. Naslund\n                                                              E. Carrara\n                                                              K. Norrman\n                                                       Ericsson Research\n                                                              March 2004",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "The Secure Real-time Transport Protocol (SRTP)",
      "ja": "安全なリアルタイムトランスポートプロトコル（SRTP）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティ向けのインターネット標準トラックプロトコルを規定するものであり、改善のための議論と提案を求めます。このプロトコルの標準化状態と状況については、「Internet Official Protocol Standards」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "Copyright (C) The Internet Society (2004). All Rights Reserved."
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP).",
      "ja": "この文書は、リアルタイムトランスポートプロトコル（RTP）のプロファイルであるセキュアリアルタイムトランスポートプロトコル（SRTP）について説明します。SRTPは、RTPトラフィックおよびRTPの制御トラフィックであるリアルタイムトランスポートコントロールプロトコル（RTCP）に、機密性、メッセージ認証、およびリプレイからの保護を提供できます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n    1.1.  Notational Conventions . . . . . . . . . . . . . . . . .  3\n2.  Goals and Features . . . . . . . . . . . . . . . . . . . . . .  4\n    2.1.  Features . . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  SRTP Framework . . . . . . . . . . . . . . . . . . . . . . . .  5\n    3.1.  Secure RTP . . . . . . . . . . . . . . . . . . . . . . .  6\n    3.2.  SRTP Cryptographic Contexts. . . . . . . . . . . . . . .  7\n          3.2.1.  Transform-independent parameters . . . . . . . .  8\n          3.2.2.  Transform-dependent parameters . . . . . . . . . 10\n          3.2.3.  Mapping SRTP Packets to Cryptographic Contexts . 10\n    3.3.  SRTP Packet Processing . . . . . . . . . . . . . . . . . 11\n          3.3.1.  Packet Index Determination, and ROC, s_l Update. 13\n          3.3.2.  Replay Protection. . . . . . . . . . . . . . . . 15\n   3.4.  Secure RTCP . . . . . . . . . . . . . . . . . . . . . . . 15",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4.  Pre-Defined Cryptographic Transforms . . . . . . . . . . . . . 19\n    4.1.  Encryption . . . . . . . . . . . . . . . . . . . . . . . 19\n          4.1.1.  AES in Counter Mode. . . . . . . . . . . . . . . 21\n          4.1.2.  AES in f8-mode . . . . . . . . . . . . . . . . . 22\n          4.1.3.  NULL Cipher. . . . . . . . . . . . . . . . . . . 25\n    4.2.  Message Authentication and Integrity . . . . . . . . . . 25\n          4.2.1.  HMAC-SHA1. . . . . . . . . . . . . . . . . . . . 25\n    4.3.  Key Derivation . . . . . . . . . . . . . . . . . . . . . 26\n          4.3.1.  Key Derivation Algorithm . . . . . . . . . . . . 26\n          4.3.2.  SRTCP Key Derivation . . . . . . . . . . . . . . 28\n          4.3.3.  AES-CM PRF . . . . . . . . . . . . . . . . . . . 28\n5.  Default and mandatory-to-implement Transforms. . . . . . . . . 28\n    5.1.  Encryption: AES-CM and NULL. . . . . . . . . . . . . . . 29\n    5.2.  Message Authentication/Integrity: HMAC-SHA1. . . . . . . 29\n    5.3.  Key Derivation: AES-CM PRF . . . . . . . . . . . . . . . 29\n6.  Adding SRTP Transforms . . . . . . . . . . . . . . . . . . . . 29\n7.  Rationale. . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n    7.1.  Key derivation . . . . . . . . . . . . . . . . . . . . . 30\n    7.2.  Salting key. . . . . . . . . . . . . . . . . . . . . . . 30\n    7.3.  Message Integrity from Universal Hashing . . . . . . . . 31\n    7.4.  Data Origin Authentication Considerations. . . . . . . . 31\n    7.5.  Short and Zero-length Message Authentication . . . . . . 32\n8.  Key Management Considerations. . . . . . . . . . . . . . . . . 33\n    8.1.  Re-keying  . . . . . . . . . . . . . . . . . . . . . . . 34\n          8.1.1.  Use of the <From, To> for re-keying. . . . . . . 34\n    8.2.  Key Management parameters. . . . . . . . . . . . . . . . 35\n9.  Security Considerations. . . . . . . . . . . . . . . . . . . . 37\n    9.1.  SSRC collision and two-time pad. . . . . . . . . . . . . 37\n    9.2.  Key Usage. . . . . . . . . . . . . . . . . . . . . . . . 38\n    9.3.  Confidentiality of the RTP Payload . . . . . . . . . . . 39\n    9.4.  Confidentiality of the RTP Header. . . . . . . . . . . . 40\n    9.5.  Integrity of the RTP payload and header. . . . . . . . . 40\n          9.5.1. Risks of Weak or Null Message Authentication. . . 42\n          9.5.2.  Implicit Header Authentication . . . . . . . . . 43\n10.  Interaction with Forward Error Correction mechanisms. . . . . 43\n11.  Scenarios . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n    11.1. Unicast. . . . . . . . . . . . . . . . . . . . . . . . . 43\n    11.2. Multicast (one sender) . . . . . . . . . . . . . . . . . 44\n    11.3. Re-keying and access control . . . . . . . . . . . . . . 45\n    11.4. Summary of basic scenarios . . . . . . . . . . . . . . . 46\n12. IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 46\n13. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 47\n14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n    14.1. Normative References . . . . . . . . . . . . . . . . . . 47\n    14.2. Informative References . . . . . . . . . . . . . . . . . 48\nAppendix A: Pseudocode for Index Determination . . . . . . . . . . 51\nAppendix B: Test Vectors . . . . . . . . . . . . . . . . . . . . . 51\n    B.1.  AES-f8 Test Vectors. . . . . . . . . . . . . . . . . . . 51",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    B.2.  AES-CM Test Vectors. . . . . . . . . . . . . . . . . . . 52\n    B.3.  Key Derivation Test Vectors. . . . . . . . . . . . . . . 53\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 55\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 56",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, RTCP (the Real-time Transport Control Protocol) [RFC3350].",
      "ja": "この文書は、リアルタイムトランスポートプロトコル (RTP) のプロファイルであるSecure Real-time Transport Protocol (SRTP) について述べています。SRTPは、RTPトラフィックおよびRTPの制御トラフィックであるRTCP (Real-time Transport Control Protocol) [RFC3350]に対し、機密性、メッセージ認証、およびリプレイ保護を提供できます。"
    },
    {
      "indent": 3,
      "text": "SRTP provides a framework for encryption and message authentication of RTP and RTCP streams (Section 3). SRTP defines a set of default cryptographic transforms (Sections 4 and 5), and it allows new transforms to be introduced in the future (Section 6). With appropriate key management (Sections 7 and 8), SRTP is secure (Sections 9) for unicast and multicast RTP applications (Section 11).",
      "ja": "SRTPは、RTPおよびRTCPストリームの暗号化とメッセージ認証のためのフレームワークを提供します（セクション3）。SRTPは、デフォルトの暗号変換セットを定義し（セクション4および5）、将来的に新しい変換を導入することを可能にします（セクション6）。適切な鍵管理（セクション7および8）を使用することで、SRTPはユニキャストおよびマルチキャストRTPアプリケーション（セクション11）に対して安全です（セクション9）。"
    },
    {
      "indent": 3,
      "text": "SRTP can achieve high throughput and low packet expansion. SRTP proves to be a suitable protection for heterogeneous environments (mix of wired and wireless networks). To get such features, default transforms are described, based on an additive stream cipher for encryption, a keyed-hash based function for message authentication, and an \"implicit\" index for sequencing/synchronization based on the RTP sequence number for SRTP and an index number for Secure RTCP (SRTCP).",
      "ja": "SRTPは、高いスループットと低いパケットオーバーヘッドを実現できます。SRTPは、異種環境（有線および無線ネットワークの混合）に適した保護であることが証明されています。これらの機能を実現するために、暗号化には加算ストリーム暗号、メッセージ認証には鍵付きハッシュベースの関数、そしてSRTPのRTPシーケンス番号に基づくシーケンス/同期のための「暗黙的」インデックスとセキュアRTCP（SRTCP）のインデックス番号に基づくデフォルトの変換が記述されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Notational Conventions",
      "section_title": true,
      "ja": "1.1. 表記規則"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. The terminology conforms to [RFC2828] with the following exception. For simplicity we use the term \"random\" throughout the document to denote randomly or pseudo-randomly generated values. Large amounts of random bits may be difficult to obtain, and for the security of SRTP, pseudo-randomness is sufficient [RFC1750].",
      "ja": "本書のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、[RFC2119]で説明されているように解釈されるものとします。用語は、次の例外を除き、[RFC2828]に準拠します。簡単にするために、本書全体で「ランダム」という用語を使用して、ランダムに、または疑似ランダムに生成された値を示します。大量のランダムビットを取得することは困難な場合があり、SRTPのセキュリティのためには、疑似ランダム性で十分です[RFC1750]。"
    },
    {
      "indent": 3,
      "text": "By convention, the adopted representation is the network byte order, i.e., the left most bit (octet) is the most significant one. By XOR we mean bitwise addition modulo 2 of binary strings, and || denotes concatenation. In other words, if C = A || B, then the most significant bits of C are the bits of A, and the least significant bits of C equal the bits of B. Hexadecimal numbers are prefixed by 0x.",
      "ja": "慣例により、採用されている表現はネットワークバイトオーダー、つまり左端のビット（オクテット）が最上位ビットです。XORは、バイナリ文字列のビット単位の加算（モジュロ2）を意味し、||は連結を示します。つまり、C = A || Bの場合、Cの最上位ビットはAのビットであり、Cの最下位ビットはBのビットに等しくなります。16進数にはプレフィックスとして0xが付きます。"
    },
    {
      "indent": 3,
      "text": "The word \"encryption\" includes also use of the NULL algorithm (which in practice does leave the data in the clear).",
      "ja": "「暗号化」という言葉には、NULLアルゴリズム（実際にはデータを平文のままにします）の使用も含まれます。"
    },
    {
      "indent": 3,
      "text": "With slight abuse of notation, we use the terms \"message authentication\" and \"authentication tag\" as is common practice, even though in some circumstances, e.g., group communication, the service provided is actually only integrity protection and not data origin authentication.",
      "ja": "表記の僅かな乱用ですが、一般的な慣習として「メッセージ認証」と「認証タグ」という用語を使用します。グループ通信などの一部の状況では、提供されるサービスが実際にはデータ送信元認証ではなく、完全性（インテグリティ）保護のみである場合でも同様です。"
    },
    {
      "indent": 0,
      "text": "2. Goals and Features",
      "section_title": true,
      "ja": "2. 目標と機能"
    },
    {
      "indent": 3,
      "text": "The security goals for SRTP are to ensure:",
      "ja": "SRTPのセキュリティ目標は、以下を保証することです。"
    },
    {
      "indent": 3,
      "text": "* the confidentiality of the RTP and RTCP payloads, and",
      "ja": "* RTPおよびRTCPペイロードの機密性、および"
    },
    {
      "indent": 3,
      "text": "* the integrity of the entire RTP and RTCP packets, together with protection against replayed packets.",
      "ja": "* RTPおよびRTCPパケット全体の完全性（インテグリティ）、およびリプレイ攻撃からの保護。"
    },
    {
      "indent": 3,
      "text": "These security services are optional and independent from each other, except that SRTCP integrity protection is mandatory (malicious or erroneous alteration of RTCP messages could otherwise disrupt the processing of the RTP stream).",
      "ja": "これらのセキュリティサービスはオプションであり、互いに独立していますが、SRTCPの整合性保護は必須です（RTCPメッセージの悪意のある、または誤った変更は、RTPストリームの処理を妨害する可能性があるため）。"
    },
    {
      "indent": 3,
      "text": "Other, functional, goals for the protocol are:",
      "ja": "プロトコルの機能的な目標は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "* a framework that permits upgrading with new cryptographic transforms,",
      "ja": "* 新しい暗号変換によるアップグレードを可能にするフレームワーク。"
    },
    {
      "indent": 3,
      "text": "* low bandwidth cost, i.e., a framework preserving RTP header compression efficiency,",
      "ja": "* 低帯域幅コスト、つまりRTPヘッダ圧縮効率を維持するフレームワーク"
    },
    {
      "indent": 3,
      "text": "and, asserted by the pre-defined transforms:",
      "ja": "また、事前定義された変換によって以下の点が保証されます。"
    },
    {
      "indent": 3,
      "text": "* a low computational cost,",
      "ja": "* 低い計算コスト"
    },
    {
      "indent": 3,
      "text": "* a small footprint (i.e., small code size and data memory for keying information and replay lists),",
      "ja": "* 小さなフットプリント（鍵情報およびリプレイリストのための少ないコードサイズとデータメモリ）"
    },
    {
      "indent": 3,
      "text": "* limited packet expansion to support the bandwidth economy goal,",
      "ja": "* 帯域幅節約の目標をサポートするための、パケットサイズの増大の抑制、"
    },
    {
      "indent": 3,
      "text": "* independence from the underlying transport, network, and physical layers used by RTP, in particular high tolerance to packet loss and re-ordering.",
      "ja": "* RTPが使用する下位のトランスポート、ネットワーク、物理層からの独立性、特にパケット損失および順序の入れ替わりに対する高い耐性。"
    },
    {
      "indent": 3,
      "text": "These properties ensure that SRTP is a suitable protection scheme for RTP/RTCP in both wired and wireless scenarios.",
      "ja": "これらの特性により、SRTPは有線および無線シナリオの両方で、RTP/RTCPにとって適切な保護スキームであることが保証されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Features",
      "section_title": true,
      "ja": "2.1. 機能"
    },
    {
      "indent": 3,
      "text": "Besides the above mentioned direct goals, SRTP provides for some additional features. They have been introduced to lighten the burden on key management and to further increase security. They include:",
      "ja": "上記の直接的な目標に加えて、SRTPはいくつかの追加機能を提供します。これらは鍵管理の負担を軽減し、セキュリティをさらに向上させるために導入されました。それらは以下の通りです。"
    },
    {
      "indent": 3,
      "text": "* A single \"master key\" can provide keying material for confidentiality and integrity protection, both for the SRTP stream and the corresponding SRTCP stream. This is achieved with a key derivation function (see Section 4.3), providing \"session keys\" for the respective security primitive, securely derived from the master key.",
      "ja": "* 単一の「マスター鍵」は、SRTPストリームと対応するSRTCPストリームの両方に対して、機密性と完全性（インテグリティ）保護のための鍵素材を提供できます。これは鍵導出関数（セクション4.3参照）によって達成され、マスター鍵から安全に導出されたそれぞれのセキュリティプリミティブ用の「セッション鍵」を提供します。"
    },
    {
      "indent": 3,
      "text": "* In addition, the key derivation can be configured to periodically refresh the session keys, which limits the amount of ciphertext produced by a fixed key, available for an adversary to cryptanalyze.",
      "ja": "* さらに、鍵導出はセッション鍵を定期的に更新するように設定でき、これにより、攻撃者が暗号解読に利用できる固定鍵によって生成される暗号文の量を制限します。"
    },
    {
      "indent": 3,
      "text": "* \"Salting keys\" are used to protect against pre-computation and time-memory tradeoff attacks [MF00] [BS00].",
      "ja": "* 「ソルト鍵」は、事前計算攻撃や時間とメモリのトレードオフ攻撃[MF00] [BS00]から保護するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Detailed rationale for these features can be found in Section 7.",
      "ja": "これらの機能に関する詳細な根拠はセクション7に記載されています。"
    },
    {
      "indent": 0,
      "text": "3. SRTP Framework",
      "section_title": true,
      "ja": "3. SRTPフレームワーク"
    },
    {
      "indent": 3,
      "text": "RTP is the Real-time Transport Protocol [RFC3550]. We define SRTP as a profile of RTP. This profile is an extension to the RTP Audio/Video Profile [RFC3551]. Except where explicitly noted, all aspects of that profile apply, with the addition of the SRTP security features. Conceptually, we consider SRTP to be a \"bump in the stack\" implementation which resides between the RTP application and the transport layer. SRTP intercepts RTP packets and then forwards an equivalent SRTP packet on the sending side, and intercepts SRTP packets and passes an equivalent RTP packet up the stack on the receiving side.",
      "ja": "SRTPはReal-time Transport Protocol [RFC3550]です。SRTPをRTPのプロファイルとして定義します。このプロファイルはRTPオーディオ/ビデオプロファイル[RFC3551]の拡張です。明示的に記載されている場合を除き、そのプロファイルのすべての側面が適用され、SRTPセキュリティ機能が追加されます。概念的には、SRTPはRTPアプリケーションとトランスポート層の間に存在する「スタックのバンプ」実装であると考えられます。SRTPはRTPパケットを傍受して同等のSRTPパケットを送信側に転送し、SRTPパケットを傍受して同等のRTPパケットを受信側のスタックに渡します。"
    },
    {
      "indent": 3,
      "text": "Secure RTCP (SRTCP) provides the same security services to RTCP as SRTP does to RTP. SRTCP message authentication is MANDATORY and thereby protects the RTCP fields to keep track of membership, provide feedback to RTP senders, or maintain packet sequence counters. SRTCP is described in Section 3.4.",
      "ja": "セキュアRTCP（SRTCP）は、SRTPがRTPに行うのと同じセキュリティサービスをRTCPに提供します。SRTCPメッセージ認証は必須（MANDATORY）であり、それによってメンバーシップの追跡、RTP送信者へのフィードバックの提供、またはパケットシーケンスカウンターの維持のためにRTCPフィールドを保護します。SRTCPについてはセクション3.4で説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Secure RTP",
      "section_title": true,
      "ja": "3.1. セキュアRTP"
    },
    {
      "indent": 6,
      "text": "The format of an SRTP packet is illustrated in Figure 1.",
      "ja": "SRTPパケットのフォーマットを図1に示します。"
    },
    {
      "indent": 3,
      "text": "     0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n  |V=2|P|X|  CC   |M|     PT      |       sequence number         | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                           timestamp                           | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |           synchronization source (SSRC) identifier            | |\n  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n  |            contributing source (CSRC) identifiers             | |\n  |                               ....                            | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                   RTP extension (OPTIONAL)                    | |\n+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| |                          payload  ...                         | |\n| |                               +-------------------------------+ |\n| |                               | RTP padding   | RTP pad count | |\n+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n| ~                     SRTP MKI (OPTIONAL)                       ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| :                 authentication tag (RECOMMENDED)              : |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n|                                                                   |\n+- Encrypted Portion*                      Authenticated Portion ---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1. The format of an SRTP packet. *Encrypted Portion is the same size as the plaintext for the Section 4 pre-defined transforms.",
      "ja": "図1. SRTPパケットのフォーマット。*暗号化部分は、セクション4で事前定義された変換においては、平文と同じサイズです。"
    },
    {
      "indent": 3,
      "text": "The \"Encrypted Portion\" of an SRTP packet consists of the encryption of the RTP payload (including RTP padding when present) of the equivalent RTP packet. The Encrypted Portion MAY be the exact size of the plaintext or MAY be larger. Figure 1 shows the RTP payload including any possible padding for RTP [RFC3550].",
      "ja": "SRTPパケットの「暗号化部分」は、等価RTPパケットのRTPペイロード（RTPパディングが存在する場合はそれを含む）の暗号化から構成されます。暗号化部分は、平文と正確に同じサイズである場合もあれば、それより大きい場合もあります。図1は、RTPのあらゆる可能性のあるパディングを含むRTPペイロード[RFC3550]を示しています。"
    },
    {
      "indent": 0,
      "text": "None of the pre-defined encryption transforms uses any padding; for these, the RTP and SRTP payload sizes match exactly. New transforms added to SRTP (following Section 6) may require padding, and may hence produce larger payloads. RTP provides its own padding format (as seen in Fig. 1), which due to the padding indicator in the RTP header has merits in terms of compactness relative to paddings using prefix-free codes. This RTP padding SHALL be the default method for transforms requiring padding. Transforms MAY specify other padding methods, and MUST then specify the amount, format, and processing of their padding. It is important to note that encryption transforms that use padding are vulnerable to subtle attacks, especially when message authentication is not used [V02]. Each specification for a new encryption transform needs to carefully consider and describe the security implications of the padding that it uses. Message authentication codes define their own padding, so this default does not apply to authentication transforms.",
      "ja": "事前定義された暗号化変換のどれもパディングを使用しません。これらの場合、RTPおよびSRTPのペイロードサイズは正確に一致します。 SRTPに追加される新しい変換（セクション6に従う）はパディングを必要とし、その結果、より大きなペイロードを生成する可能性があります。 RTPは独自のパディングフォーマットを提供します（図1参照）。これは、RTPヘッダー内のパディングインジケータにより、プレフィックスフリーコードを使用したパディングと比較して、コンパクトさにおいて利点があります。このRTPパディングは、パディングを必要とする変換のデフォルトの方法となるものとします（SHALL）。変換は他のパディング方法を指定してもよく（MAY）、その場合、それらのパディングの量、フォーマット、および処理を指定しなければなりません（MUST）。パディングを使用する暗号化変換は、特にメッセージ認証が使用されていない場合、巧妙な攻撃に対して脆弱であることに注意することが重要です[V02]。新しい暗号化変換の各仕様は、使用するパディングのセキュリティ上の影響を慎重に検討し、記述する必要があります。メッセージ認証コードは独自のパディングを定義するため、このデフォルトは認証変換には適用されません。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL MKI and the RECOMMENDED authentication tag are the only fields defined by SRTP that are not in RTP. Only 8-bit alignment is assumed.",
      "ja": "オプションのMKIと推奨認証タグは、RTPには存在しない、SRTPによって定義されている唯一のフィールドです。8ビットアライメントのみが想定されています。"
    },
    {
      "indent": 6,
      "text": "MKI (Master Key Identifier): configurable length, OPTIONAL. The MKI is defined, signaled, and used by key management. The MKI identifies the master key from which the session key(s) were derived that authenticate and/or encrypt the particular packet. Note that the MKI SHALL NOT identify the SRTP cryptographic context, which is identified according to Section 3.2.3. The MKI MAY be used by key management for the purposes of re-keying, identifying a particular master key within the cryptographic context (Section 3.2.1).",
      "ja": "MKI（マスターキー識別子）：設定可能な長さ、オプション。MKIは、鍵管理によって定義、シグナリング、および使用されます。MKIは、特定のパケットを認証および/または暗号化するセッションキーが導出されたマスターキーを識別します。MKIはSRTP暗号化コンテキストを識別してはならず、セクション3.2.3に従って識別されます。MKIは、鍵管理によって、キーイング（鍵の再設定）の目的で、暗号コンテキスト内の特定のマスターキーを識別するために使用されてもよい（セクション3.2.1）。"
    },
    {
      "indent": 6,
      "text": "Authentication tag: configurable length, RECOMMENDED. The authentication tag is used to carry message authentication data. The Authenticated Portion of an SRTP packet consists of the RTP header followed by the Encrypted Portion of the SRTP packet. Thus, if both encryption and authentication are applied, encryption SHALL be applied before authentication on the sender side and conversely on the receiver side. The authentication tag provides authentication of the RTP header and payload, and it indirectly provides replay protection by authenticating the sequence number. Note that the MKI is not integrity protected as this does not provide any extra protection.",
      "ja": "認証タグ：設定可能な長さ、推奨。認証タグは、メッセージ認証データを伝達するために使用されます。SRTPパケットの認証部分は、RTPヘッダーとその後に続くSRTPパケットの暗号化部分から構成されます。したがって、暗号化と認証の両方が適用される場合、送信者側では認証の前に、受信者側ではその逆に、暗号化が適用されるものとします。認証タグはRTPヘッダーとペイロードの認証を提供し、シーケンス番号を認証することにより、間接的にリプレイ保護を提供します。これは追加の保護を提供しないため、MKIは整合性保護の対象外であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2. SRTP Cryptographic Contexts",
      "section_title": true,
      "ja": "3.2. SRTP暗号コンテキスト"
    },
    {
      "indent": 3,
      "text": "Each SRTP stream requires the sender and receiver to maintain cryptographic state information. This information is called the \"cryptographic context\".",
      "ja": "各SRTPストリームでは、送信者と受信者が暗号状態情報を維持する必要があります。この情報は「暗号コンテキスト」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": " SRTP uses two types of keys: session keys and master keys. By a \"session key\", we mean a key which is used directly in a cryptographic transform (e.g., encryption or message authentication), and by a \"master key\", we mean a random bit string (given by the key management protocol) from which session keys are derived in a cryptographically secure way. The master key(s) and other parameters in the cryptographic context are provided by key management mechanisms external to SRTP, see Section 8.",
      "ja": "SRTPは、セッション鍵とマスター鍵の2種類の鍵を使用します。「セッション鍵」とは、暗号変換（例：暗号化またはメッセージ認証）で直接使用される鍵を意味し、「マスター鍵」とは、暗号学的に安全な方法でセッション鍵が導出される（鍵管理プロトコルによって与えられる）ランダムなビット列を意味します。暗号コンテキスト内のマスター鍵およびその他のパラメータは、SRTPの外部にある鍵管理メカニズムによって提供されます（セクション8参照）。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Transform-independent parameters",
      "section_title": true,
      "ja": "3.2.1. 変換から独立したパラメータ"
    },
    {
      "indent": 3,
      "text": "Transform-independent parameters are present in the cryptographic context independently of the particular encryption or authentication transforms that are used. The transform-independent parameters of the cryptographic context for SRTP consist of:",
      "ja": "変換から独立したパラメータは、使用される特定の暗号化または認証変換とは無関係に、暗号コンテキストに存在します。SRTPの暗号コンテキストにおける変換から独立したパラメータは、次の要素で構成されます。"
    },
    {
      "indent": 3,
      "text": "* a 32-bit unsigned rollover counter (ROC), which records how many times the 16-bit RTP sequence number has been reset to zero after passing through 65,535. Unlike the sequence number (SEQ), which SRTP extracts from the RTP packet header, the ROC is maintained by SRTP as described in Section 3.3.1.",
      "ja": "* 32ビットの符号なしロールオーバーカウンター（ROC）。これは、16ビットのRTPシーケンス番号が65,535を超えてゼロにリセットされた回数を記録します。SRTPがRTPパケットヘッダーから抽出するシーケンス番号（SEQ）とは異なり、ROCはセクション3.3.1で説明されているようにSRTPによって維持されます。"
    },
    {
      "indent": 6,
      "text": "We define the index of the SRTP packet corresponding to a given ROC and RTP sequence number to be the 48-bit quantity",
      "ja": "特定のROCおよびRTPシーケンス番号に対応するSRTPパケットのインデックスを、48ビットの値として次のように定義します。"
    },
    {
      "indent": 12,
      "text": "i = 2^16 * ROC + SEQ.",
      "ja": "i = 2^16 * ROC + SEQ"
    },
    {
      "indent": 3,
      "text": "* for the receiver only, a 16-bit sequence number s_l, which can be thought of as the highest received RTP sequence number (see Section 3.3.1 for its handling), which SHOULD be authenticated since message authentication is RECOMMENDED,",
      "ja": "* 受信側のみ、16ビットのシーケンス番号s_l。これは、受信したRTPシーケンス番号の最大値と考えることができます（その処理についてはセクション3.3.1を参照）。メッセージ認証が推奨（RECOMMENDED）されているため、これは認証されるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "* an identifier for the encryption algorithm, i.e., the cipher and its mode of operation,",
      "ja": "* 暗号化アルゴリズムの識別子（つまり、暗号とその動作モード）"
    },
    {
      "indent": 3,
      "text": "* an identifier for the message authentication algorithm,",
      "ja": "* メッセージ認証アルゴリズムの識別子"
    },
    {
      "indent": 3,
      "text": "* a replay list, maintained by the receiver only (when authentication and replay protection are provided), containing indices of recently received and authenticated SRTP packets,",
      "ja": "* 受信側のみで維持されるリプレイリスト（認証とリプレイ保護が提供されている場合）。最近受信および認証されたSRTPパケットのインデックスが含まれます。"
    },
    {
      "indent": 3,
      "text": "* an MKI indicator (0/1) as to whether an MKI is present in SRTP and SRTCP packets,",
      "ja": "* MKIがSRTPおよびSRTCPパケットに存在するかどうかを示すMKIインジケーター（0/1）"
    },
    {
      "indent": 3,
      "text": "* if the MKI indicator is set to one, the length (in octets) of the MKI field, and (for the sender) the actual value of the currently active MKI (the value of the MKI indicator and length MUST be kept fixed for the lifetime of the context),",
      "ja": "* MKIインジケーターが1に設定されている場合、MKIフィールドの長さ（オクテット単位）、および（送信側の場合）現在アクティブなMKIの実際の値（MKIインジケーターと長さの値は、コンテキストの存続期間中、固定されなければなりません（MUST））"
    },
    {
      "indent": 3,
      "text": "* the master key(s), which MUST be random and kept secret,",
      "ja": "* マスター鍵。これはランダムであり、秘密に保たれなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "* for each master key, there is a counter of the number of SRTP packets that have been processed (sent) with that master key (essential for security, see Sections 3.3.1 and 9),",
      "ja": "* 各マスター鍵には、そのマスター鍵で処理（送信）されたSRTPパケットの数を数えるカウンターがあります（セキュリティに不可欠。セクション3.3.1および9を参照）。"
    },
    {
      "indent": 3,
      "text": "* non-negative integers n_e, and n_a, determining the length of the session keys for encryption, and message authentication.",
      "ja": "* 暗号化およびメッセージ認証のためのセッション鍵の長さを決定する、非負の整数n_eおよびn_a。"
    },
    {
      "indent": 3,
      "text": "In addition, for each master key, an SRTP stream MAY use the following associated values:",
      "ja": "さらに、各マスター鍵について、SRTPストリームは以下の関連値を使用してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "* a master salt, to be used in the key derivation of session keys. This value, when used, MUST be random, but MAY be public. Use of master salt is strongly RECOMMENDED, see Section 9.2. A \"NULL\" salt is treated as 00...0.",
      "ja": "* セッション鍵の鍵導出で使用されるマスターソルト。この値は、使用する場合、ランダムでなければなりませんが（MUST）、公開してもよい（MAY）。マスターソルトの使用は強く推奨されます（RECOMMENDED）（セクション9.2参照）。「NULL」ソルトは00...0として扱われます。"
    },
    {
      "indent": 3,
      "text": "* an integer in the set {1,2,4,...,2^24}, the \"key_derivation_rate\", where an unspecified value is treated as zero. The constraint to be a power of 2 simplifies the session-key derivation implementation, see Section 4.3.",
      "ja": "* {1,2,4,...,2^24}の集合の整数である「key_derivation_rate」。指定されていない値はゼロとして扱われます。2のべき乗であるという制約により、セッション鍵導出の実装が簡素化されます（セクション4.3参照）。"
    },
    {
      "indent": 3,
      "text": "* an MKI value,",
      "ja": "* MKI値"
    },
    {
      "indent": 3,
      "text": "* <From, To> values, specifying the lifetime for a master key, expressed in terms of the two 48-bit index values inside whose range (including the range end-points) the master key is valid. For the use of <From, To>, see Section 8.1.1. <From, To> is an alternative to the MKI and assumes that a master key is in one-to-one correspondence with the SRTP session key on which the <From, To> range is defined.",
      "ja": "* <From, To>値。マスター鍵の有効期間を指定し、マスター鍵が有効な範囲（範囲の終点を含む）を示す2つの48ビットインデックス値で表現されます。<From, To>の使用については、セクション8.1.1を参照してください。<From, To>はMKIの代替であり、マスター鍵が<From, To>範囲が定義されているSRTPセッション鍵と1対1で対応していることを前提としています。"
    },
    {
      "indent": 3,
      "text": "SRTCP SHALL by default share the crypto context with SRTP, except:",
      "ja": "SRTCPは、以下の場合を除き、デフォルトでSRTPと暗号コンテキストを共有しなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "* no rollover counter and s_l-value need to be maintained as the RTCP index is explicitly carried in each SRTCP packet,",
      "ja": "* RTCPインデックスは各SRTCPパケットで明示的に伝達されるため、ロールオーバーカウンターとs_l値を維持する必要はありません。"
    },
    {
      "indent": 3,
      "text": "* a separate replay list is maintained (when replay protection is provided),",
      "ja": "* 別のリプレイリストが維持されます（リプレイ保護が提供されている場合）。"
    },
    {
      "indent": 3,
      "text": "* SRTCP maintains a separate counter for its master key (even if the master key is the same as that for SRTP, see below), as a means to maintain a count of the number of SRTCP packets that have been processed with that key.",
      "ja": "* SRTCPは、そのマスター鍵に対して別のカウンターを維持します（マスター鍵がSRTPのものと同じであっても、下記参照）。これは、その鍵で処理されたSRTCPパケットの数を維持するための手段です。"
    },
    {
      "indent": 3,
      "text": "Note in particular that the master key(s) MAY be shared between SRTP and the corresponding SRTCP, if the pre-defined transforms (including the key derivation) are used but the session key(s) MUST NOT be so shared.",
      "ja": "特に、事前定義された変換（鍵導出を含む）が使用される場合、マスター鍵はSRTPと対応するSRTCPの間で共有されてもよい（MAY）ですが、セッション鍵は共有されてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "In addition, there can be cases (see Sections 8 and 9.1) where several SRTP streams within a given RTP session, identified by their synchronization source (SSRCs, which is part of the RTP header), share most of the crypto context parameters (including possibly master and session keys). In such cases, just as in the normal SRTP/SRTCP parameter sharing above, separate replay lists and packet counters for each stream (SSRC) MUST still be maintained. Also, separate SRTP indices MUST then be maintained.",
      "ja": "さらに、特定のRTPセッション内の複数のSRTPストリーム（RTPヘッダーの一部である同期ソース（SSRC）によって識別される）が、暗号コンテキストパラメータのほとんど（マスター鍵とセッション鍵を含む可能性がある）を共有する場合があります（セクション8および9.1参照）。そのような場合、上記の通常のSRTP/SRTCPパラメータ共有と同様に、各ストリーム（SSRC）に対して個別のリプレイリストとパケットカウンターを維持しなければなりません（MUST）。また、個別のSRTPインデックスも維持しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "A summary of parameters, pre-defined transforms, and default values for the above parameters (and other SRTP parameters) can be found in Sections 5 and 8.2.",
      "ja": "上記のパラメータ（および他のSRTPパラメータ）のパラメータ、事前定義された変換、およびデフォルト値の概要は、セクション5および8.2に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Transform-dependent parameters",
      "section_title": true,
      "ja": "3.2.2. 変換に依存するパラメータ"
    },
    {
      "indent": 3,
      "text": "All encryption, authentication/integrity, and key derivation parameters are defined in the transforms section (Section 4). Typical examples of such parameters are block size of ciphers, session keys, data for the Initialization Vector (IV) formation, etc. Future SRTP transform specifications MUST include a section to list the additional cryptographic context's parameters for that transform, if any.",
      "ja": "すべての暗号化、認証/完全性、および鍵導出パラメータは、変換セクション（セクション4）で定義されます。そのようなパラメータの典型的な例は、暗号のブロックサイズ、セッション鍵、初期化ベクトル（IV）形成のためのデータなどです。将来のSRTP変換仕様には、その変換のための追加の暗号コンテキストパラメータをリストするセクションを含めなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Mapping SRTP Packets to Cryptographic Contexts",
      "section_title": true,
      "ja": "3.2.3. SRTPパケットと暗号コンテキストのマッピング"
    },
    {
      "indent": 3,
      "text": "Recall that an RTP session for each participant is defined [RFC3550] by a pair of destination transport addresses (one network address plus a port pair for RTP and RTCP), and that a multimedia session is defined as a collection of RTP sessions. For example, a particular multimedia session could include an audio RTP session, a video RTP session, and a text RTP session.",
      "ja": "各参加者のRTPセッションは、一対の宛先トランスポートアドレス（1つのネットワークアドレスとRTPおよびRTCPのポートペア）によって定義されていること、およびマルチメディアセッションがRTPセッションのコレクションとして定義されていることを思い出してください。例えば、特定のマルチメディアセッションは、オーディオRTPセッション、ビデオRTPセッション、およびテキストRTPセッションを含み得る。"
    },
    {
      "indent": 3,
      "text": "A cryptographic context SHALL be uniquely identified by the triplet context identifier:",
      "ja": "暗号化コンテキストは、トリプレットのコンテキスト識別子によって一意に識別されなければならない。"
    },
    {
      "indent": 3,
      "text": "context id = <SSRC, destination network address, destination\ntransport port number>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where the destination network address and the destination transport port are the ones in the SRTP packet. It is assumed that, when presented with this information, the key management returns a context with the information as described in Section 3.2.",
      "ja": "ここで、宛先ネットワークアドレスと宛先トランスポートポートは、SRTPパケット内のものです。この情報が提示されると、鍵管理はセクション3.2で説明されている情報を含むコンテキストを返すと仮定します。"
    },
    {
      "indent": 0,
      "text": "As noted above, SRTP and SRTCP by default share the bulk of the parameters in the cryptographic context. Thus, retrieving the crypto context parameters for an SRTCP stream in practice may imply a binding to the correspondent SRTP crypto context. It is up to the implementation to assure such binding, since the RTCP port may not be directly deducible from the RTP port only. Alternatively, the key management may choose to provide separate SRTP- and SRTCP- contexts, duplicating the common parameters (such as master key(s)). The latter approach then also enables SRTP and SRTCP to use, e.g., distinct transforms, if so desired. Similar considerations arise when multiple SRTP streams, forming part of one single RTP session, share keys and other parameters.",
      "ja": "上記のように、SRTPおよびSRTCPはデフォルトでは暗号化コンテキスト内のパラメータの大部分を共有します。したがって、実際にはSRTCPストリームの暗号化コンテキストパラメータを検索することは、対応するSRTP暗号化コンテキストへのバインディングを意味するかもしれません。RTCPポートはRTPポートのみから直接推測できない場合があるため、このようなバインディングを保証するのは実装次第です。あるいは、鍵管理は、個別のSRTPおよびSRTCPコンテキストを提供し、共通パラメータ（マスターキーなど）を複製することを選択することができます。後者のアプローチはまた、SRTPおよびSRTCPが所望であれば、例えば異なる変換を使用することを可能にします。1つのRTPセッションの一部を形成する複数のSRTPストリームが、キーやその他のパラメータを共有する場合にも、同様の考慮事項が生じます。"
    },
    {
      "indent": 3,
      "text": "If no valid context can be found for a packet corresponding to a certain context identifier, that packet MUST be discarded.",
      "ja": "特定のコンテキスト識別子に対応するパケットに対して有効なコンテキストが見つからない場合、そのパケットは破棄されなければならない。"
    },
    {
      "indent": 0,
      "text": "3.3. SRTP Packet Processing",
      "section_title": true,
      "ja": "3.3. SRTPパケット処理"
    },
    {
      "indent": 3,
      "text": "The following applies to SRTP. SRTCP is described in Section 3.4.",
      "ja": "以下はSRTPに適用されます。SRTCPについてはセクション3.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "Assuming initialization of the cryptographic context(s) has taken place via key management, the sender SHALL do the following to construct an SRTP packet:",
      "ja": "鍵管理を介して暗号化コンテキストの初期化が行われたと仮定して、送信者はSRTPパケットを構築するために次のことを行わなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "1. Determine which cryptographic context to use as described in Section 3.2.3.",
      "ja": "1. セクション3.2.3で説明されているように使用する暗号化コンテキストを決定します。"
    },
    {
      "indent": 3,
      "text": "2. Determine the index of the SRTP packet using the rollover counter, the highest sequence number in the cryptographic context, and the sequence number in the RTP packet, as described in Section 3.3.1.",
      "ja": "2. 3.3.1項で説明したように、ロールオーバーカウンタ、暗号化コンテキスト内の最も高いシーケンス番号、およびRTPパケット内のシーケンス番号を使用してSRTPパケットのインデックスを決定します。"
    },
    {
      "indent": 3,
      "text": "3. Determine the master key and master salt. This is done using the index determined in the previous step or the current MKI in the cryptographic context, according to Section 8.1.",
      "ja": "3. マスターキーとマスターソルトを決定します。これは、セクション8.1に従って、暗号化コンテキスト内の前のステップまたは現在のMKIで決定されたインデックスを使用して行います。"
    },
    {
      "indent": 3,
      "text": "4. Determine the session keys and session salt (if they are used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate, and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.",
      "ja": "4. ステップ2および3で決定されたインデックスとともに、暗号化コンテキスト内のマスターキー、マスターソルト、key_derivation_rate、およびセッションキー長を使用して、セクション4.3で説明されているように、セッションキーとセッションソルト（変換で使用されている場合）を決定します。"
    },
    {
      "indent": 3,
      "text": "5. Encrypt the RTP payload to produce the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers). This step uses the encryption algorithm indicated in the cryptographic context, the session encryption key and the session salt (if used) found in Step 4 together with the index found in Step 2.",
      "ja": "5. RTPペイロードを暗号化して、パケットの暗号化部分を作成します（定義済み暗号化のセクション4.1を参照）。このステップでは、暗号化コンテキストに示されている暗号化アルゴリズム、およびステップ4で見つかったセッション暗号化キーとセッションソルト（使用されている場合）を、ステップ2で見つかったインデックスとともに使用します。"
    },
    {
      "indent": 3,
      "text": "6. If the MKI indicator is set to one, append the MKI to the packet.",
      "ja": "6. MKIインジケータが1に設定されている場合は、MKIをパケットに追加します。"
    },
    {
      "indent": 0,
      "text": " 7. For message authentication, compute the authentication tag for the Authenticated Portion of the packet, as described in Section 4.2. This step uses the current rollover counter, the authentication algorithm indicated in the cryptographic context, and the session authentication key found in Step 4. Append the authentication tag to the packet.",
      "ja": "7. メッセージ認証の場合は、セクション4.2で説明されているように、パケットの認証部分の認証タグを計算します。このステップでは、現在のロールオーバーカウンタ、暗号化コンテキストに示されている認証アルゴリズム、およびステップ4で見つかったセッション認証キーを使用します。認証タグをパケットに追加します。"
    },
    {
      "indent": 3,
      "text": "8. If necessary, update the ROC as in Section 3.3.1, using the packet index determined in Step 2.",
      "ja": "8. 必要に応じて、ステップ2で決定されたパケットインデックスを使用して、セクション3.3.1のようにROCを更新してください。"
    },
    {
      "indent": 3,
      "text": "To authenticate and decrypt an SRTP packet, the receiver SHALL do the following:",
      "ja": "SRTPパケットを認証し復号化するために、受信者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Determine which cryptographic context to use as described in Section 3.2.3.",
      "ja": "1. セクション3.2.3で説明されているように使用する暗号化コンテキストを決定します。"
    },
    {
      "indent": 3,
      "text": "2. Run the algorithm in Section 3.3.1 to get the index of the SRTP packet. The algorithm uses the rollover counter and highest sequence number in the cryptographic context with the sequence number in the SRTP packet, as described in Section 3.3.1.",
      "ja": "2. SRTPパケットのインデックスを取得するには、セクション3.3.1で説明されているアルゴリズムを実行します。このアルゴリズムは、暗号化コンテキスト内のロールオーバーカウンタと最も高いシーケンス番号を、SRTPパケット内のシーケンス番号と組み合わせて使用します。"
    },
    {
      "indent": 3,
      "text": "3. Determine the master key and master salt. If the MKI indicator in the context is set to one, use the MKI in the SRTP packet, otherwise use the index from the previous step, according to Section 8.1.",
      "ja": "3. マスターキーとマスターソルトを決定します。コンテキスト内のMKIインジケータが1に設定されている場合は、SRTPパケット内のMKIを使用してください。それ以外の場合は、セクション8.1に従って前の手順からインデックスを使用してください。"
    },
    {
      "indent": 3,
      "text": "4. Determine the session keys, and session salt (if used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.",
      "ja": "4. セクション4.3で説明されているセッションソルト（変換で使用されている場合）は、ステップ2と3で決定された暗号化コンテキストのマスターキー、マスターソルト、key_derivation_rate、およびセッションキー長を使用します。"
    },
    {
      "indent": 3,
      "text": "5. For message authentication and replay protection, first check if the packet has been replayed (Section 3.3.2), using the Replay List and the index as determined in Step 2. If the packet is judged to be replayed, then the packet MUST be discarded, and the event SHOULD be logged.",
      "ja": "5. メッセージ認証およびリプレイ保護のために、最初にパケットがリプレイリストとステップ2で決定されたインデックスを使用して、パケットがリプレイされたかどうか（セクション3.3.2）を確認します。パケットがリプレイされたと判断された場合、そのパケットは破棄されなければならず、イベントはログに記録すべきです。"
    },
    {
      "indent": 6,
      "text": "Next, perform verification of the authentication tag, using the rollover counter from Step 2, the authentication algorithm indicated in the cryptographic context, and the session authentication key from Step 4. If the result is \"AUTHENTICATION FAILURE\" (see Section 4.2), the packet MUST be discarded from further processing and the event SHOULD be logged.",
      "ja": "次に、ステップ2からのロールオーバーカウンタ、暗号化コンテキストに示されている認証アルゴリズム、およびステップ4からのセッション認証キーを使用して、認証タグの検証を実行します。結果が「認証失敗」である場合（セクション4.2を参照）パケットはさらなる処理から破棄されなければならず、イベントをログに記録すべきです。"
    },
    {
      "indent": 3,
      "text": "6. Decrypt the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers), using the decryption algorithm indicated in the cryptographic context, the session encryption key and salt (if used) found in Step 4 with the index from Step 2.",
      "ja": "6. 暗号化コンテキストに示されている復号化アルゴリズム、ステップ4で見つかったセッション暗号化キーとソルト（使用されている場合）、およびステップ2からのインデックスを使用して、パケットの暗号化部分（定義されている暗号についてはセクション4.1を参照）を復号化します。"
    },
    {
      "indent": 3,
      "text": "7. Update the rollover counter and highest sequence number, s_l, in the cryptographic context as in Section 3.3.1, using the packet index estimated in Step 2. If replay protection is provided, also update the Replay List as described in Section 3.3.2.",
      "ja": "7. ステップ2で推定されたパケットインデックスを使用して、セクション3.3.1に従って暗号化コンテキスト内のロールオーバーカウンタと最も高いシーケンス番号s_lを更新します。リプレイ保護が提供されている場合、セクション3.3.2で説明されているようにリプレイリストも更新します。"
    },
    {
      "indent": 3,
      "text": "8. When present, remove the MKI and authentication tag fields from the packet.",
      "ja": "8. 存在する場合は、パケットからMKIと認証タグフィールドを削除します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Packet Index Determination, and ROC, s_l Update",
      "section_title": true,
      "ja": "3.3.1. パケットインデックスの決定、およびROC、s_lアップデート"
    },
    {
      "indent": 3,
      "text": "SRTP implementations use an \"implicit\" packet index for sequencing, i.e., not all of the index is explicitly carried in the SRTP packet. For the pre-defined transforms, the index i is used in replay protection (Section 3.3.2), encryption (Section 4.1), message authentication (Section 4.2), and for the key derivation (Section 4.3).",
      "ja": "SRTPの実装は、シーケンスのための「暗黙的」パケットインデックス、すなわち、すべてのインデックスがSRTPパケットで明示的に運ばれるわけではありません。事前定義された変換では、インデックスiはリプレイ保護（セクション3.3.2）、暗号化（セクション4.1）、メッセージ認証（セクション4.2）、およびキー導出（セクション4.3）で使用されます。"
    },
    {
      "indent": 3,
      "text": "When the session starts, the sender side MUST set the rollover counter, ROC, to zero. Each time the RTP sequence number, SEQ, wraps modulo 2^16, the sender side MUST increment ROC by one, modulo 2^32 (see security aspects below). The sender's packet index is then defined as",
      "ja": "セッションが開始されると、送信側はロールオーバーカウンタ、ROCをゼロに設定する必要があります。RTPシーケンス番号SEQがモジュロ2^16でラップするたびに、送信側はROCをモジュロ2^32で1つ増やす必要があります（以下のセキュリティの側面を参照）。送信者のパケットインデックスは次のように定義されます"
    },
    {
      "indent": 6,
      "text": "i = 2^16 * ROC + SEQ.",
      "ja": "i = 2^16 * ROC + SEQ."
    },
    {
      "indent": 3,
      "text": "Receiver-side implementations use the RTP sequence number to determine the correct index of a packet, which is the location of the packet in the sequence of all SRTP packets. A robust approach for the proper use of a rollover counter requires its handling and use to be well defined. In particular, out-of-order RTP packets with sequence numbers close to 2^16 or zero must be properly handled.",
      "ja": "受信側の実装では、RTPシーケンス番号を使用して、パケットの正しいインデックスを決定します。これは、すべてのSRTPパケットのシーケンス内のパケットの場所です。ロールオーバーカウンタを適切に使用するための堅牢なアプローチは、その取り扱いおよび使用を明確に定義することを必要とします。特に、2^16またはゼロに近いシーケンス番号を持つ順不同のRTPパケットを適切に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "The index estimate is based on the receiver's locally maintained ROC and s_l values. At the setup of the session, the ROC MUST be set to zero. Receivers joining an on-going session MUST be given the current ROC value using out-of-band signaling such as key-management signaling. Furthermore, the receiver SHALL initialize s_l to the RTP sequence number (SEQ) of the first observed SRTP packet (unless the initial value is provided by out of band signaling such as key management).",
      "ja": "インデックス推定値は、受信者のローカルに維持されたROCおよびs_l値に基づいています。セッションのセットアップ時に、ROCはゼロに設定されなければなりません（MUST）。進行中のセッションに参加する受信機には、鍵管理シグナリングなどの帯域外シグナリングを使用して現在のROC値が与えられなければなりません（MUST）。さらに、受信機は、最初の観測されたSRTPパケットのRTPシーケンス番号（SEQ）にs_lを初期化しなければなりません（SHALL）（初期値が鍵管理などの帯域外シグナリングによって提供されない限り）。"
    },
    {
      "indent": 3,
      "text": "On consecutive SRTP packets, the receiver SHOULD estimate the index as i = 2^16 * v + SEQ,",
      "ja": "連続したSRTPパケットでは、受信機はインデックスを i = 2^16 * v + SEQ として推定すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "where v is chosen from the set { ROC-1, ROC, ROC+1 } (modulo 2^32) such that i is closest (in modulo 2^48 sense) to the value 2^16 * ROC + s_l (see Appendix A for pseudocode).",
      "ja": "ここで、vは集合 { ROC-1, ROC, ROC+1 } (モジュロ 2^32) から選択され、i が値 2^16 * ROC + s_l に最も近い (モジュロ 2^48 の意味で) ようにします（擬似コードについては付録Aを参照）。"
    },
    {
      "indent": 3,
      "text": "After the packet has been processed and authenticated (when enabled for SRTP packets for the session), the receiver MUST use v to conditionally update its s_l and ROC variables as follows. If v=(ROC-1) mod 2^32, then there is no update to s_l or ROC. If v=ROC, then s_l is set to SEQ if and only if SEQ is larger than the current s_l; there is no change to ROC. If v=(ROC+1) mod 2^32, then s_l is set to SEQ and ROC is set to v.",
      "ja": "パケットが処理および認証された後（セッションのSRTPパケットに対して有効になっている場合）、受信側はvを使用してs_lおよびROC変数を次のように条件付きで更新しなければなりません（MUST）。v=(ROC-1) mod 2^32 の場合、s_lまたはROCの更新はありません。v=ROC の場合、SEQが現在のs_lよりも大きい場合に限りs_lはSEQに設定されます。ROCに変更はありません。v=(ROC+1) mod 2^32 の場合、s_lはSEQに設定され、ROCはvに設定されます。"
    },
    {
      "indent": 3,
      "text": "After a re-keying occurs (changing to a new master key), the rollover counter always maintains its sequence of values, i.e., it MUST NOT be reset to zero.",
      "ja": "再キーイングが発生した後（新しいマスターキーに変更）、ロールオーバーカウンタは常にそのシーケンスを維持します。すなわち、ゼロにリセットされてはいけません。"
    },
    {
      "indent": 3,
      "text": "As the rollover counter is 32 bits long and the sequence number is 16 bits long, the maximum number of packets belonging to a given SRTP stream that can be secured with the same key is 2^48 using the pre-defined transforms. After that number of SRTP packets have been sent with a given (master or session) key, the sender MUST NOT send any more packets with that key. (There exists a similar limit for SRTCP, which in practice may be more restrictive, see Section 9.2.) This limitation enforces a security benefit by providing an upper bound on the amount of traffic that can pass before cryptographic keys are changed. Re-keying (see Section 8.1) MUST be triggered, before this amount of traffic, and MAY be triggered earlier, e.g., for increased security and access control to media. Recurring key derivation by means of a non-zero key_derivation_rate (see Section 4.3), also gives stronger security but does not change the above absolute maximum value.",
      "ja": "ロールオーバーカウンタが32ビット長であり、シーケンス番号は16ビット長であるため、同じキーで保護することができる特定のSRTPストリームに属するパケットの最大数は、事前定義された変換を使用して2^48です。その数のSRTPパケットが与えられた（マスターまたはセッション）キーで送信された後、送信者はそのキーを使用してさらにパケットを送信してはなりません（MUST NOT）。（実際にはより制限的な場合がありますが、SRTCPにも同様の制限があります。セクション9.2を参照。）この制限は、暗号鍵が変更される前に通過できるトラフィックの量に上限を提供することで、セキュリティ上の利益を強制します。このトラフィック量に達する前に、再キーイング（セクション8.1を参照）がトリガーされなければならず（MUST）、たとえばセキュリティとメディアへのアクセス制御を増やすために、以前にトリガーされてもよい（MAY）。ゼロ以外のkey_derivation_rateによる繰り返しキー導出（セクション4.3を参照）も、より強力なセキュリティを提供しますが、上記の絶対最大値は変更しません。"
    },
    {
      "indent": 3,
      "text": "On the receiver side, there is a caveat to updating s_l and ROC: if message authentication is not present, neither the initialization of s_l, nor the ROC update can be made completely robust. The receiver's \"implicit index\" approach works for the pre-defined transforms as long as the reorder and loss of the packets are not too great and bit-errors do not occur in unfortunate ways. In particular, 2^15 packets would need to be lost, or a packet would need to be 2^15 packets out of sequence before synchronization is lost. Such drastic loss or reorder is likely to disrupt the RTP application itself.",
      "ja": "受信側では、s_lとROCを更新する上での注意点があります。メッセージ認証が存在しない場合、s_lの初期化もROCの更新も完全に堅牢にはできません。受信者の「暗黙的インデックス」アプローチは、パケットの並べ替えや損失が大きくなりすぎず、ビットエラーが不運な形で発生しない限り、事前定義の変換で機能します。特に、同期が失われる前に2^15パケットが失われるか、またはパケットがシーケンスから2^15パケットずれている必要があるでしょう。そのような劇的な損失や並べ替えは、RTPアプリケーション自体を混乱させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The algorithm for the index estimate and ROC update is a matter of implementation, and should take into consideration the environment (e.g., packet loss rate) and the cases when synchronization is likely to be lost, e.g., when the initial sequence number (randomly chosen by RTP) is not known in advance (not sent in the key management protocol) but may be near to wrap modulo 2^16.",
      "ja": "インデックス推定とROC更新のアルゴリズムは実装の問題であり、環境（例：パケット損失率）と同期が失われる可能性のあるケースを考慮に入れるべきです。例えば、RTPによってランダムに選択された初期シーケンス番号が事前に不明な場合（鍵管理プロトコルで送信されていない）でも、モジュロ2^16でラップする時期が近い可能性がある場合などです。"
    },
    {
      "indent": 3,
      "text": "A more elaborate and more robust scheme than the one given above is the handling of RTP's own \"rollover counter\", see Appendix A.1 of [RFC3550].",
      "ja": "上記のものよりも精巧でより堅牢なスキームは、RTP自身の「ロールオーバーカウンター」の取り扱いです。[RFC3550]の付録A.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Replay Protection",
      "section_title": true,
      "ja": "3.3.2. リプレイ保護"
    },
    {
      "indent": 3,
      "text": "Secure replay protection is only possible when integrity protection is present. It is RECOMMENDED to use replay protection, both for RTP and RTCP, as integrity protection alone cannot assure security against replay attacks.",
      "ja": "安全なリプレイ保護は、整合性保護が存在する場合にのみ可能です。整合性保護だけではリプレイ攻撃に対するセキュリティを保証できないため、RTPとRTCPの両方でリプレイ保護を使用することを推奨します（RECOMMENDED）。"
    },
    {
      "indent": 3,
      "text": "A packet is \"replayed\" when it is stored by an adversary, and then re-injected into the network. When message authentication is provided, SRTP protects against such attacks through a Replay List. Each SRTP receiver maintains a Replay List, which conceptually contains the indices of all of the packets which have been received and authenticated. In practice, the list can use a \"sliding window\" approach, so that a fixed amount of storage suffices for replay protection. Packet indices which lag behind the packet index in the context by more than SRTP-WINDOW-SIZE can be assumed to have been received, where SRTP-WINDOW-SIZE is a receiver-side, implementation-dependent parameter and MUST be at least 64, but which MAY be set to a higher value.",
      "ja": "パケットは、敵対者によって保存されてからネットワークに再注入されたときに「リプレイ」されます。メッセージ認証が提供される場合、SRTPはリプレイリストを介してそのような攻撃から保護します。各SRTP受信機はリプレイリストを維持しており、これは概念的に受信および認証されたすべてのパケットのインデックスを含みます。実際には、リストは「スライディングウィンドウ」アプローチを使用でき、その結果、リプレイ保護には一定量のストレージで十分です。コンテキスト内のパケットインデックスからSRTP-WINDOW-SIZEを超えて遅れているパケットインデックスは、受信済みとみなすことができます。ここでSRTP-WINDOW-SIZEは受信側で実装依存のパラメータであり、少なくとも64でなければなりませんが（MUST）、より高い値に設定してもよい（MAY）とみなすことができます。"
    },
    {
      "indent": 3,
      "text": "The receiver checks the index of an incoming packet against the replay list and the window. Only packets with index ahead of the window, or, inside the window but not already received, SHALL be accepted.",
      "ja": "受信機は、着信パケットのインデックスをリプレイリストおよびウィンドウと照合して確認します。ウィンドウよりもインデックスが進んでいるパケット、またはウィンドウ内にあるがまだ受信されていないパケットのみが受け入れられるべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "After the packet has been authenticated (if necessary the window is first moved ahead), the replay list SHALL be updated with the new index.",
      "ja": "パケットが認証された後（必要に応じて、まずウィンドウが前方に移動されます）、リプレイリストは新しいインデックスで更新されるべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "The Replay List can be efficiently implemented by using a bitmap to represent which packets have been received, as described in the Security Architecture for IP [RFC2401].",
      "ja": "IP [RFC2401]のセキュリティアーキテクチャーで説明されているように、ビットマップを使用してどのパケットが受信されたかを示すことで、リプレイリストを効率的に実装することができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Secure RTCP",
      "section_title": true,
      "ja": "3.4. 安全なRTCP"
    },
    {
      "indent": 3,
      "text": "Secure RTCP follows the definition of Secure RTP. SRTCP adds three mandatory new fields (the SRTCP index, an \"encrypt-flag\", and the authentication tag) and one optional field (the MKI) to the RTCP packet definition. The three mandatory fields MUST be appended to an RTCP packet in order to form an equivalent SRTCP packet. The added fields follow any other profile-specific extensions.",
      "ja": "Secure RTCPはSecure RTPの定義に従います。SRTCPは、RTCPパケット定義に3つの必須の新しいフィールド（SRTCPインデックス、「暗号化フラグ」、および認証タグ）と1つのオプションフィールド（MKI）を追加します。同等のSRTCPパケットを形成するために、3つの必須フィールドをRTCPパケットに追加する必要があります。追加されたフィールドは他のプロファイル固有の拡張機能に従います。"
    },
    {
      "indent": 3,
      "text": "According to Section 6.1 of [RFC3550], there is a REQUIRED packet format for compound packets. SRTCP MUST be given packets according to that requirement in the sense that the first part MUST be a sender report or a receiver report. However, the RTCP encryption prefix (a random 32-bit quantity) specified in that Section MUST NOT be used since, as is stated there, it is only applicable to the encryption method specified in [RFC3550] and is not needed by the cryptographic mechanisms used in SRTP.",
      "ja": "[RFC3550]のセクション6.1によると、複合パケットに必要なパケットフォーマットがあります。SRTCPは、最初の部分が送信者レポートまたは受信者レポートでなければならないという意味で、その要件に従ってパケットを与えなければなりません。ただし、そのセクションで指定されたRTCP暗号化プレフィックス（ランダムな32ビット量）は、そこに記載されている通り、[RFC3550]で指定された暗号化方式にのみ適用され、SRTPで使用される暗号メカニズムには必要ないため、使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n  |V=2|P|    RC   |   PT=SR or RR   |             length          | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                         SSRC of sender                        | |\n+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| ~                          sender info                          ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                         report block 1                        ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                         report block 2                        ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                              ...                              ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| |V=2|P|    SC   |  PT=SDES=202  |             length            | |\n| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| |                          SSRC/CSRC_1                          | |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                           SDES items                          ~ |\n| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| ~                              ...                              ~ |\n+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| |E|                         SRTCP index                         | |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n| ~                     SRTCP MKI (OPTIONAL)                      ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| :                     authentication tag                        : |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n|                                                                   |\n+-- Encrypted Portion                    Authenticated Portion -----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 2. An example of the format of a Secure RTCP packet, consisting of an underlying RTCP compound packet with a Sender Report and SDES packet.",
      "ja": "図2.送信者レポートとSDESパケットを含む基盤となるRTCP複合パケットからなる安全なRTCPパケットのフォーマットの例。"
    },
    {
      "indent": 3,
      "text": "The Encrypted Portion of an SRTCP packet consists of the encryption (Section 4.1) of the RTCP payload of the equivalent compound RTCP packet, from the first RTCP packet, i.e., from the ninth (9) octet to the end of the compound packet. The Authenticated Portion of an SRTCP packet consists of the entire equivalent (eventually compound) RTCP packet, the E flag, and the SRTCP index (after any encryption has been applied to the payload).",
      "ja": "SRTCPパケットの暗号化部分は、最初のRTCPパケット、すなわち第9（9）オクテットから複合パケットの末尾までの、等価な複合RTCPパケットのRTCPペイロードの暗号化（セクション4.1）から構成されます。SRTCPパケットの認証部分は、等価な（最終的には複合）RTCPパケット全体、Eフラグ、およびSRTCPインデックス（ペイロードに何らかの暗号化が適用された後）から構成されます。"
    },
    {
      "indent": 3,
      "text": "The added fields are:",
      "ja": "追加されたフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "E-flag: 1 bit, REQUIRED The E-flag indicates if the current SRTCP packet is encrypted or unencrypted. Section 9.1 of [RFC3550] allows the split of a compound RTCP packet into two lower-layer packets, one to be encrypted and one to be sent in the clear. The E bit set to \"1\" indicates encrypted packet, and \"0\" indicates non-encrypted packet.",
      "ja": "E-Flag：1ビット、必須。Eフラグは、現在のSRTCPパケットが暗号化されているか、または暗号化されていないかを示します。[RFC3550]のセクション9.1は、複合RTCPパケットを2つの下位層パケットに分割することを許可しており、一方は暗号化され、もう一方は平文で送信されます。Eビットが「1」に設定されている場合は暗号化されたパケットを示し、「0」は暗号化されていないパケットを示します。"
    },
    {
      "indent": 3,
      "text": "SRTCP index: 31 bits, REQUIRED The SRTCP index is a 31-bit counter for the SRTCP packet. The index is explicitly included in each packet, in contrast to the \"implicit\" index approach used for SRTP. The SRTCP index MUST be set to zero before the first SRTCP packet is sent, and MUST be incremented by one, modulo 2^31, after each SRTCP packet is sent. In particular, after a re-key, the SRTCP index MUST NOT be reset to zero again.",
      "ja": "SRTCPインデックス：31ビット、必須。SRTCPインデックスはSRTCPパケットの31ビットカウンタです。SRTPに使用される「暗黙的」インデックスアプローチとは対照的に、インデックスは各パケットに明示的に含まれています。SRTCPインデックスは、最初のSRTCPパケットが送信される前にゼロに設定されなければならず（MUST）、各SRTCPパケットが送信された後にモジュロ2^31で1つインクリメントされなければなりません（MUST）。特に、再キーの後、SRTCPインデックスをゼロにリセットしてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Authentication Tag: configurable length, REQUIRED The authentication tag is used to carry message authentication data.",
      "ja": "認証タグ：設定可能な長さ、必須。認証タグはメッセージ認証データを伝達するために使用されます。"
    },
    {
      "indent": 3,
      "text": "MKI: configurable length, OPTIONAL The MKI is the Master Key Indicator, and functions according to the MKI definition in Section 3.",
      "ja": "MKI：設定可能な長さ、オプション。MKIはマスターキーインジケータであり、セクション3のMKI定義に従って機能します。"
    },
    {
      "indent": 3,
      "text": "SRTCP uses the cryptographic context parameters and packet processing of SRTP by default, with the following changes:",
      "ja": "SRTCPは、デフォルトでSRTPの暗号化コンテキストパラメータとパケット処理を使用します。ただし、以下の変更が適用されます。"
    },
    {
      "indent": 3,
      "text": "* The receiver does not need to \"estimate\" the index, as it is explicitly signaled in the packet.",
      "ja": "* 受信機は、パケット内で明示的にシグナリングされているため、インデックスを「推定」する必要はありません。"
    },
    {
      "indent": 0,
      "text": " * Pre-defined SRTCP encryption is as specified in Section 4.1, but using the definition of the SRTCP Encrypted Portion given in this section, and using the SRTCP index as the index i. The encryption transform and related parameters SHALL by default be the same selected for the protection of the associated SRTP stream(s), while the NULL algorithm SHALL be applied to the RTCP packets not to be encrypted. SRTCP may have a different encryption transform than the one used by the corresponding SRTP. The expected use for this feature is when the former has NULL-encryption and the latter has a non NULL-encryption.",
            "ja": "* 事前定義されたSRTCP暗号化はセクション4.1で指定されていますが、このセクションに記載されているSRTCP暗号化部分の定義を使用し、SRTCPインデックスをインデックスiとして使用します。暗号化変換および関連パラメータは、デフォルトでは、関連するSRTPストリームの保護に対して選択されたものとするものとしますが、NULLアルゴリズムは暗号化されないRTCPパケットに適用されます。SRTCPは、対応するSRTPによって使用されるものよりも異なる暗号化変換を持つことができます。この機能のための予想される使用は、前者がNULL暗号化を持ち、後者はNULL以外の暗号化を持ちます。"
    },
    {
      "indent": 3,
      "text": "The E-flag is assigned a value by the sender depending on whether the packet was encrypted or not.",
      "ja": "Eフラグには、パケットが暗号化されているかどうかに応じて送信者によって値が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "* SRTCP decryption is performed as in Section 4, but only if the E flag is equal to 1. If so, the Encrypted Portion is decrypted, using the SRTCP index as the index i. In case the E-flag is 0, the payload is simply left unmodified.",
      "ja": "* SRTCP復号化はセクション4のように実行されますが、Eフラグが1に等しい場合に限ります。その場合、暗号化部分はSRTCPインデックスをインデックスiとして使用して復号化されます。Eフラグが0の場合、ペイロードは単に変更されないままになります。"
    },
    {
      "indent": 3,
      "text": "* SRTCP replay protection is as defined in Section 3.3.2, but using the SRTCP index as the index i and a separate Replay List that is specific to SRTCP.",
      "ja": "* SRTCPリプレイ保護はセクション3.3.2で定義されていますが、SRTCPインデックスをインデックスiとして使用し、SRTCPに固有の別のリプレイリストを使用します。"
    },
    {
      "indent": 3,
      "text": "* The pre-defined SRTCP authentication tag is specified as in Section 4.2, but with the Authenticated Portion of the SRTCP packet given in this section (which includes the index). The authentication transform and related parameters (e.g., key size) SHALL by default be the same as selected for the protection of the associated SRTP stream(s).",
      "ja": "* 事前定義されたSRTCP認証タグはセクション4.2のように指定されていますが、このセクションで指定されたSRTCPパケットの認証済み部分（インデックスを含む）を使用します。認証変換および関連パラメータ（例えば、鍵サイズ）は、デフォルトでは、関連するSRTPストリームの保護のために選択されたものと同じでなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "* In the last step of the processing, only the sender needs to update the value of the SRTCP index by incrementing it modulo 2^31 and for security reasons the sender MUST also check the number of SRTCP packets processed, see Section 9.2.",
      "ja": "* 処理の最後のステップでは、送信者のみがSRTCPインデックスの値をモジュロ2^31でインクリメントして更新する必要があり、セキュリティ上の理由から、送信者は処理されたSRTCPパケットの数も確認しなければなりません（MUST）。セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Message authentication for RTCP is REQUIRED, as it is the control protocol (e.g., it has a BYE packet) for RTP.",
      "ja": "RTP用の制御プロトコル（例えば、BYEパケットがある）であるため、RTCPのメッセージ認証が必要です。"
    },
    {
      "indent": 3,
      "text": "Precautions must be taken so that the packet expansion in SRTCP (due to the added fields) does not cause SRTCP messages to use more than their share of RTCP bandwidth. To avoid this, the following two measures MUST be taken:",
      "ja": "SRTCPのパケット拡張（追加フィールドのため）にSRTCPメッセージがRTCP帯域幅のシェア以上の使用を引き起こさないように予防措置を講じる必要があります。これを回避するために、次の2つの対策をとる必要があります。"
    },
    {
      "indent": 3,
      "text": "1. When initializing the RTCP variable \"avg_rtcp_size\" defined in chapter 6.3 of [RFC3550], it MUST include the size of the fields that will be added by SRTCP (index, E-bit, authentication tag, and when present, the MKI).",
      "ja": "1. [RFC3550]の第6.3章で定義されているRTCP変数 \"avg_rtcp_size\"を初期化する場合は、SRTCP（インデックス、Eビット、認証タグ、および存在する場合、MKI）によって追加されるフィールドのサイズを含める必要があります（MUST）。"
    },
    {
      "indent": 3,
      "text": "2. When updating the \"avg_rtcp_size\" using the variable \"packet_size\" (section 6.3.3 of [RFC3550]), the value of \"packet_size\" MUST include the size of the additional fields added by SRTCP.",
      "ja": "2. 変数 \"packet_size\"（[RFC3550]のセクション6.3.3）を使用して \"avg_rtcp_size\"を更新する場合、 \"packet_size\"の値にはSRTCPによって追加された追加のフィールドのサイズが含まれている必要があります（MUST）。"
    },
    {
      "indent": 3,
      "text": "With these measures in place the SRTCP messages will not use more than the allotted bandwidth. The effect of the size of the added fields on the SRTCP traffic will be that messages will be sent with longer packet intervals. The increase in the intervals will be directly proportional to size of the added fields. For the pre-defined transforms, the size of the added fields will be at least 14 octets, and upper bounded depending on MKI and the authentication tag sizes.",
      "ja": "これらの対策が講じられれば、SRTCPメッセージは割り当てられた帯域幅を超えて使用されることはありません。SRTCPトラフィックに追加されるフィールドのサイズの影響は、メッセージがより長いパケット間隔で送信されるようになることです。間隔の増加は、追加されたフィールドのサイズに正比例します。事前定義された変換の場合、追加されるフィールドのサイズは少なくとも14オクテットであり、MKIと認証タグのサイズに応じて上限が設定されます。"
    },
    {
      "indent": 0,
      "text": "4. Pre-Defined Cryptographic Transforms",
      "section_title": true,
      "ja": "4. 事前定義された暗号変換"
    },
    {
      "indent": 3,
      "text": "While there are numerous encryption and message authentication algorithms that can be used in SRTP, below we define default algorithms in order to avoid the complexity of specifying the encodings for the signaling of algorithm and parameter identifiers. The defined algorithms have been chosen as they fulfill the goals listed in Section 2. Recommendations on how to extend SRTP with new transforms are given in Section 6.",
      "ja": "SRTPで使用できる多数の暗号化およびメッセージ認証アルゴリズムがありますが、アルゴリズムとパラメータ識別子のシグナリングのためのエンコーディングを指定する複雑さを回避するために、デフォルトのアルゴリズムを定義します。定義されたアルゴリズムは、それらがセクション2にリストされている目標を満たすため選択されました。SRTPを新しい変換で拡張する方法についての推奨事項をセクション6に示します。"
    },
    {
      "indent": 0,
      "text": "4.1. Encryption",
      "section_title": true,
      "ja": "4.1. 暗号化"
    },
    {
      "indent": 3,
      "text": "The following parameters are common to both pre-defined, non-NULL, encryption transforms specified in this section.",
      "ja": "以下のパラメータは、このセクションで指定されている事前定義された非NULLの暗号化変換の両方に共通です。"
    },
    {
      "indent": 3,
      "text": "* BLOCK_CIPHER-MODE indicates the block cipher used and its mode of operation * n_b is the bit-size of the block for the block cipher * k_e is the session encryption key * n_e is the bit-length of k_e * k_s is the session salting key * n_s is the bit-length of k_s * SRTP_PREFIX_LENGTH is the octet length of the keystream prefix, a non-negative integer, specified by the message authentication code in use.",
      "ja": "* BLOCK_CIPHER-MODE は使用されるブロック暗号とその動作モードを示します\n* n_b はブロック暗号のブロックのビットサイズです\n* k_e はセッション暗号化キーです\n* n_e は k_e のビット長です\n* k_s はセッションソルトキーです\n* n_s は k_s のビット長です\n* SRTP_PREFIX_LENGTH は、使用中のメッセージ認証コードで指定されるキーストリームプレフィックスのオクテット長であり、非負の整数です。"
    },
    {
      "indent": 3,
      "text": "The distinct session keys and salts for SRTP/SRTCP are by default derived as specified in Section 4.3.",
      "ja": "SRTP/SRTCPのための異なるセッションキーとソルトは、デフォルトではセクション4.3で指定されているように導出されます。"
    },
    {
      "indent": 3,
      "text": "The encryption transforms defined in SRTP map the SRTP packet index and secret key into a pseudo-random keystream segment. Each keystream segment encrypts a single RTP packet. The process of encrypting a packet consists of generating the keystream segment corresponding to the packet, and then bitwise exclusive-oring that keystream segment onto the payload of the RTP packet to produce the Encrypted Portion of the SRTP packet. In case the payload size is not an integer multiple of n_b bits, the excess (least significant) bits of the keystream are simply discarded. Decryption is done the same way, but swapping the roles of the plaintext and ciphertext.",
      "ja": "SRTPで定義されている暗号化変換は、SRTPパケットインデックスと秘密鍵を疑似ランダムキーストリームセグメントにマッピングします。各キーストリームセグメントは単一のRTPパケットを暗号化します。パケットを暗号化するプロセスは、パケットに対応するキーストリームセグメントを生成し、次いでそのキーストリームセグメントをRTPパケットのペイロード上にビットごとに排他的論理和をとってSRTPパケットの暗号化部分を生成することからなります。ペイロードサイズがn_bビットの整数倍ではない場合、キーストリームの過剰な（最下位）ビットは単に破棄されます。復号化は同じ方法で行われますが、平文と暗号文の役割を交換します。"
    },
    {
      "indent": 3,
      "text": "+----+   +------------------+---------------------------------+\n| KG |-->| Keystream Prefix |          Keystream Suffix       |---+\n+----+   +------------------+---------------------------------+   |\n                                                                  |\n                            +---------------------------------+   v\n                            |     Payload of RTP Packet       |->(*)\n                            +---------------------------------+   |\n                                                                  |\n                            +---------------------------------+   |\n                            | Encrypted Portion of SRTP Packet|<--+\n                            +---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3: Default SRTP Encryption Processing. Here KG denotes the keystream generator, and (*) denotes bitwise exclusive-or.",
      "ja": "図3：デフォルトのSRTP暗号化処理。ここで、KGはキーストリームジェネレータを表し、（*）はビット単位の排他的論理和です。"
    },
    {
      "indent": 3,
      "text": "The definition of how the keystream is generated, given the index, depends on the cipher and its mode of operation. Below, two such keystream generators are defined. The NULL cipher is also defined, to be used when encryption of RTP is not required.",
      "ja": "インデックスを指定して、キーストリームの生成方法の定義は、暗号とその動作モードによって異なります。以下では、2つのそのようなキーストリーム発生器が定義されています。NULL暗号は、RTPの暗号化が不要な場合に使用されるように定義されています。"
    },
    {
      "indent": 3,
      "text": "The SRTP definition of the keystream is illustrated in Figure 3. The initial octets of each keystream segment MAY be reserved for use in a message authentication code, in which case the keystream used for encryption starts immediately after the last reserved octet. The initial reserved octets are called the \"keystream prefix\" (not to be confused with the \"encryption prefix\" of [RFC3550, Section 6.1]), and the remaining octets are called the \"keystream suffix\". The keystream prefix MUST NOT be used for encryption. The process is illustrated in Figure 3.",
      "ja": "キーストリームのSRTP定義を図3に示します。各キーストリームセグメントの初期オクテットは、メッセージ認証コードで使用するために予約されている可能性があります。その場合、暗号化に使用されるキーストリームは最後の予約オクテットの直後に開始されます。初期予約済みオクテットは、「キーストリームプレフィックス」と呼ばれます（[RFC3550、セクション6.1]の「暗号化プレフィックス」と混乱しないでください）、残りのオクテットは「キーストリームサフィックス」と呼ばれます。キーストリームプレフィックスは暗号化に使用しないでください。プロセスを図3に示す。"
    },
    {
      "indent": 3,
      "text": "The number of octets in the keystream prefix is denoted as SRTP_PREFIX_LENGTH. The keystream prefix is indicated by a positive, non-zero value of SRTP_PREFIX_LENGTH. This means that, even if confidentiality is not to be provided, the keystream generator output may still need to be computed for packet authentication, in which case the default keystream generator (mode) SHALL be used.",
      "ja": "キーストリームプレフィックス内のオクテット数はSRTP_PREFIX_LENGTHとして示されます。キーストリームプレフィックスは、SRTP_PREFIX_LENGTHの正のゼロ以外の値で示されます。これは、機密性が提供されない場合であっても、キーストリームジェネレータ出力は依然としてパケット認証のために計算される必要があるかもしれないことを意味し、その場合、デフォルトのキーストリームジェネレータ（モード）を使用すべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "The default cipher is the Advanced Encryption Standard (AES) [AES], and we define two modes of running AES, (1) Segmented Integer Counter Mode AES and (2) AES in f8-mode. In the remainder of this section, let E(k,x) be AES applied to key k and input block x.",
      "ja": "デフォルトの暗号はAdvanced Encryption Standard (AES) [AES]であり、AESの2つの動作モード、(1) Segmented Integer Counter Mode AESと(2) f8モードのAESを定義します。このセクションの残りの部分では、E(k,x) をキーkと入力ブロックxに適用されたAESとします。"
    },
    {
      "indent": 0,
      "text": "4.1.1. AES in Counter Mode",
      "section_title": true,
      "ja": "4.1.1. カウンターモードのAES"
    },
    {
      "indent": 3,
      "text": "Conceptually, counter mode [AES-CTR] consists of encrypting successive integers. The actual definition is somewhat more complicated, in order to randomize the starting point of the integer sequence. Each packet is encrypted with a distinct keystream segment, which SHALL be computed as follows.",
      "ja": "概念的には、カウンタモード[AES-CTR]は、連続する整数を暗号化することです。整数シーケンスの開始点をランダム化するために、実際の定義はやや複雑です。各パケットは異なるキーストリームセグメントで暗号化されています。これは次のように計算されます。"
    },
    {
      "indent": 3,
      "text": "A keystream segment SHALL be the concatenation of the 128-bit output blocks of the AES cipher in the encrypt direction, using key k = k_e, in which the block indices are in increasing order. Symbolically, each keystream segment looks like",
      "ja": "キーストリームセグメントは、キーk = k_eを使用して、AES暗号の128ビットの出力ブロックを暗号化方向に連結したもので、ブロックインデックスは増加順序になっています。象徴的には、各キーストリームセグメントは次のようになります。"
    },
    {
      "indent": 6,
      "text": "E(k, IV) || E(k, IV + 1 mod 2^128) || E(k, IV + 2 mod 2^128) ...",
      "ja": "E(k, IV) || E(k, IV + 1 mod 2^128) || E(k, IV + 2 mod 2^128) ..."
    },
    {
      "indent": 3,
      "text": "where the 128-bit integer value IV SHALL be defined by the SSRC, the SRTP packet index i, and the SRTP session salting key k_s, as below.",
      "ja": "ここで、128ビット整数値IVは、SSRC、SRTPパケットインデックスi、およびSRTPセッションソルトキーk_sによって定義されるものとします（SHALL）。"
    },
    {
      "indent": 6,
      "text": "IV = (k_s * 2^16) XOR (SSRC * 2^64) XOR (i * 2^16)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each of the three terms in the XOR-sum above is padded with as many leading zeros as needed to make the operation well-defined, considered as a 128-bit value.",
      "ja": "上記のXOR-SUMの3つの項のそれぞれには、128ビット値と見なされる操作を明確に定義するために必要なだけ多くの先行ゼロで埋められます。"
    },
    {
      "indent": 3,
      "text": "The inclusion of the SSRC allows the use of the same key to protect distinct SRTP streams within the same RTP session, see the security caveats in Section 9.1.",
      "ja": "SSRCを含めることで、同じキーを使用して同じRTPセッション内で異なるSRTPストリームを保護することが可能になります。セクション9.1のセキュリティ上の注意点を参照してください。"
    },
    {
      "indent": 3,
      "text": "In the case of SRTCP, the SSRC of the first header of the compound packet MUST be used, i SHALL be the 31-bit SRTCP index and k_e, k_s SHALL be replaced by the SRTCP encryption session key and salt.",
      "ja": "SRTCPの場合、複合パケットの最初のヘッダーのSSRCを使用する必要があります（MUST）。iは31ビットSRTCPインデックスとなり、k_e、k_sはSRTCP暗号化セッションキーとソルトに置き換えられるべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Note that the initial value, IV, is fixed for each packet and is formed by \"reserving\" 16 zeros in the least significant bits for the purpose of the counter. The number of blocks of keystream generated for any fixed value of IV MUST NOT exceed 2^16 to avoid keystream re-use, see below. The AES has a block size of 128 bits, so 2^16 output blocks are sufficient to generate the 2^23 bits of keystream needed to encrypt the largest possible RTP packet (except for IPv6 \"jumbograms\" [RFC2675], which are not likely to be used for RTP-based multimedia traffic). This restriction on the maximum bit-size of the packet that can be encrypted ensures the security of the encryption method by limiting the effectiveness of probabilistic attacks [BDJR].",
      "ja": "なお、初期値IVは各パケットに対して固定され、カウンタの目的のために最下位ビットに16個のゼロを「予約」することによって形成されます。IVの固定値に対して生成されたキーストリームのブロック数は、キーストリームの再利用を避けるために2^16を超えてはいけません（MUST NOT）。AESはブロックサイズが128ビットであるため、2^16出力ブロックは、最大可能なRTPパケットを暗号化するのに必要な2^23ビットのキーストリームを生成するのに十分です（IPv6 \"Jumbograms\" [RFC2675]を除く。これらはRTPベースのマルチメディアトラフィックには使用されない可能性が高いです）。暗号化できるパケットの最大ビットサイズに対するこの制限は、確率論的攻撃の有効性を制限することによって暗号化方法のセキュリティを確保します[BDJR]。"
    },
    {
      "indent": 0,
      "text": " For a particular Counter Mode key, each IV value used as an input MUST be distinct, in order to avoid the security exposure of a two-time pad situation (Section 9.1). To satisfy this constraint, an implementation MUST ensure that the combination of the SRTP packet index of ROC || SEQ, and the SSRC used in the construction of the IV are distinct for any particular key. The failure to ensure this uniqueness could be catastrophic for Secure RTP. This is in contrast to the situation for RTP itself, which may be able to tolerate such failures. It is RECOMMENDED that, if a dedicated security module is present, the RTP sequence numbers and SSRC either be generated or checked by that module (i.e., sequence-number and SSRC processing in an SRTP system needs to be protected as well as the key).",
      "ja": "特定のカウンタモードキーの場合、2タイムパッド状況のセキュリティ露出（セクション9.1）を避けるために、入力として使用される各IV値は異なっている必要があります（MUST）。この制約を満たすために、実装は、IVの構成に使用されるROC || SEQのSRTPパケットインデックスとSSRCの組み合わせが、特定のキーに対して一意であることを保証しなければなりません（MUST）。この一意性を保証できない場合、セキュアRTPにとって壊滅的な影響を及ぼす可能性があります。これは、そのような障害を許容できる可能性のあるRTP自体の状況とは対照的です。専用のセキュリティモジュールが存在する場合、RTPシーケンス番号とSSRCは、そのモジュールによって生成またはチェックされることを推奨します（RECOMMENDED）（すなわち、SRTPシステムにおけるシーケンス番号とSSRCの処理は、キーと同様に保護される必要があります）。"
    },
    {
      "indent": 0,
      "text": "4.1.2. AES in f8-mode",
      "section_title": true,
      "ja": "4.1.2. F8モードのAES"
    },
    {
      "indent": 3,
      "text": "To encrypt UMTS (Universal Mobile Telecommunications System, as 3G networks) data, a solution (see [f8-a] [f8-b]) known as the f8- algorithm has been developed. On a high level, the proposed scheme is a variant of Output Feedback Mode (OFB) [HAC], with a more elaborate initialization and feedback function. As in normal OFB, the core consists of a block cipher. We also define here the use of AES as a block cipher to be used in what we shall call \"f8-mode of operation\" RTP encryption. The AES f8-mode SHALL use the same default sizes for session key and salt as AES counter mode.",
      "ja": "UMTS（Universal Mobile Telecommunications System、3Gネットワークとして）データを暗号化するために、f8-アルゴリズムとして知られるソリューション（[f8-a] [f8-b]参照）が開発されました。高レベルでは、提案されたスキームは、より精巧な初期化およびフィードバック機能を持つOutput Feedback Mode (OFB) [HAC]の変形です。通常のOFBと同様に、コアはブロック暗号で構成されます。ここでは、「f8モード」RTP暗号化と呼ぶもので使用されるブロック暗号としてのAESの使用も定義します。AES f8モードは、セッションキーとソルトのためにAESカウンタモードと同じデフォルトサイズを使用しなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the structure of block cipher, E, running in f8-mode.",
      "ja": "図4は、F8モードで動作しているブロック暗号、Eの構造を示しています。"
    },
    {
      "indent": 4,
      "text": "                IV\n                |\n                v\n            +------+\n            |      |\n       +--->|  E   |\n       |    +------+\n       |        |\n m -> (*)       +-----------+-------------+--  ...     ------+\n       |    IV' |           |             |                  |\n       |        |   j=1 -> (*)    j=2 -> (*)   ...  j=L-1 ->(*)\n       |        |           |             |                  |\n       |        |      +-> (*)       +-> (*)   ...      +-> (*)\n       |        |      |    |        |    |             |    |\n       |        v      |    v        |    v             |    v\n       |    +------+   | +------+    | +------+         | +------+\nk_e ---+--->|  E   |   | |  E   |    | |  E   |         | |  E   |\n            |      |   | |      |    | |      |         | |      |\n            +------+   | +------+    | +------+         | +------+\n                |      |    |        |    |             |    |\n                +------+    +--------+    +--  ...  ----+    |\n                |           |             |                  |\n                v           v             v                  v\n               S(0)        S(1)          S(2)  . . .       S(L-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4. f8-mode of operation (asterisk, (*), denotes bitwise XOR). The figure represents the KG in Figure 3, when AES-f8 is used.",
      "ja": "図4. f8モードの動作（アスタリスク、（*）、はビット単位のXORを示します）。この図は、AES-f8が使用されている場合の図3のKGを表します。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. f8 Keystream Generation",
      "section_title": true,
      "ja": "4.1.2.1. f8 キーストリーム生成"
    },
    {
      "indent": 3,
      "text": "The Initialization Vector (IV) SHALL be determined as described in Section 4.1.2.2 (and in Section 4.1.2.3 for SRTCP).",
      "ja": "初期化ベクトル（IV）は、セクション4.1.2.2（およびSRTCPの4.1.2.3項で）に記載されているように決定されなければならない。"
    },
    {
      "indent": 3,
      "text": "Let IV', S(j), and m denote n_b-bit blocks.  The keystream,\nS(0) ||... || S(L-1), for an N-bit message SHALL be defined by\nsetting IV' = E(k_e XOR m, IV), and S(-1) = 00..0.  For\nj = 0,1,..,L-1 where L = N/n_b (rounded up to nearest integer if it\nis not already an integer) compute",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "S(j) = E(k_e, IV' XOR j XOR S(j-1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Notice that the IV is not used directly. Instead it is fed through E under another key to produce an internal, \"masked\" value (denoted IV') to prevent an attacker from gaining known input/output pairs.",
      "ja": "IVが直接使用されていないことに注意してください。代わりに、攻撃者が既知の入出力ペアを得るのを防ぐために、別のキーの下でEに入力され、内部的な「マスクされた」値（IV'と表記）を生成します。"
    },
    {
      "indent": 3,
      "text": "The role of the internal counter, j, is to prevent short keystream cycles. The value of the key mask m SHALL be",
      "ja": "内部カウンタjの役割は、短いキーストリームサイクルを防ぐことです。キーマスクmの値は以下の通りです（SHALL）。"
    },
    {
      "indent": 11,
      "text": "m = k_s || 0x555..5,",
      "ja": "m = k_s || 0x555..5,"
    },
    {
      "indent": 3,
      "text": "i.e., the session salting key, appended by the binary pattern 0101.. to fill out the entire desired key size, n_e.",
      "ja": "すなわち、所望のキーサイズn_e全体を埋めるために、バイナリパターン0101..によって追加されたセッションソルトキーです。"
    },
    {
      "indent": 3,
      "text": "The sender SHOULD NOT generate more than 2^32 blocks, which is sufficient to generate 2^39 bits of keystream. Unlike counter mode, there is no absolute threshold above (below) which f8 is guaranteed to be insecure (secure). The above bound has been chosen to limit, with sufficient security margin, the probability of degenerative behavior in the f8 keystream generation.",
      "ja": "送信者は2^32ブロックを超えて生成すべきではありません（SHOULD NOT）。これは、2^39ビットのキーストリームを生成するのに十分です。カウンタモードとは異なり、f8が安全である（または安全でない）ことを保証する絶対的な閾値は、これ以上（以下）ありません。上記の制限は、十分なセキュリティマージンをもって、f8キーストリーム生成における退化的振る舞いの確率を制限するために選択されています。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. f8 SRTP IV Formation",
      "section_title": true,
      "ja": "4.1.2.2. f8 SRTP IV生成"
    },
    {
      "indent": 3,
      "text": "The purpose of the following IV formation is to provide a feature which we call implicit header authentication (IHA), see Section 9.5.",
      "ja": "次のIV形成の目的は、暗黙的ヘッダー認証（IHA）を呼び出す機能を提供することです。セクション9.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SRTP IV for 128-bit block AES-f8 SHALL be formed in the following way:",
      "ja": "128ビットブロックAES-f8用のSRTP IVは、以下の方法で形成されるべきです（SHALL）。"
    },
    {
      "indent": 8,
      "text": "IV = 0x00 || M || PT || SEQ || TS || SSRC || ROC",
      "ja": "IV = 0x00 || M || PT || SEQ || TS || SSRC || ROC"
    },
    {
      "indent": 3,
      "text": "M, PT, SEQ, TS, SSRC SHALL be taken from the RTP header; ROC is from the cryptographic context.",
      "ja": "M、PT、SEQ、TS、SSRCはRTPヘッダーから取得されるべきです（SHALL）。ROCは暗号化コンテキストからのものです。"
    },
    {
      "indent": 3,
      "text": "The presence of the SSRC as part of the IV allows AES-f8 to be used when a master key is shared between multiple streams within the same RTP session, see Section 9.1.",
      "ja": "IVの一部としてのSSRCの存在は、同じRTPセッション内の複数のストリーム間でマスターキーが共有されているときにAES-f8を使用することを可能にします。セクション9.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1.2.3. f8 SRTCP IV Formation",
      "section_title": true,
      "ja": "4.1.2.3. f8 SRTCP IV生成"
    },
    {
      "indent": 3,
      "text": "The SRTCP IV for 128-bit block AES-f8 SHALL be formed in the following way:",
      "ja": "128ビットブロックAES-f8用のSRTCP IVは、以下の方法で形成されるべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "IV= 0..0 || E || SRTCP index || V || P || RC || PT || length || SSRC",
      "ja": "IV= 0..0 || E || SRTCP index || V || P || RC || PT || length || SSRC"
    },
    {
      "indent": 3,
      "text": "where V, P, RC, PT, length, SSRC SHALL be taken from the first header in the RTCP compound packet. E and SRTCP index are the 1-bit and 31-bit fields added to the packet.",
      "ja": "V、P、RC、PT、長さ、SSRCは、RTCP複合パケットの最初のヘッダーから取得されます。EとSRTCP Indexは、パケットに追加された1ビットフィールドと31ビットのフィールドです。ッダーから取得されます。EとSRTCP Indexは、パケットに追加された1ビットフィールドと31ビットのフィールドです。"
    },
    {
      "indent": 0,
      "text": "4.1.3. NULL Cipher",
      "section_title": true,
      "ja": "4.1.3. NULL暗号"
    },
    {
      "indent": 3,
      "text": "The NULL cipher is used when no confidentiality for RTP/RTCP is requested. The keystream can be thought of as \"000..0\", i.e., the encryption SHALL simply copy the plaintext input into the ciphertext output.",
      "ja": "NULL暗号は、RTP/RTCPの機密性が要求されていない場合に使用されます。キーストリームは「000..0」と考えることができます。すなわち、暗号化は平文入力を暗号文出力に単にコピーするべきです（SHALL）。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Authentication and Integrity",
      "section_title": true,
      "ja": "4.2. メッセージ認証と整合性"
    },
    {
      "indent": 3,
      "text": "Throughout this section, M will denote data to be integrity protected. In the case of SRTP, M SHALL consist of the Authenticated Portion of the packet (as specified in Figure 1) concatenated with the ROC, M = Authenticated Portion || ROC; in the case of SRTCP, M SHALL consist of the Authenticated Portion (as specified in Figure 2) only.",
      "ja": "このセクションを通して、Mは整合性保護されるデータを表します。SRTPの場合、Mは、ROCと連結されたパケットの認証部分（図1で指定）で構成されます（SHALL）。すなわち M = 認証部分 || ROC です。SRTCPの場合、Mは認証部分（図2で指定）のみで構成されます（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Common parameters:",
      "ja": "一般的なパラメータ："
    },
    {
      "indent": 3,
      "text": "* AUTH_ALG is the authentication algorithm * k_a is the session message authentication key * n_a is the bit-length of the authentication key * n_tag is the bit-length of the output authentication tag * SRTP_PREFIX_LENGTH is the octet length of the keystream prefix as defined above, a parameter of AUTH_ALG",
      "ja": "* AUTH_ALGは認証アルゴリズムです\n* k_aはセッションメッセージ認証キーです\n* n_aは認証キーのビット長です\n* n_tagは出力認証タグのビット長です\n* SRTP_PREFIX_LENGTHは上記で定義されたキーストリームプレフィックスのオクテット長であり、AUTH_ALGのパラメータです"
    },
    {
      "indent": 3,
      "text": "The distinct session authentication keys for SRTP/SRTCP are by default derived as specified in Section 4.3.",
      "ja": "SRTP / SRTCPのための異なるセッション認証キーは、セクション4.3で指定されているようにデフォルトで派生しています。"
    },
    {
      "indent": 3,
      "text": "The values of n_a, n_tag, and SRTP_PREFIX_LENGTH MUST be fixed for any particular fixed value of the key.",
      "ja": "n_a、n_tag、およびSRTP_PREFIX_LENGTHの値は、キーの特定の固定値に対して固定されなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "We describe the process of computing authentication tags as follows. The sender computes the tag of M and appends it to the packet. The SRTP receiver verifies a message/authentication tag pair by computing a new authentication tag over M using the selected algorithm and key, and then compares it to the tag associated with the received message. If the two tags are equal, then the message/tag pair is valid; otherwise, it is invalid and the error audit message \"AUTHENTICATION FAILURE\" MUST be returned.",
      "ja": "次のように認証タグを計算するプロセスについて説明します。送信者はMのタグを計算し、それをパケットに追加します。SRTP受信機は、選択されたアルゴリズムとキーを使用してMに対する新しい認証タグを計算し、それを受信したメッセージに関連付けられたタグと比較することによって、メッセージ/認証タグのペアを検証します。2つのタグが等しい場合、メッセージ/タグのペアは有効です。それ以外の場合は無効であり、エラー監査メッセージ「認証失敗」を返さなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "4.2.1. HMAC-SHA1",
      "section_title": true,
      "ja": "4.2.1. HMAC-SHA1"
    },
    {
      "indent": 3,
      "text": "The pre-defined authentication transform for SRTP is HMAC-SHA1 [RFC2104]. With HMAC-SHA1, the SRTP_PREFIX_LENGTH (Figure 3) SHALL be 0. For SRTP (respectively SRTCP), the HMAC SHALL be applied to the session authentication key and M as specified above, i.e., HMAC(k_a, M). The HMAC output SHALL then be truncated to the n_tag left-most bits.",
      "ja": "SRTPの事前定義された認証変換はHMAC-SHA1 [RFC2104]です。HMAC-SHA1では、SRTP_PREFIX_LENGTH（図3）は0とします。SRTP（それぞれSRTCP）では、HMACをセッション認証キーk_aとMに、上記で指定された通り適用すべきです（SHALL）。すなわち、HMAC(k_a, M)です。その後、HMAC出力は左端のn_tagビットに切り捨てられるべきです（SHALL）。"
    },
    {
      "indent": 0,
      "text": "4.3. Key Derivation",
      "section_title": true,
      "ja": "4.3. 鍵導出"
    },
    {
      "indent": 0,
      "text": "4.3.1. Key Derivation Algorithm",
      "section_title": true,
      "ja": "4.3.1. 鍵導出アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Regardless of the encryption or message authentication transform that is employed (it may be an SRTP pre-defined transform or newly introduced according to Section 6), interoperable SRTP implementations MUST use the SRTP key derivation to generate session keys. Once the key derivation rate is properly signaled at the start of the session, there is no need for extra communication between the parties that use SRTP key derivation.",
      "ja": "採用されている暗号化またはメッセージ認証変換に関わらず（それがSRTPの事前定義された変換であるか、セクション6に従って新しく導入されたものであるかにかかわらず）、相互運用可能なSRTP実装は、セッション鍵を生成するためにSRTP鍵導出を使用しなければなりません（MUST）。セッション開始時に鍵導出率が適切にシグナリングされれば、SRTP鍵導出を使用する当事者間での追加の通信は不要です。"
    },
    {
      "indent": 15,
      "text": "          packet index ---+\n                          |\n                          v\n+-----------+ master  +--------+ session encr_key\n| ext       | key     |        |---------->\n| key mgmt  |-------->|  key   | session auth_key\n| (optional |         | deriv  |---------->\n| rekey)    |-------->|        | session salt_key\n|           | master  |        |---------->\n+-----------+ salt    +--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 5: SRTP key derivation.",
      "ja": "図5：SRTPの鍵導出"
    },
    {
      "indent": 3,
      "text": "At least one initial key derivation SHALL be performed by SRTP, i.e., the first key derivation is REQUIRED. Further applications of the key derivation MAY be performed, according to the \"key_derivation_rate\" value in the cryptographic context. The key derivation function SHALL initially be invoked before the first packet and then, when r > 0, a key derivation is performed whenever index mod r equals zero. This can be thought of as \"refreshing\" the session keys. The value of \"key_derivation_rate\" MUST be kept fixed for the lifetime of the associated master key.",
      "ja": "SRTPによって少なくとも1回の初期鍵導出が実行されなければなりません（SHALL）、つまり最初の鍵導出は必須（REQUIRED）です。暗号コンテキストの「key_derivation_rate」の値に応じて、鍵導出のさらなる適用が行われてもよい（MAY）。鍵導出関数は、最初のパケットの前に最初に呼び出され、r > 0 の場合、インデックス mod r がゼロに等しくなるたびに実行されます。これはセッション鍵を「リフレッシュ」すると考えることができます。「key_derivation_rate」の値は、関連するマスター鍵の存続期間中、固定されなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Interoperable SRTP implementations MAY also derive session salting keys for encryption transforms, as is done in both of the pre-defined transforms.",
      "ja": "相互運用可能なSRTP実装は、事前定義された両方の変換で行われるように、暗号化変換のためのセッションソルト鍵を導出してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Let m and n be positive integers. A pseudo-random function family is a set of keyed functions {PRF_n(k,x)} such that for the (secret) random key k, given m-bit x, PRF_n(k,x) is an n-bit string, computationally indistinguishable from random n-bit strings, see [HAC]. For the purpose of key derivation in SRTP, a secure PRF with m = 128 (or more) MUST be used, and a default PRF transform is defined in Section 4.3.3.",
      "ja": "mとnを正の整数とします。疑似乱数関数（PRF）ファミリーは、鍵付き関数の集合 {PRF_n(k,x)} であり、（秘密の）ランダムな鍵kとmビットのxが与えられたとき、PRF_n(k,x) はランダムなnビット文字列と計算上区別できないnビット文字列です（[HAC]参照）。SRTPの鍵導出のためには、m=128（またはそれ以上）の安全なPRFを使用しなければならず（MUST）、デフォルトのPRF変換はセクション4.3.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Let \"a DIV t\" denote integer division of a by t, rounded down, and with the convention that \"a DIV 0 = 0\" for all a. We also make the convention of treating \"a DIV t\" as a bit string of the same length as a, and thus \"a DIV t\" will in general have leading zeros.",
      "ja": "「a DIV t」は、aをtで割った整数除算（切り捨て）を表し、すべてのaに対して「a DIV 0 = 0」という規約に従います。また、「a DIV t」をaと同じ長さのビット列として扱う規約も採用しており、そのため「a DIV t」は一般的に先行ゼロを持ちます。"
    },
    {
      "indent": 3,
      "text": "Key derivation SHALL be defined as follows in terms of <label>, an 8-bit constant (see below), master_salt and key_derivation_rate, as determined in the cryptographic context, and index, the packet index (i.e., the 48-bit ROC || SEQ for SRTP):",
      "ja": "鍵導出は、暗号コンテキストで決定される<label>（8ビット定数、下記参照）、master_salt、key_derivation_rate、およびパケットインデックス（SRTPの場合は48ビットのROC || SEQ）に関して、次のように定義されなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "* Let r = index DIV key_derivation_rate (with DIV as defined above).",
      "ja": "* r = index DIV key_derivation_rate とします（上記定義のDIVを使用）。"
    },
    {
      "indent": 3,
      "text": "* Let key_id = <label> || r.",
      "ja": "* key_id = <label> || r とします。"
    },
    {
      "indent": 3,
      "text": "* Let x = key_id XOR master_salt, where key_id and master_salt are aligned so that their least significant bits agree (right-alignment).",
      "ja": "* x = key_id XOR master_salt とします。ここで、key_idとmaster_saltは、それらの最下位ビットが一致するように右寄せでアラインされます。"
    },
    {
      "indent": 3,
      "text": "<label> MUST be unique for each type of key to be derived. We currently define <label> 0x00 to 0x05 (see below), and future extensions MAY specify new values in the range 0x06 to 0xff for other purposes. The n-bit SRTP key (or salt) for this packet SHALL then be derived from the master key, k_master as follows:",
      "ja": "<label>は、導出される鍵の種類ごとに一意でなければなりません（MUST）。現在、<label>として0x00から0x05までを定義しており（下記参照）、将来の拡張で他の目的のために0x06から0xffの範囲で新しい値を指定してもよい（MAY）。このパケットのnビットSRTP鍵（またはソルト）は、次のようにマスター鍵k_masterから導出されなければなりません（SHALL）。"
    },
    {
      "indent": 6,
      "text": "PRF_n(k_master, x).",
      "ja": "PRF_n(k_master, x)"
    },
    {
      "indent": 3,
      "text": "(The PRF may internally specify additional formatting and padding of x, see e.g., Section 4.3.3 for the default PRF.)",
      "ja": "（PRFは、内部的にxの追加のフォーマットやパディングを指定することがあります。デフォルトのPRFについては、例えばセクション4.3.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The session keys and salt SHALL now be derived using:",
      "ja": "セッション鍵とソルトは、以下を使用して導出されなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "- k_e (SRTP encryption): <label> = 0x00, n = n_e.",
      "ja": "- k_e (SRTP暗号化): <label> = 0x00, n = n_e"
    },
    {
      "indent": 3,
      "text": "- k_a (SRTP message authentication): <label> = 0x01, n = n_a.",
      "ja": "- k_a (SRTPメッセージ認証): <label> = 0x01, n = n_a"
    },
    {
      "indent": 3,
      "text": "- k_s (SRTP salting key): <label> = 0x02, n = n_s.",
      "ja": "- k_s (SRTPソルト鍵): <label> = 0x02, n = n_s"
    },
    {
      "indent": 3,
      "text": "where n_e, n_s, and n_a are from the cryptographic context.",
      "ja": "ここで、n_e、n_s、n_aは暗号コンテキストからのものです。"
    },
    {
      "indent": 3,
      "text": "The master key and master salt MUST be random, but the master salt MAY be public.",
      "ja": "マスター鍵とマスターソルトはランダムでなければなりませんが（MUST）、マスターソルトは公開してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Note that for a key_derivation_rate of 0, the application of the key derivation SHALL take place exactly once.",
      "ja": "key_derivation_rateが0の場合、鍵導出の適用は正確に1回行われなければなりません（SHALL）。"
    },
    {
      "indent": 0,
      "text": " The definition of DIV above is purely for notational convenience. For a non-zero t among the set of allowed key derivation rates, \"a DIV t\" can be implemented as a right-shift by the base-2 logarithm of t. The derivation operation is further facilitated if the rates are chosen to be powers of 256, but that granularity was considered too coarse to be a requirement of this specification.",
      "ja": "上記のDIVの定義は、純粋に表記の便宜上のものです。許容される鍵導出率のセットの中でゼロでないtに対して、「a DIV t」は、tの底2の対数による右シフトとして実装できます。レートを256のべき乗として選択すると、導出操作はさらに容易になりますが、その粒度はこの仕様の要件としては粗すぎると考えられました。"
    },
    {
      "indent": 3,
      "text": "The upper limit on the number of packets that can be secured using the same master key (see Section 9.2) is independent of the key derivation.",
      "ja": "同じマスター鍵を使用して保護できるパケット数の上限（セクション9.2参照）は、鍵導出とは無関係です。"
    },
    {
      "indent": 0,
      "text": "4.3.2. SRTCP Key Derivation",
      "section_title": true,
      "ja": "4.3.2. SRTCPの鍵導出"
    },
    {
      "indent": 3,
      "text": "SRTCP SHALL by default use the same master key (and master salt) as SRTP. To do this securely, the following changes SHALL be done to the definitions in Section 4.3.1 when applying session key derivation for SRTCP.",
      "ja": "SRTCPは、デフォルトでSRTPと同じマスター鍵（およびマスターソルト）を使用しなければなりません（SHALL）。これを安全に行うために、SRTCPのセッション鍵導出を適用する際には、セクション4.3.1の定義に以下の変更を加えなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Replace the SRTP index by the 32-bit quantity: 0 || SRTCP index (i.e., excluding the E-bit, replacing it with a fixed 0-bit), and use <label> = 0x03 for the SRTCP encryption key, <label> = 0x04 for the SRTCP authentication key, and, <label> = 0x05 for the SRTCP salting key.",
      "ja": "SRTPインデックスを32ビットの値「0 || SRTCPインデックス」（つまり、Eビットを除外し、固定の0ビットに置き換える）に置き換え、SRTCP暗号化鍵には<label> = 0x03、SRTCP認証鍵には<label> = 0x04、SRTCPソルト鍵には<label> = 0x05を使用します。"
    },
    {
      "indent": 0,
      "text": "4.3.3. AES-CM PRF",
      "section_title": true,
      "ja": "4.3.3. AES-CM PRF"
    },
    {
      "indent": 3,
      "text": "The currently defined PRF, keyed by 128, 192, or 256 bit master key, has input block size m = 128 and can produce n-bit outputs for n up to 2^23. PRF_n(k_master,x) SHALL be AES in Counter Mode as described in Section 4.1.1, applied to key k_master, and IV equal to (x*2^16), and with the output keystream truncated to the n first (left-most) bits. (Requiring n/128, rounded up, applications of AES.)",
      "ja": "現在定義されているPRFは、128、192、または256ビットのマスター鍵でキー付けされ、入力ブロックサイズm = 128で、最大2^23までのnビット出力を生成できます。PRF_n(k_master,x)は、セクション4.1.1で説明されているカウンターモードのAESでなければならず（SHALL）、鍵k_masterとIV=(x*2^16)に適用され、出力キーストリームは最初のnビット（左端）に切り捨てられます。（AESの適用回数はn/128を切り上げたものが必要です。）"
    },
    {
      "indent": 0,
      "text": "5. Default and mandatory-to-implement Transforms",
      "section_title": true,
      "ja": "5. デフォルトおよび実装必須の変換"
    },
    {
      "indent": 3,
      "text": "The default transforms also are mandatory-to-implement transforms in SRTP. Of course, \"mandatory-to-implement\" does not imply \"mandatory-to-use\". Table 1 summarizes the pre-defined transforms. The default values below are valid for the pre-defined transforms.",
      "ja": "デフォルトの変換は、SRTPにおいて実装が必須の変換でもあります。もちろん、「実装が必須」は「使用が必須」を意味するものではありません。表1は、事前定義された変換をまとめたものです。以下のデフォルト値は、事前定義の変換に有効です。"
    },
    {
      "indent": 25,
      "text": "mandatory-to-impl. optional default",
      "ja": "実装必須               オプション      デフォルト"
    },
    {
      "indent": 3,
      "text": "encryption AES-CM, NULL AES-f8 AES-CM message integrity HMAC-SHA1 - HMAC-SHA1 key derivation (PRF) AES-CM - AES-CM",
      "ja": "暗号化              AES-CM, NULL      AES-f8          AES-CM\nメッセージ完全性    HMAC-SHA1         -               HMAC-SHA1\n鍵導出(PRF)         AES-CM            -               AES-CM"
    },
    {
      "indent": 3,
      "text": "Table 1: Mandatory-to-implement, optional and default transforms in SRTP and SRTCP.",
      "ja": "表1：SRTPとSRTCPにおける必須実装、オプション、およびデフォルトの変換。"
    },
    {
      "indent": 0,
      "text": "5.1. Encryption: AES-CM and NULL",
      "section_title": true,
      "ja": "5.1. 暗号化：AES-CMとNULL"
    },
    {
      "indent": 3,
      "text": "AES running in Segmented Integer Counter Mode, as defined in Section 4.1.1, SHALL be the default encryption algorithm. The default key lengths SHALL be 128-bit for the session encryption key (n_e). The default session salt key-length (n_s) SHALL be 112 bits.",
      "ja": "セクション4.1.1で定義されているように、Segmented Integer Counter Modeで実行されているAESは、デフォルトの暗号化アルゴリズムとなるべきです（SHALL）。デフォルトのキー長は、セッション暗号化キー（n_e）に対して128ビットとなるべきです（SHALL）。デフォルトのセッションソルトキー長（n_s）は112ビットとなるべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "The NULL cipher SHALL also be mandatory-to-implement.",
      "ja": "NULL暗号も必須実装となるべきです（SHALL）。"
    },
    {
      "indent": 0,
      "text": "5.2. Message Authentication/Integrity: HMAC-SHA1",
      "section_title": true,
      "ja": "5.2. メッセージ認証/整合性：HMAC-SHA1"
    },
    {
      "indent": 3,
      "text": "HMAC-SHA1, as defined in Section 4.2.1, SHALL be the default message authentication code. The default session authentication key-length (n_a) SHALL be 160 bits, the default authentication tag length (n_tag) SHALL be 80 bits, and the SRTP_PREFIX_LENGTH SHALL be zero for HMAC-SHA1. In addition, for SRTCP, the pre-defined HMAC-SHA1 MUST NOT be applied with a value of n_tag, nor n_a, that are smaller than these defaults. For SRTP, smaller values are NOT RECOMMENDED, but MAY be used after careful consideration of the issues in Section 7.5 and 9.5.",
      "ja": "セクション4.2.1で定義されているように、HMAC-SHA1はデフォルトのメッセージ認証コードとなるべきです（SHALL）。デフォルトのセッション認証キー長（n_a）は160ビットとなるべきです（SHALL）。デフォルトの認証タグ長（n_tag）は80ビットとなるべきです（SHALL）。また、HMAC-SHA1の場合、SRTP_PREFIX_LENGTHはゼロとなるべきです（SHALL）。さらに、SRTCPの場合、事前定義されたHMAC-SHA1は、これらのデフォルトよりも小さいn_tagまたはn_aの値で適用してはなりません（MUST NOT）。SRTPの場合、小さい値は推奨されません（NOT RECOMMENDED）が、セクション7.5および9.5の問題を慎重に検討した上で使用してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.3. Key Derivation: AES-CM PRF",
      "section_title": true,
      "ja": "5.3. 鍵導出：AES-CM PRF"
    },
    {
      "indent": 3,
      "text": "The AES Counter Mode based key derivation and PRF defined in Sections 4.3.1 to 4.3.3, using a 128-bit master key, SHALL be the default method for generating session keys. The default master salt length SHALL be 112 bits and the default key-derivation rate SHALL be zero.",
      "ja": "128ビットマスターキーを使用して、セクション4.3.1から4.3.3で定義されているAESカウンターモードベースの鍵導出およびPRFは、セッションキーを生成するためのデフォルトの方法となるべきです（SHALL）。デフォルトのマスターソルト長は112ビットとなるべきです（SHALL）。また、デフォルトのキー導出率はゼロとなるべきです（SHALL）。"
    },
    {
      "indent": 0,
      "text": "6. Adding SRTP Transforms",
      "section_title": true,
      "ja": "6. SRTP変換の追加"
    },
    {
      "indent": 3,
      "text": "Section 4 provides examples of the level of detail needed for defining transforms. Whenever a new transform is to be added to SRTP, a companion standard track RFC MUST be written to exactly define how the new transform can be used with SRTP (and SRTCP). Such a companion RFC SHOULD avoid overlap with the SRTP protocol document. Note however, that it MAY be necessary to extend the SRTP or SRTCP cryptographic context definition with new parameters (including fixed or default values), add steps to the packet processing, or even add fields to the SRTP/SRTCP packets. The companion RFC SHALL explain any known issues regarding interactions between the transform and other aspects of SRTP.",
      "ja": "セクション4では、変換を定義するために必要な詳細レベルの例を示します。SRTPに新しい変換を追加する場合は常に、新しい変換がSRTP（およびSRTCP）でどのように使用できるかを正確に定義するために、補完的な標準トラックRFCが作成されなければなりません（MUST）。そのような補完的なRFCは、SRTPプロトコル文書との重複を避けるべきです（SHOULD）。ただし、SRTPまたはSRTCP暗号化コンテキスト定義を新しいパラメータ（固定値またはデフォルト値を含む）で拡張したり、パケット処理に手順を追加したり、さらにはSRTP/SRTCPパケットにフィールドを追加したりすることが必要になる場合があります（MAY）。補完的なRFCは、変換とSRTPの他の側面との間の相互作用に関する既知の問題を説明すべきです（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Each new transform document SHOULD specify its key attributes, e.g., size of keys (minimum, maximum, recommended), format of keys, recommended/required processing of input keying material, requirements/recommendations on key lifetime, re-keying and key derivation, whether sharing of keys between SRTP and SRTCP is allowed or not, etc.",
      "ja": "各新しい変換文書は、そのキー属性、例えばキーのサイズ（最小、最大、推奨）、キーの形式、推奨/必須の入力鍵材料処理、キーライフタイムに関する要件/推奨事項、再キーイングと鍵導出、SRTPとSRTCP間のキーの共有が許可されているかどうかなどを指定すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "An added message integrity transform SHOULD define a minimum acceptable key/tag size for SRTCP, equivalent in strength to the minimum values as defined in Section 5.2.",
      "ja": "追加されたメッセージ整合性変換は、SRTCPのための最小許容鍵/タグサイズを定義すべきです（SHOULD）。これはセクション5.2で定義されている最小値と同等の強度を持つものです。"
    },
    {
      "indent": 0,
      "text": "7. Rationale",
      "section_title": true,
      "ja": "7. 根拠"
    },
    {
      "indent": 3,
      "text": "This section explains the rationale behind several important features of SRTP.",
      "ja": "このセクションでは、SRTPのいくつかの重要な機能の背後にある根拠について説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Key derivation",
      "section_title": true,
      "ja": "7.1. 鍵の派生"
    },
    {
      "indent": 3,
      "text": "Key derivation reduces the burden on the key establishment. As many as six different keys are needed per crypto context (SRTP and SRTCP encryption keys and salts, SRTP and SRTCP authentication keys), but these are derived from a single master key in a cryptographically secure way. Thus, the key management protocol needs to exchange only one master key (plus master salt when required), and then SRTP itself derives all the necessary session keys (via the first, mandatory application of the key derivation function).",
      "ja": "鍵導出は鍵確立の負担を軽減します。Cryptoコンテキストごとに最大6つの異なるキー（SRTPおよびSRTCPの暗号化キーとソルト、SRTPおよびSRTCPの認証キー）が必要ですが、これらは暗号学的に安全な方法で単一のマスターキーから導出されます。したがって、鍵管理プロトコルは1つのマスターキー（必要な場合はマスターソルトも）のみを交換する必要があり、SRTP自体が必要なすべてのセッションキーを導出します（鍵導出関数の最初の必須適用を介して）。"
    },
    {
      "indent": 3,
      "text": "Multiple applications of the key derivation function are optional, but will give security benefits when enabled. They prevent an attacker from obtaining large amounts of ciphertext produced by a single fixed session key. If the attacker was able to collect a large amount of ciphertext for a certain session key, he might be helped in mounting certain attacks.",
      "ja": "鍵導出関数の複数回適用はオプションですが、有効にするとセキュリティ上の利点が得られます。これらは、攻撃者が単一の固定セッションキーによって生成された大量の暗号文を入手するのを防ぎます。攻撃者が特定のセッションキーについて大量の暗号文を収集できた場合、彼は特定の攻撃を仕掛ける際に助けられる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Multiple applications of the key derivation function provide backwards and forward security in the sense that a compromised session key does not compromise other session keys derived from the same master key. This means that the attacker who is able to recover a certain session key, is anyway not able to have access to messages secured under previous and later session keys (derived from the same master key). (Note that, of course, a leaked master key reveals all the session keys derived from it.)",
      "ja": "鍵導出関数の複数回適用は、侵害されたセッションキーが同じマスターキーから導出された他のセッションキーを侵害しないという意味で、後方および前方セキュリティを提供します。これは、特定のセッションキーを回復できる攻撃者が、以前およびその後のセッションキー（同じマスターキーから導出された）の下で保護されたメッセージにアクセスできないことを意味します。（もちろん、漏洩したマスターキーは、そこから導出されたすべてのセッションキーを明らかにします。）"
    },
    {
      "indent": 3,
      "text": "Considerations arise with high-rate key refresh, especially in large multicast settings, see Section 11.",
      "ja": "特に大規模なマルチキャスト設定では、高速キーのリフレッシュに関して考慮すべき点が生じます。セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Salting key",
      "section_title": true,
      "ja": "7.2. ソルトキー"
    },
    {
      "indent": 3,
      "text": "The master salt guarantees security against off-line key-collision attacks on the key derivation that might otherwise reduce the effective key size [MF00].",
      "ja": "マスターソルトは、そうでなければ有効なキーサイズを減少させる可能性のある鍵導出に対するオフラインの鍵衝突攻撃からのセキュリティを保証します[MF00]。"
    },
    {
      "indent": 3,
      "text": "The derived session salting key used in the encryption, has been introduced to protect against some attacks on additive stream ciphers, see Section 9.2. The explicit inclusion method of the salt in the IV has been selected for ease of hardware implementation.",
      "ja": "暗号化で使用される派生セッションソルティングキーは、加法的ストリーム暗号に対するいくつかの攻撃から保護するために導入されました。セクション9.2を参照してください。IV内のソルトの明示的な包含方法は、ハードウェア実装を容易にするために選択されています。"
    },
    {
      "indent": 0,
      "text": "7.3. Message Integrity from Universal Hashing",
      "section_title": true,
      "ja": "7.3. ユニバーサルハッシュからのメッセージの整合性"
    },
    {
      "indent": 3,
      "text": "The particular definition of the keystream given in Section 4.1 (the keystream prefix) is to give provision for particular universal hash functions, suitable for message authentication in the Wegman-Carter paradigm [WC81]. Such functions are provably secure, simple, quick, and especially appropriate for Digital Signal Processors and other processors with a fast multiply operation.",
      "ja": "セクション4.1で示されているキーストリームの特定の定義（キーストリームプレフィックス）は、Wegman-Carterパラダイム[WC81]におけるメッセージ認証に適した特定のユニバーサルハッシュ関数を提供することを目的としています。そのような関数は、証明可能に安全で、シンプル、高速であり、高速な乗算操作を備えたデジタル信号プロセッサや他のプロセッサにとって特に適切です。"
    },
    {
      "indent": 3,
      "text": "No authentication transforms are currently provided in SRTP other than HMAC-SHA1. Future transforms, like the above mentioned universal hash functions, MAY be added following the guidelines in Section 6.",
      "ja": "HMAC-SHA1以外の認証変換は現在SRTPで提供されていません。将来の変換（上述のユニバーサルハッシュ関数など）は、セクション6のガイドラインに従って追加してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "7.4. Data Origin Authentication Considerations",
      "section_title": true,
      "ja": "7.4. データ送信元認証に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Note that in pair-wise communications, integrity and data origin authentication are provided together. However, in group scenarios where the keys are shared between members, the MAC tag only proves that a member of the group sent the packet, but does not prevent against a member impersonating another. Data origin authentication (DOA) for multicast and group RTP sessions is a hard problem that needs a solution; while some promising proposals are being investigated [PCST1] [PCST2], more work is needed to rigorously specify these technologies. Thus SRTP data origin authentication in groups is for further study.",
      "ja": "ペアワイズ通信では、整合性とデータ送信元認証が一緒に提供されることに注意してください。しかし、メンバー間でキーが共有されるグループシナリオでは、MACタグはグループのメンバーがパケットを送信したことを証明するだけであり、あるメンバーが別のメンバーを偽装するのを防ぐことはできません。マルチキャストおよびグループRTPセッションにおけるデータ送信元認証（DOA）は、解決策を必要とする難しい問題です。いくつかの有望な提案が調査中ですが[PCST1] [PCST2]、これらの技術を厳密に指定するためにはさらなる作業が必要です。したがって、グループにおけるSRTPデータ送信元認証は今後の研究課題です。"
    },
    {
      "indent": 3,
      "text": "DOA can be done otherwise using signatures. However, this has high impact in terms of bandwidth and processing time, therefore we do not offer this form of authentication in the pre-defined packet-integrity transform.",
      "ja": "署名を使用してDOAを実行できます。ただし、これは帯域幅と処理時間の点で大きな影響を及ぼします。したがって、定義されたパケット整合性変換でこの形式の認証を提供しません。"
    },
    {
      "indent": 3,
      "text": "The presence of mixers and translators does not allow data origin authentication in case the RTP payload and/or the RTP header are manipulated. Note that these types of middle entities also disrupt end-to-end confidentiality (as the IV formation depends e.g., on the RTP header preservation). A certain trust model may choose to trust the mixers/translators to decrypt/re-encrypt the media (this would imply breaking the end-to-end security, with related security implications).",
      "ja": "RTPペイロードおよび/またはRTPヘッダーが操作されている場合、ミキサーとトランスレータの存在はデータ送信元認証を許可しません。これらのタイプの中間エンティティはまた、（例えばIVの生成がRTPヘッダーの保持に依存するため）エンドツーエンドの機密性を妨害することに留意してください。特定の信頼モデルは、メディアを復号化/再暗号化するためにミキサー/トランスレータを信頼することを選択する場合があります（これは、関連するセキュリティ上の影響を伴うエンドツーエンドのセキュリティを破ることを意味します）。"
    },
    {
      "indent": 0,
      "text": "7.5. Short and Zero-length Message Authentication",
      "section_title": true,
      "ja": "7.5. 短縮またはゼロ長のメッセージ認証"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 1, the authentication tag is RECOMMENDED in SRTP. A full 80-bit authentication-tag SHOULD be used, but a shorter tag or even a zero-length tag (i.e., no message authentication) MAY be used under certain conditions to support either of the following two application environments.",
      "ja": "図1に示すように、認証タグはSRTPで推奨されています。完全な80ビット認証タグは使用すべきですが（SHOULD）、特定の条件下では、より短いタグまたはゼロ長タグ（すなわち、メッセージ認証なし）を使用してもよい（MAY）とされ、以下の2つのアプリケーション環境のいずれかをサポートします。"
    },
    {
      "indent": 6,
      "text": "1. Strong authentication can be impractical in environments where bandwidth preservation is imperative. An important special case is wireless communication systems, in which bandwidth is a scarce and expensive resource. Studies have shown that for certain applications and link technologies, additional bytes may result in a significant decrease in spectrum efficiency [SWO]. Considerable effort has been made to design IP header compression techniques to improve spectrum efficiency [RFC3095]. A typical voice application produces 20 byte samples, and the RTP, UDP and IP headers need to be jointly compressed to one or two bytes on average in order to obtain acceptable wireless bandwidth economy [RFC3095]. In this case, strong authentication would impose nearly fifty percent overhead.",
      "ja": "1. 帯域幅の節約が不可欠な環境では、強力な認証は非実用的になる可能性があります。重要な特殊なケースは無線通信システムであり、帯域幅は希少で高価なリソースです。研究によれば、特定のアプリケーションやリンク技術では、追加のバイトがスペクトル効率を大幅に低下させる可能性があります[SWO]。スペクトル効率を向上させるためにIPヘッダ圧縮技術を設計する上でかなりの努力が払われてきました[RFC3095]。典型的な音声アプリケーションは20バイトのサンプルを生成し、許容可能な無線帯域幅経済を達成するためには、RTP、UDP、およびIPヘッダを平均して1バイトまたは2バイトに共同圧縮する必要があります[RFC3095]。この場合、強力な認証はほぼ50パーセントのオーバーヘッドを課すことになります。"
    },
    {
      "indent": 6,
      "text": "2. Authentication is impractical for applications that use data links with fixed-width fields that cannot accommodate the expansion due to the authentication tag. This is the case for some important existing wireless channels. For example, zero-byte header compression is used to adapt EVRC/SMV voice with the legacy IS-95 bearer channel in CDMA2000 VoIP services. It was found that not a single additional octet could be added to the data, which motivated the creation of a zero-byte profile for ROHC [RFC3242].",
      "ja": "2. 認証タグによる拡張に対応できない固定幅フィールドを持つデータリンクを使用するアプリケーションには、認証は非実用的です。これは、いくつかの重要な既存の無線チャネルに当てはまります。たとえば、CDMA2000 VoIPサービスでは、ゼロバイトヘッダ圧縮がEVRC/SMV音声とレガシーのIS-95ベアラチャネルを適合させるために使用されます。その結果、データに単一の追加オクテットも追加できないことが判明し、これがROHCのゼロバイトプロファイル[RFC3242]の作成を動機づけました。"
    },
    {
      "indent": 3,
      "text": "A short tag is secure for a restricted set of applications. Consider a voice telephony application, for example, such as a G.729 audio codec with a 20-millisecond packetization interval, protected by a 32-bit message authentication tag. The likelihood of any given packet being successfully forged is only one in 2^32. Thus an adversary can control no more than 20 milliseconds of audio output during a 994-day period, on average. In contrast, the effect of a single forged packet can be much larger if the application is stateful. A codec that uses relative or predictive compression across packets will propagate the maliciously generated state, affecting a longer duration of output.",
      "ja": "短いタグは、限られたアプリケーションセットに対して安全です。例えば、20ミリ秒のパケット化間隔を持つG.729オーディオコーデックのような音声電話アプリケーションを、32ビットのメッセージ認証タグで保護することを考えてみましょう。任意のパケットが正常に偽造される可能性は2^32分の1にすぎません。したがって、敵対者は平均して994日間で20ミリ秒を超えるオーディオ出力を制御することはできません。対照的に、アプリケーションがステートフルである場合、単一の偽造パケットの影響ははるかに大きくなる可能性があります。パケット間で相対的または予測的な圧縮を使用するコーデックは、悪意を持って生成された状態を伝播し、より長い期間の出力に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Certainly not all SRTP or telephony applications meet the criteria for short or zero-length authentication tags. Section 9.5.1 discusses the risks of weak or no message authentication, and section 9.5 describes the circumstances when it is acceptable and when it is unacceptable.",
      "ja": "確かに、すべてのSRTPまたはテレフォニーアプリケーションが短いまたはゼロ長の認証タグの基準を満たすわけではありません。セクション9.5.1では、弱いまたはNULL認証のリスクについて議論し、セクション9.5では、それが許容される場合と許容されない場合について説明しています。"
    },
    {
      "indent": 0,
      "text": "8. Key Management Considerations",
      "section_title": true,
      "ja": "8. 鍵管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are emerging key management standards [MIKEY] [KEYMGT] [SDMS] for establishing an SRTP cryptographic context (e.g., an SRTP master key). Both proprietary and open-standard key management methods are likely to be used for telephony applications [MIKEY] [KINK] and multicast applications [GDOI]. This section provides guidance for key management systems that service SRTP session.",
      "ja": "SRTP暗号化コンテキスト（例えばSRTPマスターキー）を確立するための新たな鍵管理規格[MIKEY] [KEYMGT] [SDMS]があります。独自の鍵管理方法とオープン標準の鍵管理方法の両方が、テレフォニーアプリケーション[MIKEY] [KINK]およびマルチキャストアプリケーション[GDOI]で使用される可能性があります。このセクションでは、SRTPセッションを提供する鍵管理システムのためのガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "For initialization, an interoperable SRTP implementation SHOULD be given the SSRC and MAY be given the initial RTP sequence number for the RTP stream by key management (thus, key management has a dependency on RTP operational parameters). Sending the RTP sequence number in the key management may be useful e.g., when the initial sequence number is close to wrapping (to avoid synchronization problems), and to communicate the current sequence number to a joining endpoint (to properly initialize its replay list).",
      "ja": "初期化のために、相互運用可能なSRTP実装にはSSRCが与えられるべきであり（SHOULD）、鍵管理によってRTPストリームの初期RTPシーケンス番号が与えられてもよい（MAY）（したがって、鍵管理はRTP運用パラメータに依存します）。鍵管理でRTPシーケンス番号を送信することは、例えば、初期シーケンス番号がラップに近い場合（同期問題を回避するため）、および現在のシーケンス番号を参加中のエンドポイントに通信する場合（リプレイリストを適切に初期化するため）に有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the pre-defined transforms are used, SRTP allows sharing of the same master key between SRTP/SRTCP streams belonging to the same RTP session.",
      "ja": "事前定義された変換が使用されている場合、SRTPは同じRTPセッションに属するSRTP / SRTCPストリーム間の同じマスターキーを共有することを可能にします。"
    },
    {
      "indent": 3,
      "text": "First, sharing between SRTP streams belonging to the same RTP session is secure if the design of the synchronization mechanism, i.e., the IV, avoids keystream re-use (the two-time pad, Section 9.1). This is taken care of by the fact that RTP provides for unique SSRCs for streams belonging to the same RTP session. See Section 9.1 for further discussion.",
      "ja": "第一に、同期メカニズムの設計、すなわちIVがキーストリームの再利用（ツータイムパッド、セクション9.1）を回避する場合、同じRTPセッションに属するSRTPストリーム間の共有は安全です。これは、RTPが同じRTPセッションに属するストリームに対して一意のSSRCを提供するという事実によって対処されます。さらなる議論についてはセクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Second, sharing between SRTP and the corresponding SRTCP is secure. The fact that an SRTP stream and its associated SRTCP stream both carry the same SSRC does not constitute a problem for the two-time pad due to the key derivation. Thus, SRTP and SRTCP corresponding to one RTP session MAY share master keys (as they do by default).",
      "ja": "第二に、SRTPと対応するSRTCP間の共有は安全です。SRTPストリームとその関連するSRTCPストリームが両方とも同じSSRCを搬送するからといって、鍵導出によるツータイムパッドの問題が生じるわけではありません。したがって、1つのRTPセッションに対応するSRTPおよびSRTCPは、マスターキーを共有してもよい（MAY）（デフォルトのように）。"
    },
    {
      "indent": 0,
      "text": " Note that message authentication also has a dependency on SSRC uniqueness that is unrelated to the problem of keystream reuse: SRTP streams authenticated under the same key MUST have a distinct SSRC in order to identify the sender of the message. This requirement is needed because the SSRC is the cryptographically authenticated field used to distinguish between different SRTP streams. Were two streams to use identical SSRC values, then an adversary could substitute messages from one stream into the other without detection.",
      "ja": "メッセージ認証は、キーストリーム再利用の問題とは無関係のSSRCの一意性にも依存していることに注意してください。同じキーの下で認証されたSRTPストリームは、メッセージの送信者を識別するために異なるSSRCを持つ必要があります（MUST）。この要件が必要なのは、SSRCが異なるSRTPストリームを区別するために使用される暗号学的に認証されたフィールドであるためです。もし2つのストリームが同一のSSRC値を使用した場合、敵対者は検出されることなく、あるストリームのメッセージを別のストリームに置き換えることができるでしょう。"
    },
    {
      "indent": 3,
      "text": "SRTP/SRTCP MUST NOT share master keys under any other circumstances than the ones given above, i.e., between SRTP and its corresponding SRTCP, and, between streams belonging to the same RTP session.",
      "ja": "SRTP / SRTCPは、上記のもの、すなわちSRTPとそれに対応するSRTCPとの間、および同じRTPセッションに属するストリーム間で、他の状況下でマスターキーを共有してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.1. Re-keying",
      "section_title": true,
      "ja": "8.1. 再キーイング"
    },
    {
      "indent": 3,
      "text": "The recommended way for a particular key management system to provide re-key within SRTP is by associating a master key in a crypto context with an MKI.",
      "ja": "特定の鍵管理システムがSRTP内に再キーを提供するための推奨される方法は、マスターキーを暗号コンテキストにMKIと関連付けることである。"
    },
    {
      "indent": 3,
      "text": "This provides for easy master key retrieval (see Scenarios in Section 11), but has the disadvantage of adding extra bits to each packet. As noted in Section 7.5, some wireless links do not cater for added bits, therefore SRTP also defines a more economic way of triggering re-keying, via use of <From, To>, which works in some specific, simple scenarios (see Section 8.1.1).",
      "ja": "これはマスターキーの簡単な検索を提供しますが（セクション11のシナリオを参照）、各パケットに余分なビットを追加するという欠点があります。セクション7.5で述べたように、一部の無線リンクは追加ビットに対応していないため、SRTPは<From, To>の使用を介して再キーイングをトリガーする、より経済的な方法も定義しており、これは特定のシンプルなシナリオで機能します（セクション8.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "SRTP senders SHALL count the amount of SRTP and SRTCP traffic being used for a master key and invoke key management to re-key if needed (Section 9.2). These interactions are defined by the key management interface to SRTP and are not defined by this protocol specification.",
      "ja": "SRTP送信者は、マスターキーに使用されているSRTPおよびSRTCPトラフィックの量をカウントし、必要に応じて再キーを実行するために鍵管理を呼び出すべきです（SHALL）（セクション9.2）。これらの相互作用は、SRTPへの鍵管理インターフェースによって定義されており、このプロトコル仕様によって定義されているものではありません。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Use of the <From, To> for re-keying",
      "section_title": true,
      "ja": "8.1.1. 再キーイングのための<from、to>の使用"
    },
    {
      "indent": 3,
      "text": "In addition to the use of the MKI, SRTP defines another optional mechanism for master key retrieval, the <From, To>. The <From, To> specifies the range of SRTP indices (a pair of sequence number and ROC) within which a certain master key is valid, and is (when used) part of the crypto context. By looking at the 48-bit SRTP index of the current SRTP packet, the corresponding master key can be found by determining which From-To interval it belongs to. For SRTCP, the most recently observed/used SRTP index (which can be obtained from the cryptographic context) is used for this purpose, even though SRTCP has its own (31-bit) index (see caveat below).",
      "ja": "MKIの使用に加えて、SRTPはマスターキー取得の別のオプションメカニズムである<From, To>を定義します。<From, To>は、特定のマスターキーが有効であるSRTPインデックスの範囲（シーケンス番号とROCのペア）を指定し、（使用される場合）暗号コンテキストの一部となります。現在のSRTPパケットの48ビットSRTPインデックスを見ることで、どのFrom-To間隔に属するかを判断することによって、対応するマスターキーを見つけることができます。SRTCPの場合、SRTCPには独自の（31ビット）インデックスがあるにもかかわらず、この目的のために最も最近観測/使用されたSRTPインデックス（暗号化コンテキストから取得可能）が使用されます（下記の注意を参照）。"
    },
    {
      "indent": 0,
      "text": " This method, compared to the MKI, has the advantage of identifying the master key and defining its lifetime without adding extra bits to each packet. This could be useful, as already noted, for some wireless links that do not cater for added bits. However, its use SHOULD be limited to specific, very simple scenarios. We recommend to limit its use when the RTP session is a simple unidirectional or bi-directional stream. This is because in case of multiple streams, it is difficult to trigger the re-key based on the <From, To> of a single RTP stream. For example, if several streams share a master key, there is no simple one-to-one correspondence between the index sequence space of a certain stream, and the index sequence space on which the <From, To> values are based. Consequently, when a master key is shared between streams, one of these streams MUST be designated by key management as the one whose index space defines the re-keying points. Also, the re-key triggering on SRTCP is based on the correspondent SRTP stream, i.e., when the SRTP stream changes the master key, so does the correspondent SRTCP. This becomes obviously more and more complex with multiple streams.",
      "ja": "この方法は、MKIと比較して、各パケットに余分なビットを追加することなく、マスターキーを識別し、その寿命を定義するという利点があります。これは、すでに述べたように、追加ビットに対応しない一部の無線リンクにとって有用である可能性があります。ただし、その使用は特定の非常に単純なシナリオに限定されるべきです（SHOULD）。RTPセッションが単純な一方向または双方向のストリームである場合は、その使用を制限することをお勧めします。これは、複数のストリームの場合、単一のRTPストリームの<From, To>に基づいて再キーをトリガーすることは困難であるためです。例えば、複数のストリームがマスターキーを共有している場合、特定のストリームのインデックスシーケンススペースと、<From, To>値が基づいているインデックスシーケンススペースとの間に単純な1対1対応の対応はありません。したがって、マスターキーがストリーム間で共有される場合、これらのストリームのうちの1つは、鍵管理によってそのインデックススペースが再キーイングポイントを定義するものとして指定されなければなりません（MUST）。また、SRTCP上での再キーイングのトリガーは、対応するSRTPストリームに基づいており、すなわちSRTPストリームがマスターキーを変更すると、対応するSRTCPも同様にそれを行います。これは、複数のストリームでは明らかにますます複雑になります。"
    },
    {
      "indent": 3,
      "text": "The default values for the <From, To> are \"from the first observed packet\" and \"until further notice\". However, the maximum limit of SRTP/SRTCP packets that are sent under each given master/session key (Section 9.2) MUST NOT be exceeded.",
      "ja": "<from、to>のデフォルト値は、「最初の観測パケットから」、「さらなる通知まで」です。ただし、特定のマスター/セッションキー（セクション9.2）の下で送信されるSRTP / SRTCPパケットの最大制限を超えてはいけません。"
    },
    {
      "indent": 3,
      "text": "In case the <From, To> is used as key retrieval, then the MKI is not inserted in the packet (and its indicator in the crypto context is zero). However, using the MKI does not exclude using <From, To> key lifetime simultaneously. This can for instance be useful to signal at the sender side at which point in time an MKI is to be made active.",
      "ja": "<From, To>が鍵の取得として使用される場合、MKIはパケットに挿入されません（そして暗号コンテキスト内のそのインジケータはゼロです）。しかし、MKIを使用しても、<From, To>のキーライフタイムを同時に使用することを排除しません。これは、例えば、送信者側でMKIをいつアクティブにするかを通知するのに有用な場合があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Key Management parameters",
      "section_title": true,
      "ja": "8.2. 鍵管理パラメータ"
    },
    {
      "indent": 3,
      "text": "The table below lists all SRTP parameters that key management can supply. For reference, it also provides a summary of the default and mandatory-to-support values for an SRTP implementation as described in Section 5.",
      "ja": "以下の表は、鍵管理が提供できるすべてのSRTPパラメータを示しています。参考のために、セクション5で説明されているように、SRTP実装のデフォルトおよび必須の値の概要も提供します。"
    },
    {
      "indent": 3,
      "text": "Parameter                     Mandatory-to-support    Default\n---------                     --------------------    -------\n\nSRTP and SRTCP encr transf.       AES_CM, NULL         AES_CM\n(Other possible values: AES_f8)\n\nSRTP and SRTCP auth transf.       HMAC-SHA1           HMAC-SHA1\n\nSRTP and SRTCP auth params:\n  n_tag (tag length)                 80                 80\n  SRTP prefix_length                  0                  0\n\nKey derivation PRF                 AES_CM              AES_CM\n\nKey material params\n(for each master key):\n  master key length                 128                128\n  n_e (encr session key length)     128                128\n  n_a (auth session key length)     160                160\n  master salt key\n  length of the master salt         112                112\n  n_s (session salt key length)     112                112\n  key derivation rate                 0                  0\n\n  key lifetime\n     SRTP-packets-max-lifetime      2^48               2^48\n     SRTCP-packets-max-lifetime     2^31               2^31\n     from-to-lifetime <From, To>\n  MKI indicator                       0                 0\n  length of the MKI                   0                 0\n  value of the MKI\n\nCrypto context index params:\n  SSRC value\n  ROC\n  SEQ\n  SRTCP Index\n  Transport address\n  Port number\n\nRelation to other RTP profiles:\n  sender's order between FEC and SRTP FEC-SRTP      FEC-SRTP\n  (see Section 10)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. SSRC collision and two-time pad",
      "section_title": true,
      "ja": "9.1. SSRCの衝突と2回のパッド"
    },
    {
      "indent": 3,
      "text": "Any fixed keystream output, generated from the same key and index MUST only be used to encrypt once. Re-using such keystream (jokingly called a \"two-time pad\" system by cryptographers), can seriously compromise security. The NSA's VENONA project [C99] provides a historical example of such a compromise. It is REQUIRED that automatic key management be used for establishing and maintaining SRTP and SRTCP keying material; this requirement is to avoid keystream reuse, which is more likely to occur with manual key management. Furthermore, in SRTP, a \"two-time pad\" is avoided by requiring the key, or some other parameter of cryptographic significance, to be unique per RTP/RTCP stream and packet. The pre-defined SRTP transforms accomplish packet-uniqueness by including the packet index and stream-uniqueness by inclusion of the SSRC.",
      "ja": "同じキーとインデックスから生成された固定キーストリーム出力は、一度だけ暗号化に使用されなければなりません（MUST）。そのようなキーストリーム（冗談を暗号化された「2タイムパッド」システムと呼ばれる）を再利用すると、セキュリティを深刻に侵害することができます。NSAのVenona Project [C99]はそのような妥協の歴史的な例を提供します。自動鍵管理は、SRTPおよびSRTCPキーイング材料の確立および維持に使用されることが必要です。この要件はキーストリームの再利用を回避することであり、手動キー管理で発生する可能性が高いです。さらに、SRTPでは、RTP / RTCPストリームおよびパケットごとにユニットになるように、キー、または暗号的有意性の他のパラメータを必要とすることによって「2タイムパッド」が回避される。事前定義されたSRTP変換は、SSRCを含めることによってパケットインデックスとストリーム一意性を含むことによってパケット一意性を変換する。"
    },
    {
      "indent": 3,
      "text": "The pre-defined transforms (AES-CM and AES-f8) allow master keys to be shared across streams belonging to the same RTP session by the inclusion of the SSRC in the IV. A master key MUST NOT be shared among different RTP sessions.",
      "ja": "事前定義された変換（AES-CMおよびAES-F8）は、IV内のSSRCを含めることによって、同じRTPセッションに属するストリーム間でマスターキーを共有することができます。マスターキーは、さまざまなRTPセッション間で共有されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Thus, the SSRC MUST be unique between all the RTP streams within the same RTP session that share the same master key. RTP itself provides an algorithm for detecting SSRC collisions within the same RTP session. Thus, temporary collisions could lead to temporary two-time pad, in the unfortunate event that SSRCs collide at a point in time when the streams also have identical sequence numbers (occurring with probability roughly 2^(-48)). Therefore, the key management SHOULD take care of avoiding such SSRC collisions by including the SSRCs to be used in the session as negotiation parameters, proactively assuring their uniqueness. This is a strong requirements in scenarios where for example, there are multiple senders that can start to transmit simultaneously, before SSRC collision are detected at the RTP level.",
      "ja": "したがって、SSRCは、同じRTPセッション内のすべてのRTPストリーム間で同じマスターキーを共有するすべてのRTPストリーム間で一意でなければなりません。RTP自体は、同じRTPセッション内のSSRC衝突を検出するためのアルゴリズムを提供します。したがって、一時的な衝突は、ストリームが同一のシーケンス番号を有する時点で衝突する不幸なイベントで、一時的な2タイムパッドにつながる可能性があります（約2 ^（ -  48））。したがって、キー管理は、セッションで使用されるSSRCを交渉パラメータとして積極的に保証することで、そのようなSSRC衝突を回避するのを避けるべきです。これはシナリオの強力な要件です。たとえば、SSRCの衝突がRTPレベルで検出される前に、同時に送信し始めることができる複数の送信者がいます。"
    },
    {
      "indent": 3,
      "text": "Note also that even with distinct SSRCs, extensive use of the same key might improve chances of probabilistic collision and time-memory-tradeoff attacks succeeding.",
      "ja": "また、異なるSSRCを使用しても、同じキーを広く使用することは、確率論的衝突とタイムメモリ - トレードオフ攻撃の可能性を向上させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "As described, master keys MAY be shared between streams belonging to the same RTP session, but it is RECOMMENDED that each SSRC have its own master key. When master keys are shared among SSRC participants and SSRCs are managed by a key management module as recommended above, the RECOMMENDED policy for an SSRC collision error is for the participant to leave the SRTP session as it is a sign of malfunction.",
      "ja": "説明したように、マスターキーは、同じRTPセッションに属するストリーム間で共有されていてもよいが、各SSRCに独自のマスターキーがあることをお勧めします。SSRC参加者間でマスターキーが共有され、SSRCSが推奨されているように鍵管理モジュールによって管理されている場合、SSRC衝突エラーの推奨ポリシーは、参加者が誤動作の兆候としてSRTPセッションを残すためのものです。"
    },
    {
      "indent": 0,
      "text": "9.2. Key Usage",
      "section_title": true,
      "ja": "9.2. 鍵利用"
    },
    {
      "indent": 3,
      "text": "The effective key size is determined (upper bounded) by the size of the master key and, for encryption, the size of the salting key. Any additive stream cipher is vulnerable to attacks that use statistical knowledge about the plaintext source to enable key collision and time-memory tradeoff attacks [MF00] [H80] [BS00]. These attacks take advantage of commonalities among plaintexts, and provide a way for a cryptanalyst to amortize the computational effort of decryption over many keys, or over many bytes of output, thus reducing the effective key size of the cipher. A detailed analysis of these attacks and their applicability to the encryption of Internet traffic is provided in [MF00]. In summary, the effective key size of SRTP when used in a security system in which m distinct keys are used, is equal to the key size of the cipher less the logarithm (base two) of m. Protection against such attacks can be provided simply by increasing the size of the keys used, which here can be accomplished by the use of the salting key. Note that the salting key MUST be random but MAY be public. A salt size of (the suggested) size 112 bits protects against attacks in scenarios where at most 2^112 keys are in use. This is sufficient for all practical purposes.",
      "ja": "有効なキーサイズは、マスターキーのサイズと、暗号化の場合はソルティングキーのサイズによって決定（上限）されます。 Addivent Stream暗号は、主要な衝突とタイムメモリのトレードオフ攻撃を有効にするために平文ソースに関する統計的な知識を使用する攻撃に対して脆弱です[MF00] [H80] [BS00]。これらの攻撃は平文の間の共通点を利用し、暗号広告が多くのキーにわたって復号化の計算努力を償却する方法を提供し、したがって暗号の有効なキーサイズを減らす。これらの攻撃の詳細な分析とそのインターネットトラフィックの暗号化への適用性が[MF00]に提供されています。要約すると、M個の異なるキーが使用されるセキュリティシステムで使用されたときのSRTPの有効鍵サイズは、Mの対数（基本2）の暗号のキーサイズと等しい。そのような攻撃に対する保護は、使用されるキーのサイズを増やすことによって簡単に提供することができます。ここではここではソルティングキーを使用して実現できます。ソルティングキーはランダムでなければなりませんが（MUST）、公開されていてもかまいません（MAY）。 （提案された）サイズ112ビットのソルトサイズは、最大2^112キーが使用されているシナリオの攻撃から保護します。これはすべての実用的な目的に十分です。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD use keys that are as large as possible. Please note that in many cases increasing the key size of a cipher does not affect the throughput of that cipher.",
      "ja": "実装はできるだけ大きいキーを使用する必要があります。多くの場合、暗号のキーサイズを大きくすると、その暗号のスループットには影響しません。"
    },
    {
      "indent": 3,
      "text": "The use of the SRTP and SRTCP indices in the pre-defined transforms fixes the maximum number of packets that can be secured with the same key. This limit is fixed to 2^48 SRTP packets for an SRTP stream, and 2^31 SRTCP packets, when SRTP and SRTCP are considered independently. Due to for example re-keying, reaching this limit may or may not coincide with wrapping of the indices, and thus the sender MUST keep packet counts. However, when the session keys for related SRTP and SRTCP streams are derived from the same master key (the default behavior, Section 4.3), the upper bound that has to be considered is in practice the minimum of the two quantities. That is, when 2^48 SRTP packets or 2^31 SRTCP packets have been secured with the same key (whichever occurs before), the key management MUST be called to provide new master key(s) (previously stored and used keys MUST NOT be used again), or the session MUST be terminated. If a sender of RTCP discovers that the sender of SRTP (or SRTCP) has not updated the master or session key prior to sending 2^48 SRTP (or 2^31 SRTCP) packets belonging to the same SRTP (SRTCP) stream, it is up to the security policy of the RTCP sender how to behave, e.g., whether an RTCP BYE-packet should be sent and/or if the event should be logged.",
      "ja": "事前定義された変換のSRTPとSRTCPインデックスの使用は、同じキーで保護できるパケットの最大数を修正します。この制限は、SRTPストリームの2 ^ 48 SRTPパケットに固定され、SRTPとSRTCPが独立して考慮される場合は、2 ^ 31 SRTCPパケットが固定されています。たとえば、再キーイングがあるため、この制限に達すると、インデックスのラッピングと一致しない場合があります。したがって、送信者はパケット数を保存しなければなりません。ただし、関連するSRTPおよびSRTCPストリームのセッションキーが同じマスターキー（デフォルトの動作（セクション4.3）から派生した場合、考慮されなければならない上限は実際には2つの量の最小値です。つまり、2 ^ 48 SRTPパケットまたは2 ^ 31 SRTCPパケットが同じキーで（どちらか行われた方）、新しいマスターキーを提供するために鍵管理を呼び出す必要があります（以前は保存されている鍵と使用されてはいけません）。再び使用するか、またはセッションを終了する必要があります。 RTCPの送信者がSRTP（またはSRTCP）の送信者が、同じSRTP（SRTCP）ストリームに属する2 ^ 48 SRTP（または2 ^ 31 SRTCP）パケットを送信する前に、SRTP（またはSRTCP）の送信者がマスターまたはセッションキーを更新していない場合は、 RTCP送信者のセキュリティポリシーの動作、例えば、RTCP BYE-PACKETを送信するかどうか、および/またはイベントを記録する必要があるかどうか。"
    },
    {
      "indent": 3,
      "text": "Note: in most typical applications (assuming at least one RTCP packet for every 128,000 RTP packets), it will be the SRTCP index that first reaches the upper limit, although the time until this occurs is very long: even at 200 SRTCP packets/sec, the 2^31 index space of SRTCP is enough to secure approximately 4 months of communication.",
      "ja": "注：最も一般的なアプリケーションでは、（128,000 RTPパケットごとに少なくとも1つのRTCPパケットを想定）、これが発生するまでの時間は非常に長いですが、最初に上限に達するSRTCPインデックスになります。SRTCPの2 31インデックス空間は、約4ヶ月の通信を確保するのに十分です。"
    },
    {
      "indent": 3,
      "text": "Note that if the master key is to be shared between SRTP streams within the same RTP session (Section 9.1), although the above bounds are on a per stream (i.e., per SSRC) basis, the sender MUST base re-key decision on the stream whose sequence number space is the first to be exhausted.",
      "ja": "同じRTPセッション内のSRTPストリーム間でマスターキーを共有する場合（セクション9.1）、上記の範囲はストリームごとに（すなわち、SSRCごとに）ベースであるため、送信者は次の再キーの決定を基本させる必要があります。シーケンス番号スペースが最初に使い果たされるストリーム。"
    },
    {
      "indent": 3,
      "text": "Key derivation limits the amount of plaintext that is encrypted with a fixed session key, and made available to an attacker for analysis, but key derivation does not extend the master key's lifetime. To see this, simply consider our requirements to avoid two-time pad: two distinct packets MUST either be processed with distinct IVs, or with distinct session keys, and both the distinctness of IV and of the session keys are (for the pre-defined transforms) dependent on the distinctness of the packet indices.",
      "ja": "キーの派生は、固定セッションキーで暗号化され、分析のために攻撃者が利用できる平文の量を制限しますが、鍵導出はマスター鍵の寿命を延長しません。これを確認するには、2タイムパッドを避けるための当社の要件を考慮してください。2つの異なるパケットは、異なるIVS、または異なるセッションキーで処理され、IVとセッションキーの独立しさの両方（事前定義の場合）が必要です。パケットインデックスの異なる性に依存します。"
    },
    {
      "indent": 3,
      "text": "Note that with the key derivation, the effective key size is at most that of the master key, even if the derived session key is considerably longer. With the pre-defined authentication transform, the session authentication key is 160 bits, but the master key by default is only 128 bits. This design choice was made to comply with certain recommendations in [RFC2104] so that an existing HMAC implementation can be plugged into SRTP without problems. Since the default tag size is 80 bits, it is, for the applications in mind, also considered acceptable from security point of view. Users having concerns about this are RECOMMENDED to instead use a 192 bit master key in the key derivation. It was, however, chosen not to mandate 192-bit keys since existing AES implementations to be used in the key-derivation may not always support key-lengths other than 128 bits. Since AES is not defined (or properly analyzed) for use with 160 bit keys it is NOT RECOMMENDED that ad-hoc key-padding schemes are used to pad shorter keys to 192 or 256 bits.",
      "ja": "鍵導出では、派生セッション鍵がかなり長い場合でも、有効なキーサイズはマスターキーのものです。事前定義された認証変換では、セッション認証キーは160ビットですが、デフォルトのマスターキーは128ビットです。既存のHMAC実装を問題なくSRTPに差し込むことができるように、[RFC2104]で特定の推奨事項に準拠していました。デフォルトのタグサイズは80ビットであるため、アプリケーションがセキュリティの観点から受け入れられると見なされます。これを懸念しているユーザーは、代わりにキー導出で192ビットのマスターキーを使用することをお勧めします。しかしながら、鍵導出に使用される既存のAES実装は、常に128ビット以外のキー長をサポートしない可能性があるため、192ビットキーを義務付けないことが選択されていました。 160ビットキーでは、AESが定義されていない（または適切に分析されています）ので、アドホックキーパディング方式を使用して短いキーを192または256ビットにパッドすることはお勧めできません。"
    },
    {
      "indent": 0,
      "text": "9.3. Confidentiality of the RTP Payload",
      "section_title": true,
      "ja": "9.3. RTPペイロードの機密性"
    },
    {
      "indent": 0,
      "text": " SRTP's pre-defined ciphers are \"seekable\" stream ciphers, i.e., ciphers able to efficiently seek to arbitrary locations in their keystream (so that the encryption or decryption of one packet does not depend on preceding packets). By using seekable stream ciphers, SRTP avoids the denial of service attacks that are possible on stream ciphers that lack this property. It is important to be aware that, as with any stream cipher, the exact length of the payload is revealed by the encryption. This means that it may be possible to deduce certain \"formatting bits\" of the payload, as the length of the codec output might vary due to certain parameter settings etc. This, in turn, implies that the corresponding bit of the keystream can be deduced. However, if the stream cipher is secure (counter mode and f8 are provably secure under certain assumptions [BDJR] [KSYH] [IK]), knowledge of a few bits of the keystream will not aid an attacker in predicting subsequent keystream bits. Thus, the payload length (and information deducible from this) will leak, but nothing else.",
      "ja": "SRTPの予め定義された暗号は「準備策」ストリーム暗号、すなわち、それらのキーストリーム内の任意の位置に効率的にシークすることができる暗号化（1つのパケットの暗号化または復号化が前のパケットに依存しないようにする）である。 SEEKABLEストリーム暗号を使用することによって、SRTPはこのプロパティを欠いているストリーム暗号で可能なサービス拒否攻撃を回避します。任意のストリーム暗号と同様に、ペイロードの正確な長さが暗号化によって明らかにされることに注意することが重要です。これは、コーデック出力の長さが特定のパラメータ設定などにより異なる可能性があるため、ペイロードの特定の「フォーマットビット」を推定することが可能である可能性があることを意味します。これは、キーストリームの対応するビットを推測できることを意味します。 。ただし、ストリーム暗号が安全である場合（カウンタモードとF8は特定の仮定[BDJR] [KSYH] [IK]では実際的には確実に保護されています）、キーストリームの数ビットの知識は、後続のキーストリームビットを予測する際の攻撃者に役立ちません。したがって、ペイロード長（およびこれと推定される情報）は漏れますが、他には何もありません。"
    },
    {
      "indent": 3,
      "text": "As some RTP packet could contain highly predictable data, e.g., SID, it is important to use a cipher designed to resist known plaintext attacks (which is the current practice).",
      "ja": "いくつかのRTPパケットは非常に予測可能なデータを含む可能性があるので、例えばSIDは、既知の平文攻撃に抵抗するように設計された暗号を使用することが重要である（これは現在の練習である）。"
    },
    {
      "indent": 0,
      "text": "9.4. Confidentiality of the RTP Header",
      "section_title": true,
      "ja": "9.4. RTPヘッダの機密性"
    },
    {
      "indent": 3,
      "text": "In SRTP, RTP headers are sent in the clear to allow for header compression. This means that data such as payload type, synchronization source identifier, and timestamp are available to an eavesdropper. Moreover, since RTP allows for future extensions of headers, we cannot foresee what kind of possibly sensitive information might also be \"leaked\".",
      "ja": "SRTPでは、RTPヘッダーがクリアに送信され、ヘッダー圧縮を可能にします。これは、ペイロードタイプ、同期ソース識別子、およびタイムスタンプなどのデータが盗聴者に利用可能であることを意味します。さらに、RTPは将来のヘッダーの拡張を可能にするので、私達はどのような種類の敏感な情報も「漏洩」され得るものを予測することはできません。"
    },
    {
      "indent": 3,
      "text": "SRTP is a low-cost method, which allows header compression to reduce bandwidth. It is up to the endpoints' policies to decide about the security protocol to employ. If one really needs to protect headers, and is allowed to do so by the surrounding environment, then one should also look at alternatives, e.g., IPsec [RFC2401].",
      "ja": "SRTPは低コストのメソッドで、ヘッダー圧縮が帯域幅を減らすことができます。採用するセキュリティプロトコルについて決定するのはエンドポイントのポリシー次第です。周囲の環境によって本当にそうすることが許されている場合は、代替手段、例えばIPsec [RFC2401]を見る必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Integrity of the RTP payload and header",
      "section_title": true,
      "ja": "9.5. RTPペイロードとヘッダーの整合性"
    },
    {
      "indent": 3,
      "text": "SRTP messages are subject to attacks on their integrity and source identification, and these risks are discussed in Section 9.5.1. To protect against these attacks, each SRTP stream SHOULD be protected by HMAC-SHA1 [RFC2104] with an 80-bit output tag and a 160-bit key, or a message authentication code with equivalent strength. Secure RTP SHOULD NOT be used without message authentication, except under the circumstances described in this section. It is important to note that encryption algorithms, including AES Counter Mode and f8, do not provide message authentication. SRTCP MUST NOT be used with weak (or NULL) authentication.",
      "ja": "SRTPメッセージは、整合性とソースの識別に対する攻撃の対象となり、これらのリスクは9.5.1項で議論されています。これらの攻撃から保護するために、各SRTPストリームは、80ビットの出力タグと160ビットキーでHMAC-SHA1 [RFC2104]、または同等の強度を持つメッセージ認証コードで保護する必要があります。このセクションで説明されている状況下では、セキュアRTPはメッセージ認証なしで使用しないでください。AESカウンタモードおよびF8を含む暗号化アルゴリズムは、メッセージ認証を提供しないことに注意することが重要です。SRTCPは、弱い（またはNULL）認証で使用しないでください。"
    },
    {
      "indent": 3,
      "text": "SRTP MAY be used with weak authentication (e.g., a 32-bit authentication tag), or with no authentication (the NULL authentication algorithm). These options allow SRTP to be used to provide confidentiality in situations where",
      "ja": "SRTPは、弱い認証（例えば、32ビット認証タグ）、または認証なし（NULL認証アルゴリズム）と共に使用され得る。これらのオプションにより、SRTPを使用して、状況で機密性を提供できます。"
    },
    {
      "indent": 4,
      "text": "* weak or null authentication is an acceptable security risk, and * it is impractical to provide strong message authentication.",
      "ja": "* 弱いまたはNULL認証は許容できるセキュリティリスクであり、*強いメッセージ認証を提供することは実用的ではありません。"
    },
    {
      "indent": 3,
      "text": "These conditions are described below and in Section 7.5. Note that both conditions MUST hold in order for weak or null authentication to be used. The risks associated with exercising the weak or null authentication options need to be considered by a security audit prior to their use for a particular application or environment given the risks, which are discussed in Section 9.5.1.",
      "ja": "これらの条件については、7.5節で説明します。弱い認証またはヌル認証を使用するためには、両方の条件が保持されなければなりません。弱い認証オプションを実行することに関連するリスクは、9.5.1項で説明されているリスクを考慮して、特定のアプリケーションまたは環境の使用前にセキュリティ監査によって考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Weak authentication is acceptable when the RTP application is such that the effect of a small fraction of successful forgeries is negligible. If the application is stateless, then the effect of a single forged RTP packet is limited to the decoding of that particular packet. Under this condition, the size of the authentication tag MUST ensure that only a negligible fraction of the packets passed to the RTP application by the SRTP receiver can be forgeries. This fraction is negligible when an adversary, if given control of the forged packets, is not able to make a significant impact on the output of the RTP application (see the example of Section 7.5).",
      "ja": "RTPアプリケーションが、成功した偽造者の影響が無視できるほどの影響が少ない場合には、弱い認証が許容されます。アプリケーションがステートレスの場合、単一の鍛造RTPパケットの効果はその特定のパケットの復号化に制限されます。この条件では、認証タグのサイズは、SRTP受信者によってRTPアプリケーションに渡されたパケットのごくわずかな割合のみが偽物になることを保証する必要があります。鍛造パケットの制御が与えられている場合、このフラクタリーは無視できない場合、鍛造パケットの制御がRTPアプリケーションの出力に大きな影響を与えることができない（セクション7.5の例を参照）。"
    },
    {
      "indent": 3,
      "text": "Weak or null authentication MAY be acceptable when it is unlikely that an adversary can modify ciphertext so that it decrypts to an intelligible value. One important case is when it is difficult for an adversary to acquire the RTP plaintext data, since for many codecs, an adversary that does not know the input signal cannot manipulate the output signal in a controlled way. In many cases it may be difficult for the adversary to determine the actual value of the plaintext. For example, a hidden snooping device might be required in order to know a live audio or video signal. The adversary's signal must have a quality equivalent to or greater than that of the signal under attack, since otherwise the adversary would not have enough information to encode that signal with the codec used by the victim. Plaintext prediction may also be especially difficult for an interactive application such as a telephone call.",
      "ja": "弱いまたはNULL認証は、敵対者が暗号文を修正することができることがわかりやすい場合には許容可能であり得る。1つの重要なケースは、多くのコーデックでは、入力信号が制御された方法で出力信号を操作できないことを知らない敵対者がRTP平文データを取得することが困難である場合です。多くの場合、敵対者が平文の実際の価値を決定するのが難しいかもしれません。たとえば、ライブオーディオまたはビデオ信号を知るためには、隠されたスヌーピングデバイスが必要になる場合があります。逆の信号は、攻撃の影響を受けている信号のそれ以上の品質と同等かそれ以上の品質を持たなければなりません。平文の予測はまた、電話などの対話型アプリケーションにとって特に困難であり得る。"
    },
    {
      "indent": 3,
      "text": "Weak or null authentication MUST NOT be used when the RTP application makes data forwarding or access control decisions based on the RTP data. In such a case, an attacker may be able to subvert confidentiality by causing the receiver to forward data to an attacker. See Section 3 of [B96] for a real-life example of such attacks.",
      "ja": "RTPアプリケーションがRTPデータに基づいてデータ転送またはアクセス制御の決定を下す場合は、弱いまたはNULL認証を使用しないでください。そのような場合、攻撃者は受信機にデータを攻撃者に転送させることによって機密性を阻止することができるかもしれない。そのような攻撃の実際の例では、[B96]のセクション3を参照してください。"
    },
    {
      "indent": 0,
      "text": " Null authentication MUST NOT be used when a replay attack, in which an adversary stores packets then replays them later in the session, could have a non-negligible impact on the receiver. An example of a successful replay attack is the storing of the output of a surveillance camera for a period of time, later followed by the injection of that output to the monitoring station to avoid surveillance. Encryption does not protect against this attack, and non-null authentication is REQUIRED in order to defeat it.",
      "ja": "敵対認証は、敵対者がパケットを保存する再生攻撃がセッションの後半で再利用する場合は、受信者に無視できない影響を与える可能性があります。再生攻撃が成功した例は、監視カメラの出力の保存であり、後で監視局へのその出力の注入が続いて監視を回避することが成功することである。暗号化はこの攻撃から保護されません、そしてそれを倒すためにはヌル以外の認証が必要です。"
    },
    {
      "indent": 3,
      "text": "If existential message forgery is an issue, i.e., when the accuracy of the received data is of non-negligible importance, null authentication MUST NOT be used.",
      "ja": "存在メッセージの偽造が問題である場合、すなわち受信データの正確さが無視されない重要である場合、NULL認証は使用されてはならない。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Risks of Weak or Null Message Authentication",
      "section_title": true,
      "ja": "9.5.1. 弱いまたはNULLメッセージ認証のリスク"
    },
    {
      "indent": 3,
      "text": "During a security audit considering the use of weak or null authentication, it is important to keep in mind the following attacks which are possible when no message authentication algorithm is used.",
      "ja": "弱い認証またはヌル認証の使用を考慮したセキュリティ監査中に、メッセージ認証アルゴリズムが使用されていない場合に可能な次の攻撃を留意することが重要です。"
    },
    {
      "indent": 3,
      "text": "An attacker who cannot predict the plaintext is still always able to modify the message sent between the sender and the receiver so that it decrypts to a random plaintext value, or to send a stream of bogus packets to the receiver that will decrypt to random plaintext values. This attack is essentially a denial of service attack, though in the absence of message authentication, the RTP application will have inputs that are bit-wise correlated with the true value. Some multimedia codecs and common operating systems will crash when such data are accepted as valid video data. This denial of service attack may be a much larger threat than that due to an attacker dropping, delaying, or re-ordering packets.",
      "ja": "プレーンテキストを予測できない攻撃者は、まだ、送信者と受信者との間で送信されたメッセージを無作為平文の値に復号化するか、またはランダム平文の値に復号化する受信者にBogusパケットのストリームを送信することができる。。この攻撃は基本的にはサービス拒否攻撃であるが、メッセージ認証がないが、RTPアプリケーションは、真の値とビット的に相関している入力を有することになる。そのようなデータが有効なビデオデータとして受け入れられると、いくつかのマルチメディアコーデックと共通オペレーティングシステムがクラッシュします。このサービス拒否攻撃は、攻撃者の落下、遅延、または並べ替えることによるものよりはるかに大きな脅威となる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An attacker who cannot predict the plaintext can still replay a previous message with certainty that the receiver will accept it. Applications with stateless codecs might be robust against this type of attack, but for other, more complex applications these attacks may be far more grave.",
      "ja": "平文を予測できない攻撃者は、受信者がそれを受け入れることを確実に確実に確実に再生することができます。ステートレスコーデックを持つアプリケーションは、このタイプの攻撃に対して堅牢になる可能性がありますが、他の複雑なアプリケーションでは、これらの攻撃ははるかに墓になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An attacker who can predict the plaintext can modify the ciphertext so that it will decrypt to any value of her choosing. With an additive stream cipher, an attacker will always be able to change individual bits.",
      "ja": "平文を予測できる攻撃者は、それが選択された任意の価値に復号化するように暗号文を修正することができます。加法ストリーム暗号を使用すると、攻撃者は常に個々のビットを変更することができます。"
    },
    {
      "indent": 0,
      "text": " An attacker may be able to subvert confidentiality due to the lack of authentication when a data forwarding or access control decision is made on decrypted but unauthenticated plaintext. This is because the receiver may be fooled into forwarding data to an attacker, leading to an indirect breach of confidentiality (see Section 3 of [B96]). This is because data-forwarding decisions are made on the decrypted plaintext; information in the plaintext will determine to what subnet (or process) the plaintext is forwarded in ESP [RFC2401] tunnel mode (respectively, transport mode). When Secure RTP is used without message authentication, it should be verified that the application does not make data forwarding or access control decisions based on the decrypted plaintext.",
      "ja": "攻撃者は、復号化されているが認証されていない平文に基づいてデータ転送またはアクセス制御の決定が行われる場合、認証の欠如のために機密性を侵害することができるかもしれません。これは、受信機がデータを攻撃者に転送するようにだまされている可能性があるため、機密性の間接的な違反をもたらすからです（[B96]のセクション3を参照）。これは、データ転送の決定が復号化された平文で行われるためです。Plaintextの情報は、PlaintextがESP（RFC2401]トンネルモード（それぞれトランスポートモード）で転送されたサブネット（またはプロセス）を決定します。セキュアRTPをメッセージ認証なしで使用すると、アプリケーションが復号化された平文に基づいてデータ転送またはアクセス制御の決定を下さないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some cipher modes of operation that require padding, e.g., standard cipher block chaining (CBC) are very sensitive to attacks on confidentiality if certain padding types are used in the absence of integrity. The attack [V02] shows that this is indeed the case for the standard RTP padding as discussed in reference to Figure 1, when used together with CBC mode. Later transform additions to SRTP MUST therefore carefully consider the risk of using this padding without proper integrity protection.",
      "ja": "パディング、例えば標準暗号ブロック連鎖（CBC）を必要とするいくつかの暗号化操作モードは、一定のパディングタイプが完全性がない場合に使用される場合、機密性に対する攻撃に対して非常に敏感です。Attack [V02]は、これが実際には、図1を参照して、CBCモードと一緒に使用されるときに標準的なRTPパディングの場合が実際にあることを示しています。したがって、後の変換SRTPへの追加は、適切な完全性保護なしにこのパディングを使用する危険性を慎重に検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Implicit Header Authentication",
      "section_title": true,
      "ja": "9.5.2. 暗黙のヘッダー認証"
    },
    {
      "indent": 3,
      "text": "The IV formation of the f8-mode gives implicit authentication (IHA) of the RTP header, even when message authentication is not used. When IHA is used, an attacker that modifies the value of the RTP header will cause the decryption process at the receiver to produce random plaintext values. While this protection is not equivalent to message authentication, it may be useful for some applications.",
      "ja": "F8モードのIV形成は、メッセージ認証が使用されていない場合でも、RTPヘッダの暗黙の認証（IHA）を与えます。IHAが使用されるとき、RTPヘッダーの値を変更する攻撃者は、受信側の復号化プロセスによってランダムな平文の値を生成させます。この保護はメッセージ認証と同等ではありませんが、一部のアプリケーションに役立ちます。"
    },
    {
      "indent": 0,
      "text": "10. Interaction with Forward Error Correction mechanisms",
      "section_title": true,
      "ja": "10. 前方誤り訂正機構との相互作用"
    },
    {
      "indent": 3,
      "text": "The default processing when using Forward Error Correction (e.g., RFC 2733) processing with SRTP SHALL be to perform FEC processing prior to SRTP processing on the sender side and to perform SRTP processing prior to FEC processing on the receiver side. Any change to this ordering (reversing it, or, placing FEC between SRTP encryption and SRTP authentication) SHALL be signaled out of band.",
      "ja": "SRTPを用いた前方誤り訂正（例えばRFC2733）処理を用いた場合のデフォルト処理は、送信側でSRTP処理の前にFEC処理を行い、受信側でのFEC処理の前にSRTP処理を行うものとする。この順序付け（反転、またはSRTP暗号化とSRTP認証の間にFECを配置する）の変更は、帯域外に通知されます。"
    },
    {
      "indent": 0,
      "text": "11. Scenarios",
      "section_title": true,
      "ja": "11. シナリオ"
    },
    {
      "indent": 3,
      "text": "SRTP can be used as security protocol for the RTP/RTCP traffic in many different scenarios. SRTP has a number of configuration options, in particular regarding key usage, and can have impact on the total performance of the application according to the way it is used. Hence, the use of SRTP is dependent on the kind of scenario and application it is used with. In the following, we briefly illustrate some use cases for SRTP, and give some guidelines for recommended setting of its options.",
      "ja": "SRTPは、さまざまなシナリオでRTP / RTCPトラフィックのセキュリティプロトコルとして使用できます。SRTPには、特に鍵の使用法に関して、いくつかの設定オプションがあり、使用方法に従ってアプリケーションの全体的なパフォーマンスに影響を与える可能性があります。したがって、SRTPの使用はシナリオの種類やアプリケーションに依存しています。以下では、SRTPのユースケースを簡単に説明し、そのオプションの推奨設定のためのガイドラインをいくつか示します。"
    },
    {
      "indent": 0,
      "text": "11.1. Unicast",
      "section_title": true,
      "ja": "11.1. ユニキャスト"
    },
    {
      "indent": 3,
      "text": "A typical example would be a voice call or video-on-demand application.",
      "ja": "典型的な例は、音声通話またはビデオオンデマンドアプリケーションです。"
    },
    {
      "indent": 3,
      "text": "Consider one bi-directional RTP stream, as one RTP session. It is possible for the two parties to share the same master key in the two directions according to the principles of Section 9.1. The first round of the key derivation splits the master key into any or all of the following session keys (according to the provided security functions):",
      "ja": "1つのRTPセッションとして、1つの双方向RTPストリームを検討してください。セクション9.1の原理に従って、2人の当事者が2つの方向に同じマスターキーを共有することが可能です。キー導出の最初のラウンドは、マスターキーを次のセッションキーのいずれかまたはすべてに分割します（提供されたセキュリティ機能に従って）。"
    },
    {
      "indent": 3,
      "text": "SRTP_encr_key, SRTP_auth_key, SRTCP_encr_key, and SRTCP_auth key.",
      "ja": "SRTP_ENCR_KEY、SRTP_AUTH_KEY、SRTCP_ENCR_KEY、およびSRTCP_AUTHキー。"
    },
    {
      "indent": 3,
      "text": "(For simplicity, we omit discussion of the salts, which are also derived.) In this scenario, it will in most cases suffice to have a single master key with the default lifetime. This guarantees sufficiently long lifetime of the keys and a minimum set of keys in place for most practical purposes. Also, in this case RTCP protection can be applied smoothly. Under these assumptions, use of the MKI can be omitted. As the key-derivation in combination with large difference in the packet rate in the respective directions may require simultaneous storage of several session keys, if storage is an issue, we recommended to use low-rate key derivation.",
      "ja": "（簡単にするために、我々はまた導出される塩の議論を省略します。）このシナリオでは、ほとんどの場合、デフォルトの寿命を持つ単一のマスターキーを持つことは十分です。これにより、最も実用的な目的のために、鍵の十分に長い寿命と最低限の鍵のセットが適所に保証されます。また、この場合、RTCP保護をスムーズに適用することができます。これらの仮定の下で、MKIの使用は省略することができます。それぞれの方向のパケットレートの大きな違いと組み合わせることで、複数のセッションキーを同時に記憶する必要があるかもしれない、ストレージが問題である場合、我々は低速鍵導出を使用することを勧告する。"
    },
    {
      "indent": 3,
      "text": "The same considerations can be extended to the unicast scenario with multiple RTP sessions, where each session would have a distinct master key.",
      "ja": "同じ考察は、複数のRTPセッションを使用してユニキャストシナリオに拡張することができます。各セッションは異なるマスターキーを持つことになります。"
    },
    {
      "indent": 0,
      "text": "11.2. Multicast (one sender)",
      "section_title": true,
      "ja": "11.2. マルチキャスト（1つの送信者）"
    },
    {
      "indent": 3,
      "text": "Just as with (unprotected) RTP, a scalability issue arises in big groups due to the possibly very large amount of SRTCP Receiver Reports that the sender might need to process. In SRTP, the sender may have to keep state (the cryptographic context) for each receiver, or more precisely, for the SRTCP used to protect Receiver Reports. The overhead increases proportionally to the size of the group. In particular, re-keying requires special concern, see below.",
      "ja": "（保護されていない）RTPと同じように、送信者が処理する必要があるかもしれないほど非常に大量のSRTCP受信機が報告されるため、スケーラビリティの問題が大きなグループで発生します。SRTPでは、送信者は、受信者レポートを保護するために使用されるSRTCPに対して、各受信者の状態（暗号化コンテキスト）を保持する必要がある場合があります。オーバーヘッドはグループのサイズに比例して増加します。特に、リーキーリングには特別な懸念が必要です。下記を参照してください。"
    },
    {
      "indent": 3,
      "text": "Consider first a small group of receivers. There are a few possible setups with the distribution of master keys among the receivers. Given a single RTP session, one possibility is that the receivers share the same master key as per Section 9.1 to secure all their respective RTCP traffic. This shared master key could then be the same one used by the sender to protect its outbound SRTP traffic. Alternatively, it could be a master key shared only among the receivers and used solely for their SRTCP traffic. Both alternatives require the receivers to trust each other.",
      "ja": "最初に少数の受信機グループを検討してください。受信者間のマスターキーの配布を伴う可能なセットアップがいくつかあります。単一のRTPセッションを考慮すると、受信者はセクション9.1と同じマスターキーを共有して、すべてのRTCPトラフィックを保護することです。この共有マスターキーは、送信者がそのアウトバウンドSRTPトラフィックを保護するために使用されるものと同じものになる可能性があります。あるいは、それは受信機間でのみ共有され、それらのSRTCPトラフィックのためだけに使用されているマスターキーであり得る。両方の選択肢は受信機が互いに信頼することを要求する。"
    },
    {
      "indent": 0,
      "text": " Considering SRTCP and key storage, it is recommended to use low-rate (or zero) key_derivation (except the mandatory initial one), so that the sender does not need to store too many session keys (each SRTCP stream might otherwise have a different session key at a given point in time, as the SRTCP sources send at different times). Thus, in case key derivation is wanted for SRTP, the cryptographic context for SRTP can be kept separate from the SRTCP crypto context, so that it is possible to have a key_derivation_rate of 0 for SRTCP and a non-zero value for SRTP.",
      "ja": "SRTCPおよびキーストレージを考慮すると、低レート（またはゼロ）キーを使用することをお勧めします（必須の最初の1つを除く）、送信側はあまりにも多くのセッションキーを保存する必要はありません（各SRTCPストリームでは別のセッションが異なる場合があります。SRTCPソースが異なる時点で送信されるときに、特定の時点でのキーのキー。したがって、SRTPに対して鍵導出が望まれる場合、SRTPの暗号化コンテキストをSRTCP暗号コンテキストとは別に保つことができ、SRTCPの場合は0のkey_delivation_rateおよびSRTPのゼロ以外の値を得ることができる。"
    },
    {
      "indent": 3,
      "text": "Use of the MKI for re-keying is RECOMMENDED for most applications (see Section 8.1).",
      "ja": "ほとんどのアプリケーションには、REキーイングのためのMKIを使用することをお勧めします（セクション8.1を参照）。"
    },
    {
      "indent": 3,
      "text": "If there are more than one SRTP/SRTCP stream (within the same RTP session) that share the master key, the upper limit of 2^48 SRTP packets / 2^31 SRTCP packets means that, before one of the streams reaches its maximum number of packets, re-keying MUST be triggered on ALL streams sharing the master key. (From strict security point of view, only the stream reaching the maximum would need to be re-keyed, but then the streams would no longer be sharing master key, which is the intention.) A local policy at the sender side should force rekeying in a way that the maximum packet limit is not reached on any of the streams. Use of the MKI for re-keying is RECOMMENDED.",
      "ja": "マスターキーを共有するSRTP / SRTCPストリーム（同じRTPセッション内）が複数ある場合は、2 ^ 48 SRTPパケット/ 2 31 SRTCPパケットの上限は、一方のストリームが最大数に達する前にそれを意味します。パケットのうち、マスターキーを共有するすべてのストリームで再キーイングを起動する必要があります。（厳密なセキュリティの観点からは、最大のセキュリティの観点からは、最大に達するだけでは再キーが付いている必要がありますが、ストリームはマスターキーを共有しなくなりました。最大パケット制限がいずれかのストリームに到達しないように。再キーイングのためのMKIを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "In large multicast with one sender, the same considerations as for the small group multicast hold. The biggest issue in this scenario is the additional load placed at the sender side, due to the state (cryptographic contexts) that has to be maintained for each receiver, sending back RTCP Receiver Reports. At minimum, a replay window might need to be maintained for each RTCP source.",
      "ja": "1つの送信者との大規模なマルチキャストでは、小グループマルチキャストホールドと同じ考察。このシナリオで最大の問題は、各受信者に対して維持されなければならない状態（暗号化コンテキスト）がRTCP受信側レポートを送信する状態（暗号化コンテキスト）のために、送信者側に追加の負荷をかけています。最低限、RTCPソースごとに再生ウィンドウを維持する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "11.3. Re-keying and access control",
      "section_title": true,
      "ja": "11.3. 再キーイングとアクセス制御"
    },
    {
      "indent": 3,
      "text": "Re-keying may occur due to access control (e.g., when a member is removed during a multicast RTP session), or for pure cryptographic reasons (e.g., the key is at the end of its lifetime). When using SRTP default transforms, the master key MUST be replaced before any of the index spaces are exhausted for any of the streams protected by one and the same master key.",
      "ja": "アクセス制御（例えば、マルチキャストRTPセッション中にメンバが取り外されるとき）、または純粋な暗号理由のために（例えば、鍵はその生涯の終わりにある）アクセス制御のために起こり得る。SRTPのデフォルト変換を使用する場合、マスターキーは、1つおよび同じマスターキーによって保護されたストリームのいずれかに対して任意の索引スペースが使い果たされる前に置き換える必要があります。"
    },
    {
      "indent": 0,
      "text": " How key management re-keys SRTP implementations is out of scope, but it is clear that there are straightforward ways to manage keys for a multicast group. In one-sender multicast, for example, it is typically the responsibility of the sender to determine when a new key is needed. The sender is the one entity that can keep track of when the maximum number of packets has been sent, as receivers may join and leave the session at any time, there may be packet loss and delay etc. In scenarios other than one-sender multicast, other methods can be used. Here, one must take into consideration that key exchange can be a costly operation, taking several seconds for a single exchange. Hence, some time before the master key is exhausted/expires, out-of-band key management is initiated, resulting in a new master key that is shared with the receiver(s). In any event, to maintain synchronization when switching to the new key, group policy might choose between using the MKI and the <From, To>, as described in Section 8.1.",
      "ja": "キー管理の再キーSRTPの実装が範囲外ですが、マルチキャストグループのキーを管理する方法が簡単です。たとえば、1つの送信者マルチキャストでは、通常、新しいキーがいつ必要かを判断するための送信者の責任です。送信者は、受信者がいつでも参加してセッションを終了することができるので、パケットの最大数が送信されてセッションを終了することができる場合、1つの送信者マルチキャスト以外のシナリオでは、パケットの損失と遅延などがある場合があります。他の方法を使用することができる。ここでは、単一の交換のために数秒かかり、鍵交換が費用のかかる操作になる可能性があることを考慮に入れる必要があります。したがって、マスターキーが使い果たされた/期限切れになるまでの時間は、帯域外鍵管理が開始され、その結果、受信者と共有される新しいマスターキーが生成されます。いずれにせよ、新しいキーに切り替えるときに同期を維持するために、セクション8.1で説明されているように、グループポリシーはMKIと<FROM、TO>を使用して選択することがあります。"
    },
    {
      "indent": 3,
      "text": "For access control purposes, the <From, To> periods are set at the desired granularity, dependent on the packet rate. High rate re-keying can be problematic for SRTCP in some large-group scenarios. As mentioned, there are potential problems in using the SRTP index, rather than the SRTCP index, for determining the master key. In particular, for short periods during switching of master keys, it may be the case that SRTCP packets are not under the current master key of the correspondent SRTP. Therefore, using the MKI for re-keying in such scenarios will produce better results.",
      "ja": "アクセス制御の目的のために、パケットレートに応じて、<from、to>期間が所望の粒度に設定される。いくつかの大グループシナリオでは、SRTCPにとって高いレートの再キーイングが問題になる可能性があります。前述のように、マスターキーを決定するためのSRTCPインデックスではなく、SRTPインデックスを使用する潜在的な問題があります。特に、マスターキーの切り替え中の短期間の場合、SRTCPパケットがCROPENT SRTPの現在のマスターキーの下にない場合であり得る。したがって、このようなシナリオでの再キーイングにMKIを使用すると、より良い結果が得られます。"
    },
    {
      "indent": 0,
      "text": "11.4. Summary of basic scenarios",
      "section_title": true,
      "ja": "11.4. 基本シナリオの概要"
    },
    {
      "indent": 3,
      "text": "The description of these scenarios highlights some recommendations on the use of SRTP, mainly related to re-keying and large scale multicast:",
      "ja": "これらのシナリオの説明は、主に再キーイングおよび大規模マルチキャストに関連するSRTPの使用に関するいくつかの推奨事項を強調しています。"
    },
    {
      "indent": 3,
      "text": "- Do not use fast re-keying with the <From, To> feature. It may, in particular, give problems in retrieving the correct SRTCP key, if an SRTCP packet arrives close to the re-keying time. The MKI SHOULD be used in this case.",
      "ja": "- <FROM、TO>機能で高速再キーイングを使用しないでください。特に、SRTCPパケットがリダイータイムに近づくと、特に正しいSRTCPキーを検索する際に問題がある可能性があります。この場合、MKIを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- If multiple SRTP streams in the same RTP session share the same master key, also moderate rate re-keying MAY have the same problems, and the MKI SHOULD be used.",
      "ja": "- 同じRTPセッション内の複数のSRTPストリームが同じマスターキーを共有している場合も、適度なレートの再キーイングに同じ問題があり、MKIを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- Though offering increased security, a non-zero key_derivation_rate is NOT RECOMMENDED when trying to minimize the number of keys in use with multiple streams.",
      "ja": "- セキュリティを強化することは、複数のストリームで使用されているキーの数を最小化しようとすると、ゼロ以外のkey_delivation_rateはお勧めできません。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The RTP specification establishes a registry of profile names for use by higher-level control protocols, such as the Session Description Protocol (SDP), to refer to transport methods. This profile registers the name \"RTP/SAVP\".",
      "ja": "RTP仕様は、トランスポート方法を参照するために、セッション記述プロトコル（SDP）などの上位レベルの制御プロトコルで使用するためのプロファイル名のレジストリを確立します。このプロファイルは \"rtp / savp\"という名前を登録します。"
    },
    {
      "indent": 3,
      "text": "SRTP uses cryptographic transforms which a key management protocol signals. It is the task of each particular key management protocol to register the cryptographic transforms or suites of transforms with IANA. The key management protocol conveys these protocol numbers, not SRTP, and each key management protocol chooses the numbering scheme and syntax that it requires.",
      "ja": "SRTPは、キー管理プロトコル信号がどの暗号変換を使用します。暗号変換または変換のスイートをIANAで登録するのは、特定の鍵管理プロトコルのタスクです。キー管理プロトコルは、SRTPではなくこれらのプロトコル番号を伝達し、各キー管理プロトコルは必要な番号付け方式と構文を選択します。"
    },
    {
      "indent": 3,
      "text": "Specification of a key management protocol for SRTP is out of scope here. Section 8.2, however, provides guidance on the parameters that need to be defined for the default and mandatory transforms.",
      "ja": "SRTPの鍵管理プロトコルの指定はここでは範囲外です。ただし、セクション8.2は、デフォルトの変換と必須変換に対して定義する必要があるパラメータに対するガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "13. Acknowledgements",
      "section_title": true,
      "ja": "13. 謝辞"
    },
    {
      "indent": 3,
      "text": "David Oran (Cisco) and Rolf Blom (Ericsson) are co-authors of this document but their valuable contributions are acknowledged here to keep the length of the author list down.",
      "ja": "David Oran (Cisco)とRolf Blom (Ericsson) もこの文書の共著者ですが、著者リストの長さを抑えるため、ここでの謝辞をもって彼らの貴重な貢献とさせていただきます。"
    },
    {
      "indent": 3,
      "text": "The authors would in addition like to thank Magnus Westerlund, Brian Weis, Ghyslain Pelletier, Morgan Lindqvist, Robert Fairlie-Cuninghame, Adrian Perrig, the AVT WG and in particular the chairmen Colin Perkins and Stephen Casner, the Transport and Security Area Directors, and Eric Rescorla for their reviews and support.",
      "ja": "著者はさらに、Magnus Westerlund、Brian Weis、Ghyslain Pelletier、Morgan Lindqvist、Robert Fairlie-Cuninghame、Adrian Perrig、AVT WG、特に議長のColin PerkinsとStephen Casner、Transport and Security Area Directors、そしてEric Rescorlaのレビューとサポートに感謝します。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14. 参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[AES]     NIST, \"Advanced Encryption Standard (AES)\", FIPS PUB 197,\n          http://www.nist.gov/aes/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, 1997年2月."
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, 1997年3月."
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for Internet Protocol\", RFC 2401, 1998年11月."
    },
    {
      "indent": 3,
      "text": "[RFC2828] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, May 2000.",
      "ja": "[RFC2828] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, 2000年5月."
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-time Applications\", RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-time Applications\", RFC 3550, 2003年7月."
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", RFC 3551, July 2003.",
      "ja": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", RFC 3551, 2003年7月."
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考的文献"
    },
    {
      "indent": 3,
      "text": "[AES-CTR] Lipmaa, H., Rogaway, P. and D. Wagner, \"CTR-Mode\n          Encryption\", NIST, http://csrc.nist.gov/encryption/modes/\n          workshop1/papers/lipmaa-ctr.pdf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[B96] Bellovin, S., \"Problem Areas for the IP Security Protocols,\" in Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1-16, San Jose, CA, July 1996 (http://www.research.att.com/~smb/papers/index.html).",
      "ja": "[B96] Bellovin, S., \"Problem Areas for the IP Security Protocols,\" in Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1-16, San Jose, CA, July 1996 (http://www.research.att.com/~smb/papers/index.html)."
    },
    {
      "indent": 3,
      "text": "[BDJR] Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, \"A Concrete Treatment of Symmetric Encryption: Analysis of DES Modes of Operation\", Proceedings 38th IEEE FOCS, pp. 394- 403, 1997.",
      "ja": "[BDJR] Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, \"A Concrete Treatment of Symmetric Encryption: Analysis of DES Modes of Operation\", Proceedings 38th IEEE FOCS, pp. 394- 403, 1997."
    },
    {
      "indent": 3,
      "text": "[BS00] Biryukov, A. and A. Shamir, \"Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers\", Proceedings, ASIACRYPT 2000, LNCS 1976, pp. 1-13, Springer Verlag.",
      "ja": "[BS00] Biryukov, A. and A. Shamir, \"Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers\", Proceedings, ASIACRYPT 2000, LNCS 1976, pp. 1-13, Springer Verlag."
    },
    {
      "indent": 3,
      "text": "[C99] Crowell, W. P., \"Introduction to the VENONA Project\", http://www.nsa.gov:8080/docs/venona/index.html.",
      "ja": "[C99] Crowell, W. P., \"Introduction to the VENONA Project\", http://www.nsa.gov:8080/docs/venona/index.html."
    },
    {
      "indent": 3,
      "text": "[CTR] Dworkin, M., NIST Special Publication 800-38A, \"Recommendation for Block Cipher Modes of Operation: Methods and Techniques\", 2001. http://csrc.nist.gov/publications/nistpubs/800-38a/sp800- 38a.pdf.",
      "ja": "[CTR] Dworkin, M., NIST Special Publication 800-38A, \"Recommendation for Block Cipher Modes of Operation: Methods and Techniques\", 2001. http://csrc.nist.gov/publications/nistpubs/800-38a/sp800- 38a.pdf."
    },
    {
      "indent": 3,
      "text": "[f8-a] 3GPP TS 35.201 V4.1.0 (2001-12) Technical Specification 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Specification of the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9 Specification (Release 4).",
      "ja": "[f8-a] 3GPP TS 35.201 V4.1.0 (2001-12) Technical Specification 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Specification of the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9 Specification (Release 4)."
    },
    {
      "indent": 3,
      "text": "[f8-b] 3GPP TR 33.908 V4.0.0 (2001-09) Technical Report 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; General Report on the Design, Specification and Evaluation of 3GPP Standard Confidentiality and Integrity Algorithms (Release 4).",
      "ja": "[f8-b] 3GPP TR 33.908 V4.0.0 (2001-09) Technical Report 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; General Report on the Design, Specification and Evaluation of 3GPP Standard Confidentiality and Integrity Algorithms (Release 4)."
    },
    {
      "indent": 3,
      "text": "[GDOI] Baugher, M., Weis, B., Hardjono, T. and H. Harney, \"The Group Domain of Interpretation, RFC 3547, July 2003.",
      "ja": "[GDOI] Baugher, M., Weis, B., Hardjono, T. and H. Harney, \"The Group Domain of Interpretation, RFC 3547, July 2003."
    },
    {
      "indent": 3,
      "text": "[HAC] Menezes, A., Van Oorschot, P. and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press, 1997, ISBN 0-8493- 8523-7.",
      "ja": "[HAC] Menezes, A., Van Oorschot, P. and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press, 1997, ISBN 0-8493- 8523-7."
    },
    {
      "indent": 3,
      "text": "[H80] Hellman, M. E., \"A cryptanalytic time-memory trade-off\", IEEE Transactions on Information Theory, July 1980, pp. 401-406.",
      "ja": "[H80] Hellman, M. E., \"A cryptanalytic time-memory trade-off\", IEEE Transactions on Information Theory, July 1980, pp. 401-406."
    },
    {
      "indent": 3,
      "text": "[IK] T. Iwata and T. Kohno: \"New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms\", Proceedings of FSE 2004.",
      "ja": "[IK] T. Iwata and T. Kohno: \"New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms\", Proceedings of FSE 2004."
    },
    {
      "indent": 3,
      "text": "[KINK] Thomas, M. and J. Vilhuber, \"Kerberized Internet Negotiation of Keys (KINK)\", Work in Progress.",
      "ja": "[KINK] Thomas, M. and J. Vilhuber, \"Kerberized Internet Negotiation of Keys (KINK)\", Work in Progress."
    },
    {
      "indent": 3,
      "text": "[KEYMGT] Arrko, J., et al., \"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)\", Work in Progress.",
      "ja": "[KEYMGT] Arrko, J., et al., \"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)\", Work in Progress."
    },
    {
      "indent": 3,
      "text": "[KSYH] Kang, J-S., Shin, S-U., Hong, D. and O. Yi, \"Provable Security of KASUMI and 3GPP Encryption Mode f8\", Proceedings Asiacrypt 2001, Springer Verlag LNCS 2248, pp. 255-271, 2001.",
      "ja": "[KSYH] Kang, J-S., Shin, S-U., Hong, D. and O. Yi, \"Provable Security of KASUMI and 3GPP Encryption Mode f8\", Proceedings Asiacrypt 2001, Springer Verlag LNCS 2248, pp. 255-271, 2001."
    },
    {
      "indent": 3,
      "text": "[MIKEY] Arrko, J., et. al., \"MIKEY: Multimedia Internet KEYing\", Work in Progress.",
      "ja": "[MIKEY] Arrko, J., et. al., \"MIKEY: Multimedia Internet KEYing\", Work in Progress."
    },
    {
      "indent": 3,
      "text": "[MF00] McGrew, D. and S. Fluhrer, \"Attacks on Encryption of Redundant Plaintext and Implications on Internet Security\", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag.",
      "ja": "[MF00] McGrew, D. and S. Fluhrer, \"Attacks on Encryption of Redundant Plaintext and Implications on Internet Security\", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag."
    },
    {
      "indent": 3,
      "text": "[PCST1] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient and Secure Source Authentication for Multicast\", in Proc. of Network and Distributed System Security Symposium NDSS 2001, pp. 35-46, 2001.",
      "ja": "[PCST1] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient and Secure Source Authentication for Multicast\", in Proc. of Network and Distributed System Security Symposium NDSS 2001, pp. 35-46, 2001."
    },
    {
      "indent": 3,
      "text": "[PCST2] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient Authentication and Signing of Multicast Streams over Lossy Channels\", in Proc. of IEEE Security and Privacy Symposium S&P2000, pp. 56-73, 2000.",
      "ja": "[PCST2] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient Authentication and Signing of Multicast Streams over Lossy Channels\", in Proc. of IEEE Security and Privacy Symposium S&P2000, pp. 56-73, 2000."
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, 1994年12月."
    },
    {
      "indent": 3,
      "text": "[RFC2675] Borman, D., Deering, S. and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, August 1999.",
      "ja": "[RFC2675] Borman, D., Deering, S. and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, 1999年8月."
    },
    {
      "indent": 3,
      "text": "[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T. and H. Zheng, \"RObust Header Compression: Framework and Four Profiles: RTP, UDP, ESP, and uncompressed (ROHC)\", RFC 3095, July 2001.",
      "ja": "[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T. and H. Zheng, \"RObust Header Compression: Framework and Four Profiles: RTP, UDP, ESP, and uncompressed (ROHC)\", RFC 3095, 2001年7月."
    },
    {
      "indent": 3,
      "text": "[RFC3242] Jonsson, L-E. and G. Pelletier, \"RObust Header Compression (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP \", RFC 3242, April 2002.",
      "ja": "[RFC3242] Jonsson, L-E. and G. Pelletier, \"RObust Header Compression (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP \", RFC 3242, 2002年4月."
    },
    {
      "indent": 3,
      "text": "[SDMS] Andreasen, F., Baugher, M. and D. Wing, \"Session Description Protocol Security Descriptions for Media Streams\", Work in Progress.",
      "ja": "[SDMS] Andreasen, F., Baugher, M. and D. Wing, \"Session Description Protocol Security Descriptions for Media Streams\", Work in Progress."
    },
    {
      "indent": 3,
      "text": "[SWO] Svanbro, K., Wiorek, J. and B. Olin, \"Voice-over-IP-over-wireless\", Proc. PIMRC 2000, London, Sept. 2000.",
      "ja": "[SWO] Svanbro, K., Wiorek, J. and B. Olin, \"Voice-over-IP-over-wireless\", Proc. PIMRC 2000, London, Sept. 2000."
    },
    {
      "indent": 3,
      "text": "[V02] Vaudenay, S., \"Security Flaws Induced by CBC Padding - Application to SSL, IPsec, WTLS...\", Advances in Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545.",
      "ja": "[V02] Vaudenay, S., \"Security Flaws Induced by CBC Padding - Application to SSL, IPsec, WTLS...\", Advances in Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545."
    },
    {
      "indent": 3,
      "text": "[WC81] Wegman, M. N., and J.L. Carter, \"New Hash Functions and Their Use in Authentication and Set Equality\", JCSS 22, 265-279, 1981.",
      "ja": "[WC81] Wegman, M. N., and J.L. Carter, \"New Hash Functions and Their Use in Authentication and Set Equality\", JCSS 22, 265-279, 1981."
    },
    {
      "indent": 0,
      "text": "Appendix A: Pseudocode for Index Determination",
      "ja": "付録A: インデックス決定のための疑似コード"
    },
    {
      "indent": 3,
      "text": "The following is an example of pseudo-code for the algorithm to determine the index i of an SRTP packet with sequence number SEQ. In the following, signed arithmetic is assumed.",
      "ja": "以下は、シーケンス番号SEQを持つSRTPパケットのインデックスiを決定するためのアルゴリズムの疑似コードの例です。以下では、符号付き算術演算が想定されています。"
    },
    {
      "indent": 9,
      "text": "if (s_l < 32,768) if (SEQ - s_l > 32,768) set v to (ROC-1) mod 2^32 else set v to ROC endif else if (s_l - 32,768 > SEQ) set v to (ROC+1) mod 2^32 else set v to ROC endif endif return SEQ + v*65,536",
      "ja": "if (s_l < 32,768) if (SEQ - s_l > 32,768) v = (ROC-1) mod 2^32 else v = ROC endif else if (s_l - 32,768 > SEQ) v = (ROC+1) mod 2^32 else v = ROC endif endif return SEQ + v*65,536"
    },
    {
      "indent": 0,
      "text": "Appendix B: Test Vectors",
      "ja": "付録B: テストベクター"
    },
    {
      "indent": 3,
      "text": "All values are in hexadecimal.",
      "ja": "すべての値は16進数です。"
    },
    {
      "indent": 0,
      "text": "B.1. AES-f8 Test Vectors",
      "section_title": true,
      "ja": "B.1. AES-f8テストベクター"
    },
    {
      "indent": 3,
      "text": "SRTP PREFIX LENGTH : 0",
      "ja": "SRTP PREFIX LENGTH : 0"
    },
    {
      "indent": 3,
      "text": "RTP packet header : 806e5cba50681de55c621599",
      "ja": "RTP packet header : 806e5cba50681de55c621599"
    },
    {
      "indent": 3,
      "text": "RTP packet payload : 70736575646f72616e646f6d6e657373 20697320746865206e65787420626573 74207468696e67",
      "ja": "RTP packet payload : 70736575646f72616e646f6d6e657373 20697320746865206e65787420626573 74207468696e67"
    },
    {
      "indent": 3,
      "text": "ROC                 :   d462564a\nkey                 :   234829008467be186c3de14aae72d62c\nsalt key            :   32f2870d\nkey-mask (m)        :   32f2870d555555555555555555555555\nkey XOR key-mask    :   11baae0dd132eb4d3968b41ffb278379",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   IV                  :   006e5cba50681de55c621599d462564a\n   IV'                 :   595b699bbd3bc0df26062093c1ad8f73\n   j = 0\n   IV' xor j           :   595b699bbd3bc0df26062093c1ad8f73\n   S(-1)               :   00000000000000000000000000000000\n   IV' xor S(-1) xor j :   595b699bbd3bc0df26062093c1ad8f73\n   S(0)                :   71ef82d70a172660240709c7fbb19d8e\n   plaintext           :   70736575646f72616e646f6d6e657373\n   ciphertext          :   019ce7a26e7854014a6366aa95d4eefd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "j = 1\nIV' xor j           :   595b699bbd3bc0df26062093c1ad8f72\nS(0)                :   71ef82d70a172660240709c7fbb19d8e\nIV' xor S(0) xor j  :   28b4eb4cb72ce6bf020129543a1c12fc\nS(1)                :   3abd640a60919fd43bd289a09649b5fc\nplaintext           :   20697320746865206e65787420626573\nciphertext          :   1ad4172a14f9faf455b7f1d4b62bd08f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "j = 2\nIV' xor j           :   595b699bbd3bc0df26062093c1ad8f71\nS(1)                :   3abd640a60919fd43bd289a09649b5fc\nIV' xor S(1) xor j  :   63e60d91ddaa5f0b1dd4a93357e43a8d\nS(2)                :   220c7a8715266565b09ecc8a2a62b11b\nplaintext           :   74207468696e67\nciphertext          :   562c0eef7c4802",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.2. AES-CM Test Vectors",
      "section_title": true,
      "ja": "B.2. AES-CMテストベクター"
    },
    {
      "indent": 4,
      "text": "Keystream segment length: 1044512 octets (65282 AES blocks)\nSession Key:      2B7E151628AED2A6ABF7158809CF4F3C\nRollover Counter: 00000000\nSequence Number:  0000\nSSRC:             00000000\nSession Salt:     F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000 (already shifted)\nOffset:           F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Counter Keystream",
      "ja": "Counter Keystream"
    },
    {
      "indent": 4,
      "text": "F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000   E03EAD0935C95E80E166B16DD92B4EB4\nF0F1F2F3F4F5F6F7F8F9FAFBFCFD0001   D23513162B02D0F72A43A2FE4A5F97AB\nF0F1F2F3F4F5F6F7F8F9FAFBFCFD0002   41E95B3BB0A2E8DD477901E4FCA894C0\n...                                ...\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF   EC8CDF7398607CB0F2D21675EA9EA1E4\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFF00   362B7C3C6773516318A077D7FC5073AE\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFF01   6A2CC3787889374FBEB4C81B17BA6C44",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nota Bene: this test case is contrived so that the latter part of the keystream segment coincides with the test case in Section F.5.1 of [CTR].",
      "ja": "注意：このテストケースは、キーストリームセグメントの後半が[CTR]のセクションF.5.1のテストケースと一致するように作られています。"
    },
    {
      "indent": 0,
      "text": "B.3. Key Derivation Test Vectors",
      "section_title": true,
      "ja": "B.3. 鍵導出テストベクター"
    },
    {
      "indent": 3,
      "text": "This section provides test data for the default key derivation function, which uses AES-128 in Counter Mode. In the following, we walk through the initial key derivation for the AES-128 Counter Mode cipher, which requires a 16 octet session encryption key and a 14 octet session salt, and an authentication function which requires a 94-octet session authentication key. These values are called the cipher key, the cipher salt, and the auth key in the following. Since this is the initial key derivation and the key derivation rate is equal to zero, the value of (index DIV key_derivation_rate) is zero (actually, a six-octet string of zeros). In the following, we shorten key_derivation_rate to kdr.",
      "ja": "このセクションでは、カウンターモードでAES-128を使用するデフォルトの鍵導出関数のテストデータを提供します。以下では、16オクテットのセッション暗号化鍵と14オクテットのセッションソルトを必要とするAES-128カウンターモード暗号、および94オクテットのセッション認証鍵を必要とする認証関数の初期鍵導出について順を追って説明します。これらの値は、以下で暗号鍵、暗号ソルト、認証鍵と呼ばれます。これは初期の鍵導出であり、鍵導出率がゼロであるため、（index DIV key_derivation_rate）の値はゼロです（実際には、6オクテットのゼロの文字列）。以下では、key_derivation_rateをkdrと短縮します。"
    },
    {
      "indent": 3,
      "text": "The inputs to the key derivation function are the 16 octet master key and the 14 octet master salt:",
      "ja": "鍵導出関数への入力は、16オクテットのマスター鍵と14オクテットのマスターソルトです。"
    },
    {
      "indent": 6,
      "text": "master key: E1F97A0D3E018BE0D64FA32C06DE4139 master salt: 0EC675AD498AFEEBB6960B3AABE6",
      "ja": "master key: E1F97A0D3E018BE0D64FA32C06DE4139\nmaster salt: 0EC675AD498AFEEBB6960B3AABE6"
    },
    {
      "indent": 3,
      "text": "We first show how the cipher key is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption key label 0x00 with (index DIV kdr), then padding on the right with two null octets (which implements the multiply-by-2^16 operation, see Section 4.3.3). The resulting value is then AES-CM- encrypted using the master key to get the cipher key.",
      "ja": "最初に、暗号鍵がどのように生成されるかを示します。AES-CMの入力ブロックは、マスターソルトと暗号化キーラベル0x00と（index DIV kdr）の連結を排他的論理和（XOR）し、右側を2つのヌルオクテットでパディング（これは2^16を乗算する操作を実装します。セクション4.3.3参照）することによって生成されます。結果の値は、マスターキーを使用してAES-CMで暗号化され、暗号鍵が生成されます。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr:                 000000000000\nlabel:                       00\nmaster salt:   0EC675AD498AFEEBB6960B3AABE6\n-----------------------------------------------\nxor:           0EC675AD498AFEEBB6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:        0EC675AD498AFEEBB6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "cipher key: C61E7A93744F39EE10734AFE3FF7A087 (AES-CM output)",
      "ja": "cipher key: C61E7A93744F39EE10734AFE3FF7A087 (AES-CM output)"
    },
    {
      "indent": 3,
      "text": "Next, we show how the cipher salt is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption salt label. That value is padded and encrypted as above.",
      "ja": "次に、暗号ソルトがどのように生成されるかを示します。AES-CMの入力ブロックは、マスターソルトと暗号化ソルトラベルの連結を排他的論理和（XOR）することによって生成されます。その値は上記のようにパディングされ、暗号化されます。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr: 000000000000 label: 02 master salt: 0EC675AD498AFEEBB6960B3AABE6",
      "ja": "index DIV kdr: 000000000000\nlabel: 02\nmaster salt: 0EC675AD498AFEEBB6960B3AABE6"
    },
    {
      "indent": 6,
      "text": "----------------------------------------------\nxor:           0EC675AD498AFEE9B6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:        0EC675AD498AFEE9B6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "30CBBC08863D8C85D49DB34A9AE17AC6 (AES-CM ouptut)",
      "ja": "30CBBC08863D8C85D49DB34A9AE17AC6 (AES-CM output)"
    },
    {
      "indent": 6,
      "text": "cipher salt: 30CBBC08863D8C85D49DB34A9AE1",
      "ja": "cipher salt: 30CBBC08863D8C85D49DB34A9AE1"
    },
    {
      "indent": 3,
      "text": "We now show how the auth key is generated. The input block for AES-CM is generated as above, but using the authentication key label.",
      "ja": "次に、認証鍵がどのように生成されるかを示します。AES-CMの入力ブロックは上記と同様に生成されますが、認証キーラベルを使用します。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr:                   000000000000\nlabel:                         01\nmaster salt:     0EC675AD498AFEEBB6960B3AABE6\n-----------------------------------------------\nxor:             0EC675AD498AFEEAB6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:          0EC675AD498AFEEAB6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Below, the auth key is shown on the left, while the corresponding AES input blocks are shown on the right.",
      "ja": "以下に、認証鍵を左に、対応するAES入力ブロックを右に示します。"
    },
    {
      "indent": 3,
      "text": "auth key                           AES input blocks\nCEBE321F6FF7716B6FD4AB49AF256A15   0EC675AD498AFEEAB6960B3AABE60000\n6D38BAA48F0A0ACF3C34E2359E6CDBCE   0EC675AD498AFEEAB6960B3AABE60001\nE049646C43D9327AD175578EF7227098   0EC675AD498AFEEAB6960B3AABE60002\n6371C10C9A369AC2F94A8C5FBCDDDC25   0EC675AD498AFEEAB6960B3AABE60003\n6D6E919A48B610EF17C2041E47403576   0EC675AD498AFEEAB6960B3AABE60004\n6B68642C59BBFC2F34DB60DBDFB2       0EC675AD498AFEEAB6960B3AABE60005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Questions and comments should be directed to the authors and avt@ietf.org:",
      "ja": "質問やコメントは、著者およびavt@ietf.orgまでお送りください。"
    },
    {
      "indent": 3,
      "text": "Mark Baugher Cisco Systems, Inc. 5510 SW Orchid Street Portland, OR 97219 USA",
      "ja": "Mark Baugher Cisco Systems, Inc. 5510 SW Orchid Street Portland, OR 97219 USA"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 408-853-4418\nEMail:  mbaugher@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Elisabetta Carrara Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Elisabetta Carrara Ericsson Research SE-16480 Stockholm Sweden"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 50877040\nEMail:  elisabetta.carrara@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David A. McGrew Cisco Systems, Inc. San Jose, CA 95134-1706 USA",
      "ja": "David A. McGrew Cisco Systems, Inc. San Jose, CA 95134-1706 USA"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 301-349-5815\nEMail:  mcgrew@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mats Naslund Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Mats Naslund Ericsson Research SE-16480 Stockholm Sweden"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 58533739\nEMail:  mats.naslund@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Karl Norrman Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Karl Norrman Ericsson Research SE-16480 Stockholm Sweden"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 4044502\nEMail:  karl.norrman@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78 and except as set forth therein, the authors retain all their rights.",
      "ja": "Copyright (C) The Internet Society (2004). この文書はBCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書および本書に含まれる情報は「現状のまま」で提供され、寄稿者、その代理またはスポンサーとなっている組織（もしあれば）、インターネットソサエティ、およびインターネット技術タスクフォースは、明示または黙示を問わず、本書の情報の使用がいかなる権利も侵害しないという保証、または商品性や特定の目的への適合性の黙示の保証を含むがこれらに限定されない、すべての保証を否認します。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書に記載されている技術の実装または使用に関連すると主張される可能性のある知的財産権またはその他の権利の有効性または範囲、あるいはそのような権利に基づくライセンスが利用可能であるか否かの範囲について、いかなる立場も取りません。また、IETFがそのような権利を特定するために独自の努力をしたことを表明するものでもありません。RFC文書の権利に関する手続きについての情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局になされたIPR開示のコピー、および利用可能になるライセンスの保証、または本仕様の実装者または利用者がそのような所有権を使用するための一般的なライセンスまたは許可を取得しようとした試みの結果は、http://www.ietf.org/iprのIETFオンラインIPRリポジトリから入手できます。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この標準を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権について、利害関係者からの情報提供を歓迎します。情報はIETF（ietf-ipr@ietf.org）までお寄せください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディタ機能への資金提供は、現在インターネットソサエティによって行われています。"
    }
  ]
}