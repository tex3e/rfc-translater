{
  "title": {
    "text": "RFC 9924 - Advanced Professional Video",
    "ja": "RFC 9924 - 高度なプロフェッショナルビデオ"
  },
  "number": 9924,
  "created_at": "2026-02-11 23:25:37.241143+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                            Y. Lim\nRequest for Comments: 9924                                       M. Park\nCategory: Informational                                      M. Budagavi\nISSN: 2070-1721                                                 R. Joshi\n                                                                 K. Choi\n                                                     Samsung Electronics\n                                                           February 2026",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Advanced Professional Video",
      "section_title": true,
      "ja": "高度なプロフェッショナルビデオ"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the bitstream format of Advanced Professional Video (APV) and its decoding process. APV is a professional video codec providing visually lossless compression mainly for recording and post production.",
      "ja": "このドキュメントでは、Advanced Professional Video (APV) のビットストリーム形式とそのデコード プロセスについて説明します。APV は、主に録画とポストプロダクション向けに視覚的にロスレス圧縮を提供するプロフェッショナルなビデオ コーデックです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書は Internet Standards Track 仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、他の RFC ストリームとは独立した、RFC シリーズへの貢献です。RFC 編集者は独自の裁量でこの文書を公開することを選択しており、実装または展開におけるこの文書の価値については何も述べていません。RFC 編集者によって出版が承認された文書は、どのレベルのインターネット標準の候補でもありません。RFC 7841 のセクション 2 を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9924.",
      "ja": "この文書の現在のステータス、正誤表、およびそれに対するフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc9924 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2026 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright (c) 2026 IETF Trust および文書の著者として特定された人物。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78 およびこの文書の発行日に有効な IETF 文書に関する IETF トラストの法的規定 (https://trustee.ietf.org/license-info) の対象となります。これらの文書には、この文書に関するお客様の権利と制限が記載されているため、注意深くお読みください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terms\n  2.1.  Terms and Definitions\n  2.2.  Abbreviated Terms\n3.  Conventions Used in This Document\n  3.1.  General\n  3.2.  Operators\n    3.2.1.  Arithmetic Operators\n    3.2.2.  Bitwise Operators\n  3.3.  Range Notation\n    3.3.1.  Order of Operations Precedence\n  3.4.  Variables, Syntax Elements, and Tables\n  3.5.  Processes\n4.  Formats and Processes Used in This Document\n  4.1.  Bitstream Formats\n  4.2.  Source, Decoded, and Output Frame Formats\n  4.3.  Partitioning of a Frame\n    4.3.1.  Partitioning of a Frame into Tiles\n    4.3.2.  Spatial or Component-Wise Partitioning\n  4.4.  Scanning Processes\n    4.4.1.  Zig-Zag Scan\n    4.4.2.  Inverse Scan\n5.  Syntax and Semantics\n  5.1.  Method of Specifying Syntax\n  5.2.  Syntax Functions and Descriptors\n    5.2.1.  byte_aligned()\n    5.2.2.  more_data_in_tile()\n    5.2.3.  next_bits(n)\n    5.2.4.  read_bits(n)\n    5.2.5.  Syntax Element Processing Functions\n  5.3.  List of Syntax and Semantics\n    5.3.1.  Access Unit\n    5.3.2.  Primitive Bitstream Unit\n    5.3.3.  Primitive Bitstream Unit Header\n    5.3.4.  Frame\n    5.3.5.  Frame Header\n    5.3.6.  Frame Information\n    5.3.7.  Quantization Matrix\n    5.3.8.  Tile Info\n    5.3.9.  Access Unit Information\n    5.3.10. Metadata\n    5.3.11. Filler\n    5.3.12. Tile\n    5.3.13. Tile Header\n    5.3.14. Tile Data\n    5.3.15. Macroblock Layer\n    5.3.16. AC Coefficient Coding\n    5.3.17. Byte Alignment\n6.  Decoding Process\n  6.1.  MB Decoding Process\n  6.2.  Block Reconstruction Process\n  6.3.  Scaling and Transformation Process\n    6.3.1.  Scaling Process for Transform Coefficients\n    6.3.2.  Process for Scaled Transform Coefficients\n7.  Parsing Process\n  7.1.  Process for Syntax Element Type h(v)\n    7.1.1.  Process for abs_dc_coeff_diff\n    7.1.2.  Process for coeff_zero_run\n    7.1.3.  Process for abs_ac_coeff_minus1\n    7.1.4.  Process for Variable-Length Codes\n  7.2.  Codeword Generation Process for h(v) (Informative)\n    7.2.1.  Process for abs_dc_coeff_diff\n    7.2.2.  Process for coeff_zero_run\n    7.2.3.  Process for abs_ac_coeff_minus1\n    7.2.4.  Process for Variable-Length Codes\n8.  Metadata Information\n  8.1.  Metadata Payload\n  8.2.  List of Metadata Syntax and Semantics\n    8.2.1.  Filler Metadata\n    8.2.2.  Recommendation ITU-T T.35 Metadata\n    8.2.3.  Mastering Display Color Volume Metadata\n    8.2.4.  Content Light-Level Information Metadata\n    8.2.5.  User-Defined Metadata\n    8.2.6.  Undefined Metadata\n9.  Profiles, Levels, and Bands\n  9.1.  Overview of Profiles, Levels, and Bands\n  9.2.  Requirements on Video Decoder Capability\n  9.3.  Profiles\n    9.3.1.  General\n    9.3.2.  422-10 Profile\n    9.3.3.  422-12 Profile\n    9.3.4.  444-10 Profile\n    9.3.5.  444-12 Profile\n    9.3.6.  4444-10 Profile\n    9.3.7.  4444-12 Profile\n    9.3.8.  400-10 Profile\n  9.4.  Levels and Bands\n    9.4.1.  General\n    9.4.2.  Limits of Levels and Bands\n10. Security Considerations\n11. IANA Considerations\n12. References\n  12.1.  Normative References\n  12.2.  Informative References\nAppendix A.  Raw Bitstream Format\nAppendix B.  APV Implementations\n  B.1.  OpenAPV Open Source Project\n  B.2.  Android Open Source Project\n  B.3.  FFmpeg Open Source Project\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines the bitstream format and decoding process for the Advanced Professional Video (APV) codec. The APV codec is a professional video codec that was developed in response to the need for professional-level, high-quality video recording and post production. The primary purpose of the APV codec is for use in professional video recording and editing workflows for various types of content. This specification is neither the product of the IETF nor a consensus view of the community.",
      "ja": "この文書では、Advanced Professional Video (APV) コーデックのビットストリーム形式とデコード プロセスを定義します。APV コーデックは、プロフェッショナル レベルの高品質ビデオ録画とポスト プロダクションのニーズに応えて開発されたプロフェッショナル ビデオ コーデックです。APV コーデックの主な目的は、さまざまな種類のコンテンツのプロのビデオ録画および編集ワークフローで使用することです。この仕様は、IETF の成果物でも、コミュニティの総意でもありません。"
    },
    {
      "indent": 3,
      "text": "The APV codec supports the following features:",
      "ja": "APV コーデックは次の機能をサポートしています。"
    },
    {
      "indent": 6,
      "text": "* Perceptually lossless video quality that is close to the original, uncompressed quality;",
      "ja": "* オリジナルの非圧縮品質に近い、知覚的にロスレスなビデオ品質。"
    },
    {
      "indent": 6,
      "text": "* Low complexity and high throughput intra frame only coding without inter frame coding;",
      "ja": "* フレーム間コーディングを行わない、フレーム内のみのコーディングで複雑さが低く、スループットが高い。"
    },
    {
      "indent": 6,
      "text": "* Intra frame coding without prediction between pixel values but with prediction between transformed values for low delay encoding;",
      "ja": "* 低遅延符号化の場合、ピクセル値間の予測を行わず、変換値間の予測を行うフレーム内符号化。"
    },
    {
      "indent": 6,
      "text": "* High bit rates of up to a few Gbps for 2K, 4K, and 8K resolution content, enabled by a lightweight entropy coding scheme;",
      "ja": "* 軽量エントロピーコーディングスキームによって実現される、2K、4K、および 8K 解像度のコンテンツで最大数 Gbps の高ビットレート。"
    },
    {
      "indent": 6,
      "text": "* Frame tiling for immersive content and for enabling parallel encoding and decoding;",
      "ja": "* 没入型コンテンツのためのフレーム タイル化、および並列エンコードとデコードを可能にする。"
    },
    {
      "indent": 6,
      "text": "* Various chroma sampling formats from 4:0:0 to 4:4:4:4, and bit depths from 10 to 16 (Note: Only the profiles supporting 10 bits and 12 bits are currently defined);",
      "ja": "* 4:0:0 ～ 4:4:4:4 のさまざまなクロマ サンプリング フォーマット、および 10 ～ 16 のビット深度 (注: 現在、10 ビットと 12 ビットをサポートするプロファイルのみが定義されています)。"
    },
    {
      "indent": 6,
      "text": "* The ability to decode and re-encode multiple times without severe visual quality degradation; and",
      "ja": "* 深刻な視覚的品質の低下を生じることなく、複数回デコードおよび再エンコードできる機能。そして"
    },
    {
      "indent": 6,
      "text": "* Various metadata including HDR10/10+ and user-defined formats.",
      "ja": "* HDR10/10+ やユーザー定義フォーマットを含むさまざまなメタデータ。"
    },
    {
      "indent": 0,
      "text": "2. Terms",
      "section_title": true,
      "ja": "2. 条項"
    },
    {
      "indent": 0,
      "text": "2.1. Terms and Definitions",
      "section_title": true,
      "ja": "2.1. 用語と定義"
    },
    {
      "indent": 3,
      "text": "access unit (AU):",
      "ja": "アクセスユニット(AU):"
    },
    {
      "indent": 12,
      "text": "a collection of primitive bitstream units (PBU) including various types of frames, metadata, filler, and access unit information, associated with a specific time",
      "ja": "特定の時間に関連付けられた、さまざまなタイプのフレーム、メタデータ、フィラー、アクセス ユニット情報を含むプリミティブ ビットストリーム ユニット (PBU) のコレクション"
    },
    {
      "indent": 3,
      "text": "band:",
      "ja": "バンド："
    },
    {
      "indent": 12,
      "text": "a defined set of constraints on the value of the maximum coded data rate of each level",
      "ja": "各レベルの最大符号化データ レートの値に対する定義済みの一連の制約"
    },
    {
      "indent": 3,
      "text": "block:",
      "ja": "ブロック："
    },
    {
      "indent": 12,
      "text": "MxN (M-column by N-row) array of samples, or an MxN array of transform coefficients",
      "ja": "サンプルの MxN (M 列 x N 行) 配列、または変換係数の MxN 配列"
    },
    {
      "indent": 3,
      "text": "byte-aligned:",
      "ja": "バイトアライン:"
    },
    {
      "indent": 12,
      "text": "a position in a bitstream that is an integer multiple of 8 bits from the position of the first bit in the bitstream",
      "ja": "ビットストリーム内の最初のビットの位置から 8 ビットの整数倍であるビットストリーム内の位置"
    },
    {
      "indent": 3,
      "text": "chroma:",
      "ja": "彩度："
    },
    {
      "indent": 12,
      "text": "a sample array or single sample representing one of the two color difference signals related to the primary colors, represented by the symbols Cb and Cr in 4:2:2 or 4:4:4 color format",
      "ja": "原色に関連する 2 つの色差信号の 1 つを表すサンプル配列または単一サンプル。4:2:2 または 4:4:4 カラー形式の記号 Cb および Cr で表されます。"
    },
    {
      "indent": 3,
      "text": "coded frame:",
      "ja": "コード化されたフレーム:"
    },
    {
      "indent": 12,
      "text": "a coded representation of a frame containing all macroblocks of the frame",
      "ja": "フレームのすべてのマクロブロックを含むフレームのコード化された表現"
    },
    {
      "indent": 3,
      "text": "coded representation:",
      "ja": "コード化された表現:"
    },
    {
      "indent": 12,
      "text": "a data element as represented in its coded form",
      "ja": "コード化された形式で表されるデータ要素"
    },
    {
      "indent": 3,
      "text": "component:",
      "ja": "成分："
    },
    {
      "indent": 12,
      "text": "an array or a single sample from one of the three arrays (luma and two chroma) that compose a frame in 4:2:2, or 4:4:4 color format, or an array or a single sample from an array that compose a frame in 4:0:0 color format, or an array or a single sample from one of the four arrays that compose a frame in 4:4:4:4 color format.",
      "ja": "4:2:2 または 4:4:4 カラー フォーマットでフレームを構成する 3 つの配列 (ルマと 2 つのクロマ) の 1 つからの配列または単一サンプル、4:0:0 カラー フォーマットでフレームを構成する配列または配列からの 1 つのサンプル、または 4:4:4:4 カラー フォーマットでフレームを構成する 4 つの配列の 1 つからの配列または 1 つのサンプル。"
    },
    {
      "indent": 3,
      "text": "decoded frame:",
      "ja": "デコードされたフレーム:"
    },
    {
      "indent": 12,
      "text": "a frame derived by decoding a coded frame",
      "ja": "コード化されたフレームをデコードすることによって得られるフレーム"
    },
    {
      "indent": 3,
      "text": "decoder:",
      "ja": "デコーダ："
    },
    {
      "indent": 12,
      "text": "an embodiment of a decoding process",
      "ja": "復号化プロセスの実施形態"
    },
    {
      "indent": 3,
      "text": "decoding process:",
      "ja": "デコードプロセス:"
    },
    {
      "indent": 12,
      "text": "a process specified that reads a bitstream and derives decoded frames from it",
      "ja": "ビットストリームを読み取り、そこからデコードされたフレームを取得する指定されたプロセス"
    },
    {
      "indent": 3,
      "text": "encoder:",
      "ja": "エンコーダ:"
    },
    {
      "indent": 12,
      "text": "an embodiment of an encoding process",
      "ja": "符号化プロセスの実施形態"
    },
    {
      "indent": 3,
      "text": "encoding process:",
      "ja": "エンコードプロセス:"
    },
    {
      "indent": 12,
      "text": "a process that produces a bitstream conforming to this document",
      "ja": "この文書に準拠したビットストリームを生成するプロセス"
    },
    {
      "indent": 3,
      "text": "flag:",
      "ja": "フラグ："
    },
    {
      "indent": 12,
      "text": "a variable or single-bit syntax element that can take one of the two possible values: 0 and 1",
      "ja": "2 つの値 (0 と 1) のいずれかを取り得る変数または単一ビットの構文要素"
    },
    {
      "indent": 3,
      "text": "frame:",
      "ja": "フレーム："
    },
    {
      "indent": 12,
      "text": "an array of luma samples and two corresponding arrays of chroma samples in 4:2:2 and 4:4:4 color format, or an array of samples in 4:0:0 color format, or four arrays of samples in 4:4:4:4 color format",
      "ja": "4:2:2 および 4:4:4 カラー フォーマットのルマ サンプルの配列と 2 つの対応するクロマ サンプルの配列、または 4:0:0 カラー フォーマットのサンプルの配列、または 4:4:4:4 カラー フォーマットのサンプルの 4 つの配列"
    },
    {
      "indent": 3,
      "text": "level:",
      "ja": "レベル："
    },
    {
      "indent": 12,
      "text": "a defined set of constraints on the values that are taken by the syntax elements and variables of this document, or the value of a transform coefficient prior to scaling",
      "ja": "このドキュメントの構文要素および変数によって取得される値、またはスケーリング前の変換係数の値に対して定義された一連の制約。"
    },
    {
      "indent": 3,
      "text": "luma:",
      "ja": "ルミナ:"
    },
    {
      "indent": 12,
      "text": "a sample array or single sample representing the monochrome signal related to the primary colors, represented by the symbol or subscript Y or L",
      "ja": "原色に関連するモノクロ信号を表すサンプル配列または単一サンプル。記号または添え字 Y または L で表されます。"
    },
    {
      "indent": 3,
      "text": "macroblock (MB):",
      "ja": "マクロブロック (MB):"
    },
    {
      "indent": 12,
      "text": "a square block of luma samples and two corresponding blocks of chroma samples of a frame in 4:2:2 or 4:4:4 color format, or a square block of samples of a frame in 4:0:0 color format, or four square blocks of samples of a frame in 4:4:4:4 color format",
      "ja": "4:2:2 または 4:4:4 カラー フォーマットのフレームのルマ サンプルの正方形ブロックとクロマ サンプルの 2 つの対応するブロック、または 4:0:0 カラー フォーマットのフレームのサンプルの正方形ブロック、または 4:4:4:4 カラー フォーマットのフレームのサンプルの 4 つの正方形ブロック"
    },
    {
      "indent": 3,
      "text": "metadata:",
      "ja": "メタデータ:"
    },
    {
      "indent": 12,
      "text": "data describing various characteristics related to a bitstream without directly affecting the decoding process of it.",
      "ja": "ビットストリームのデコードプロセスに直接影響を与えることなく、ビットストリームに関連するさまざまな特性を記述するデータ。"
    },
    {
      "indent": 3,
      "text": "partitioning:",
      "ja": "パーティショニング:"
    },
    {
      "indent": 12,
      "text": "a division of a set into subsets such that each element of the set is in exactly one of the subsets",
      "ja": "セットの各要素がサブセットの 1 つに正確に含まれるように、セットをサブセットに分割すること"
    },
    {
      "indent": 3,
      "text": "prediction:",
      "ja": "予測："
    },
    {
      "indent": 12,
      "text": "an embodiment of the prediction process",
      "ja": "予測プロセスの一実施形態"
    },
    {
      "indent": 3,
      "text": "prediction process:",
      "ja": "予測プロセス:"
    },
    {
      "indent": 12,
      "text": "use of a predictor to provide an estimate of the data element currently being decoded",
      "ja": "現在デコードされているデータ要素の推定値を提供するための予測子の使用"
    },
    {
      "indent": 3,
      "text": "predictor:",
      "ja": "予測子:"
    },
    {
      "indent": 12,
      "text": "a combination of specified values or previously decoded data elements used in the decoding process of subsequent data elements",
      "ja": "後続のデータ要素の復号化プロセスで使用される、指定された値または以前に復号化されたデータ要素の組み合わせ"
    },
    {
      "indent": 3,
      "text": "primitive bitstream unit (PBU):",
      "ja": "プリミティブ ビットストリーム ユニット (PBU):"
    },
    {
      "indent": 12,
      "text": "a data structure to construct an access unit with frame and metadata",
      "ja": "フレームとメタデータを含むアクセスユニットを構築するデータ構造"
    },
    {
      "indent": 3,
      "text": "profile:",
      "ja": "プロフィール："
    },
    {
      "indent": 12,
      "text": "a specified subset of the syntax of this document",
      "ja": "このドキュメントの構文の指定されたサブセット"
    },
    {
      "indent": 3,
      "text": "quantization parameter (QP):",
      "ja": "量子化パラメータ (QP):"
    },
    {
      "indent": 12,
      "text": "a variable used by the decoding process for the scaling value of transform coefficients",
      "ja": "変換係数のスケーリング値の復号化プロセスで使用される変数"
    },
    {
      "indent": 3,
      "text": "raster scan:",
      "ja": "ラスタースキャン:"
    },
    {
      "indent": 12,
      "text": "a mapping of a rectangular two-dimensional pattern to a one-dimensional pattern such that the first entries in the one-dimensional pattern are from the top row of the two-dimensional pattern scanned from left to right, followed by the second, third, etc., rows of the pattern each scanned from left to right",
      "ja": "長方形の 2 次元パターンから 1 次元パターンへのマッピング。1 次元パターンの最初のエントリは、2 次元パターンの一番上の行から左から右にスキャンされ、続いてパターンの 2 行目、3 行目など、それぞれ左から右にスキャンされます。"
    },
    {
      "indent": 3,
      "text": "raw bitstream:",
      "ja": "生のビットストリーム:"
    },
    {
      "indent": 12,
      "text": "an encapsulation of a sequence of access units where a field indicating the size of an access unit precedes each access unit as defined in Appendix A",
      "ja": "付録 A で定義されているように、アクセス ユニットのサイズを示すフィールドが各アクセス ユニットの前に置かれる、アクセス ユニットのシーケンスのカプセル化。"
    },
    {
      "indent": 3,
      "text": "source:",
      "ja": "ソース："
    },
    {
      "indent": 12,
      "text": "a term used to describe the video material or some of its attributes before the encoding process",
      "ja": "エンコードプロセス前のビデオ素材またはその属性の一部を説明するために使用される用語"
    },
    {
      "indent": 3,
      "text": "syntax element:",
      "ja": "構文要素:"
    },
    {
      "indent": 12,
      "text": "an element of data represented in the bitstream",
      "ja": "ビットストリームで表現されるデータの要素"
    },
    {
      "indent": 3,
      "text": "syntax structure:",
      "ja": "構文構造:"
    },
    {
      "indent": 12,
      "text": "zero or more syntax elements present together in a bitstream in a specified order",
      "ja": "ビットストリーム内に指定された順序で一緒に存在する 0 個以上の構文要素"
    },
    {
      "indent": 3,
      "text": "tile:",
      "ja": "タイル："
    },
    {
      "indent": 12,
      "text": "a rectangular region of MBs within a particular tile column and a particular tile row in a frame",
      "ja": "フレーム内の特定のタイル列および特定のタイル行内の MB の長方形領域"
    },
    {
      "indent": 3,
      "text": "tile column:",
      "ja": "タイル列:"
    },
    {
      "indent": 12,
      "text": "a rectangular region of MBs having a height equal to the height of the frame and width specified by syntax elements in the frame header",
      "ja": "フレームの高さと同じ高さとフレームヘッダーの構文要素で指定された幅を持つ MB の長方形領域"
    },
    {
      "indent": 3,
      "text": "tile row:",
      "ja": "タイル行:"
    },
    {
      "indent": 12,
      "text": "a rectangular region of MBs having a height specified by syntax elements in the frame header and a width equal to the width of the frame",
      "ja": "フレームヘッダーの構文要素で指定された高さとフレームの幅に等しい幅を持つ MB の長方形領域"
    },
    {
      "indent": 3,
      "text": "tile scan:",
      "ja": "タイルスキャン:"
    },
    {
      "indent": 12,
      "text": "a specific sequential ordering of MBs partitioning a frame in which the MBs are ordered consecutively in MB raster scan in a tile and the tiles in a frame are ordered consecutively in a raster scan of the tiles of the frame",
      "ja": "フレームを分割する MB の特定の連続順序付け。MB はタイル内の MB ラスター スキャンで連続的に順序付けされ、フレーム内のタイルはフレームのタイルのラスター スキャンで連続的に順序付けされます。"
    },
    {
      "indent": 3,
      "text": "transform coefficient:",
      "ja": "変換係数:"
    },
    {
      "indent": 12,
      "text": "a scalar quantity, considered to be in a frequency domain, that is associated with a particular one-dimensional or two-dimensional index",
      "ja": "特定の 1 次元または 2 次元のインデックスに関連付けられた、周波数領域にあると考えられるスカラー量"
    },
    {
      "indent": 0,
      "text": "2.2. Abbreviated Terms",
      "section_title": true,
      "ja": "2.2. 略語"
    },
    {
      "indent": 3,
      "text": "LSB:",
      "ja": "LSB:"
    },
    {
      "indent": 12,
      "text": "least significant bit",
      "ja": "最下位ビット"
    },
    {
      "indent": 3,
      "text": "MSB:",
      "ja": "MSB:"
    },
    {
      "indent": 12,
      "text": "most significant bit",
      "ja": "最上位ビット"
    },
    {
      "indent": 3,
      "text": "RGB:",
      "ja": "RGB:"
    },
    {
      "indent": 12,
      "text": "Red, Green and Blue",
      "ja": "赤、緑、青"
    },
    {
      "indent": 0,
      "text": "3. Conventions Used in This Document",
      "section_title": true,
      "ja": "3. この文書で使用される表記規則"
    },
    {
      "indent": 0,
      "text": "3.1. General",
      "section_title": true,
      "ja": "3.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Operators",
      "section_title": true,
      "ja": "3.2. オペレーター"
    },
    {
      "indent": 3,
      "text": "The operators and the order of precedence are the same as used in the C programming language [ISO9899]. However, there are some exceptions for the operators described in the Section 3.2.1 and Section 3.2.2, which follows widely used industry practices for video codecs.",
      "ja": "演算子と優先順位は、C プログラミング言語 [ISO9899] で使用されるものと同じです。ただし、セクション 3.2.1 およびセクション 3.2.2 で説明されている演算子にはいくつかの例外があり、ビデオ コーデックに対して広く使用されている業界の慣例に従っています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Arithmetic Operators",
      "section_title": true,
      "ja": "3.2.1. 算術演算子"
    },
    {
      "indent": 3,
      "text": "//",
      "ja": "//"
    },
    {
      "indent": 12,
      "text": "an integer division with rounding of the result toward zero. For example, 7//4 and -7//-4 are rounded to 1 and -7//4 and 7//-4 are rounded to -1",
      "ja": "結果をゼロに向かって四捨五入した整数の除算。たとえば、7//4 と -7//-4 は 1 に丸められ、-7//4 と 7//-4 は -1 に丸められます。"
    },
    {
      "indent": 3,
      "text": "/ or div(x,y)",
      "ja": "/ または div(x,y)"
    },
    {
      "indent": 12,
      "text": "a division in mathematical equations where no truncation or rounding is intended",
      "ja": "切り捨てや四捨五入が意図されていない数式の割り算"
    },
    {
      "indent": 3,
      "text": "min(x,y)",
      "ja": "min(x,y)"
    },
    {
      "indent": 12,
      "text": "the minimum value of the values x and y",
      "ja": "値 x と y の最小値"
    },
    {
      "indent": 3,
      "text": "max(x,y)",
      "ja": "最大(x,y)"
    },
    {
      "indent": 12,
      "text": "the maximum value of the values x and y",
      "ja": "値 x と y の最大値"
    },
    {
      "indent": 3,
      "text": "ceil(x)",
      "ja": "天井(x)"
    },
    {
      "indent": 12,
      "text": "the smallest integer value that is larger than or equal to x",
      "ja": "x 以上の最小の整数値"
    },
    {
      "indent": 3,
      "text": "clip(x,y,z)",
      "ja": "クリップ(x,y,z)"
    },
    {
      "indent": 12,
      "text": "clip(x,y,z)=max(x,min(z,y))",
      "ja": "クリップ(x,y,z)=最大(x,最小(z,y))"
    },
    {
      "indent": 3,
      "text": "sum (i=x, y, f(i))",
      "ja": "合計 (i=x, y, f(i))"
    },
    {
      "indent": 12,
      "text": "a summation of f(i) with i taking all integer values from x up to and including y",
      "ja": "i が x から y までのすべての整数値を取る f(i) の合計"
    },
    {
      "indent": 3,
      "text": "log2(x)",
      "ja": "log2(x)"
    },
    {
      "indent": 12,
      "text": "the base-2 logarithm of x",
      "ja": "x の底 2 の対数"
    },
    {
      "indent": 0,
      "text": "3.2.2. Bitwise Operators",
      "section_title": true,
      "ja": "3.2.2. ビット演算子"
    },
    {
      "indent": 3,
      "text": "& (bitwise \"and\")",
      "ja": "& (ビット単位の「and」)"
    },
    {
      "indent": 12,
      "text": "When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on arguments with unequal bit depths, the bit depths are equalized by adding zeros in significant positions to the argument with lower bit depth.",
      "ja": "整数引数を操作する場合、整数値の 2 の補数表現を操作します。ビット深度が等しくない引数を操作する場合、ビット深度が低い引数の有効な位置にゼロを追加することでビット深度が等しくなります。"
    },
    {
      "indent": 3,
      "text": "| (bitwise \"or\")",
      "ja": "|(ビット単位の「または」)"
    },
    {
      "indent": 12,
      "text": "When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on arguments with unequal bit depths, the bit depths are equalized by adding zeros in significant positions to the argument with lower bit depth.",
      "ja": "整数引数を操作する場合、整数値の 2 の補数表現を操作します。ビット深度が等しくない引数を操作する場合、ビット深度が低い引数の有効な位置にゼロを追加することでビット深度が等しくなります。"
    },
    {
      "indent": 3,
      "text": "x >> y",
      "ja": "x >> y"
    },
    {
      "indent": 12,
      "text": "arithmetic right shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the most significant bits (MSBs) as a result of the right shift have a value equal to the MSB of x prior to the shift operation.",
      "ja": "x の 2 の補数整数表現を 2 進数 y で算術的に右シフトします。この関数は、y の非負の整数値に対してのみ定義されます。右シフトの結果として最上位ビット (MSB) にシフトされたビットは、シフト操作前の x の MSB に等しい値を持ちます。"
    },
    {
      "indent": 3,
      "text": "x << y",
      "ja": "x << y"
    },
    {
      "indent": 12,
      "text": "arithmetic left shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the least significant bits (LSBs) as a result of the left shift have a value equal to 0.",
      "ja": "x の 2 の補数整数表現を 2 進数 y で算術左シフトします。この関数は、y の非負の整数値に対してのみ定義されます。左シフトの結果として最下位ビット (LSB) にシフトされたビットの値は 0 になります。"
    },
    {
      "indent": 0,
      "text": "3.3. Range Notation",
      "section_title": true,
      "ja": "3.3. 範囲表記"
    },
    {
      "indent": 3,
      "text": "x = y..z",
      "ja": "x = y..z"
    },
    {
      "indent": 12,
      "text": "x takes on integer values starting from y to z, inclusive, with x, y, and z being integer numbers and z being greater than y.",
      "ja": "x は y から z までの整数値をとり、x、y、z は整数であり、z は y より大きくなります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Order of Operations Precedence",
      "section_title": true,
      "ja": "3.3.1. 操作の優先順位"
    },
    {
      "indent": 3,
      "text": "When order of precedence is not indicated explicitly by use of parentheses, operations are evaluated in the following order.",
      "ja": "括弧を使用して優先順位が明示的に示されていない場合、演算は次の順序で評価されます。"
    },
    {
      "indent": 6,
      "text": "* Operations of a higher precedence are evaluated before any operation of a lower precedence. Table 1 specifies the precedence of operations from highest to lowest; operations closer to the top of the table indicate a higher precedence.",
      "ja": "* 優先順位の高い操作は、優先順位の低い操作よりも前に評価されます。表 1 は、操作の優先順位を最高から最低まで示しています。テーブルの先頭に近い操作ほど優先順位が高いことを示します。"
    },
    {
      "indent": 6,
      "text": "* Operations of the same precedence are evaluated sequentially from left to right.",
      "ja": "* 同じ優先順位の操作は、左から右に順番に評価されます。"
    },
    {
      "indent": 16,
      "text": "+=========================================+\n| operations (with operands x, y, and z)  |\n+=========================================+\n| \"x++\", \"x--\"                            |\n+-----------------------------------------+\n| \"!x\", \"-x\" (as a unary prefix operator) |\n+-----------------------------------------+\n| x^y (power)                             |\n+-----------------------------------------+\n| \"x * y\", \"x / y\", \"x // y\", \"x % y\"     |\n+-----------------------------------------+\n| \"x + y\", \"x - y\", \"sum (i=x, y, f(i))\"  |\n+-----------------------------------------+\n| \"x << y\", \"x >> y\"                      |\n+-----------------------------------------+\n| \"x < y\", \"x <= y\", \"x > y\", \"x >= y\"    |\n+-----------------------------------------+\n| \"x == y\", \"x != y\"                      |\n+-----------------------------------------+\n| \"x & y\"                                 |\n+-----------------------------------------+\n| \"x | y\"                                 |\n+-----------------------------------------+\n| \"x && y\"                                |\n+-----------------------------------------+\n| \"x || y\"                                |\n+-----------------------------------------+\n| \"x ? y : z\"                             |\n+-----------------------------------------+\n| \"x..y\"                                  |\n+-----------------------------------------+\n| \"x = y\", \"x += y\", \"x -= y\"             |\n+-----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": " Table 1: Operation precedence from highest (top of the table) to lowest (bottom of the table)",
      "ja": "表 1: 操作の優先順位 (表の一番上) から最も低いもの (表の一番下)"
    },
    {
      "indent": 0,
      "text": "3.4. Variables, Syntax Elements, and Tables",
      "section_title": true,
      "ja": "3.4. 変数、構文要素、およびテーブル"
    },
    {
      "indent": 3,
      "text": "Each syntax element is described by its name in all lowercase letters and its type is provided next to the syntax code in each row. Each syntax element and multi-byte integers are written in big endian format. The decoding process behaves according to the value of the syntax element and to the values of previously decoded syntax elements.",
      "ja": "各構文要素はすべて小文字の名前で説明され、その型は各行の構文コードの横に示されています。各構文要素とマルチバイト整数は、ビッグ エンディアン形式で書き込まれます。デコード プロセスは、構文要素の値と、以前にデコードされた構文要素の値に従って動作します。"
    },
    {
      "indent": 3,
      "text": "In some cases, the syntax tables may use the values of other variables derived from syntax elements values. Such variables appear in the syntax tables or text, named by a mixture of lower case and uppercase letters and without any underscore characters. Variables with names starting with an uppercase letter are derived for the decoding of the current syntax structure and all dependent syntax structures. Variables with names starting with an uppercase letter may be used in the decoding process for later syntax structures without mentioning the originating syntax structure of the variable. Variables with names starting with a lowercase letter are only used within the section in which they are derived.",
      "ja": "場合によっては、構文テーブルは、構文要素の値から導出された他の変数の値を使用することがあります。このような変数は、構文テーブルまたはテキストに表示され、小文字と大文字を組み合わせて、アンダースコア文字を含まない名前が付けられます。大文字で始まる名前を持つ変数は、現在の構文構造とすべての依存構文構造のデコード用に導出されます。大文字で始まる名前を持つ変数は、変数の元の構文構造について言及することなく、後の構文構造のデコード プロセスで使用できます。小文字で始まる名前の変数は、その変数が導出されるセクション内でのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "Functions that specify properties of the current position in the bitstream are referred to as syntax functions. These functions are specified in Section 5.2 and assume the existence of a bitstream pointer with an indication of the position of the next bit to be read by the decoding process from the bitstream.",
      "ja": "ビットストリーム内の現在位置のプロパティを指定する関数は、構文関数と呼ばれます。これらの関数はセクション 5.2 で指定されており、デコード プロセスによってビットストリームから読み取られる次のビットの位置を示すビットストリーム ポインターの存在を前提としています。"
    },
    {
      "indent": 3,
      "text": "A one-dimensional array is referred to as a list. A two-dimensional array is referred to as a matrix. Arrays can either be syntax elements or variables. Square brackets are used for the indexing of arrays. In reference to a visual depiction of a matrix, the first square bracket is used as a column (horizontal) index and the second square bracket is used as a row (vertical) index.",
      "ja": "1 次元配列はリストと呼ばれます。2 次元配列は行列と呼ばれます。配列は構文要素または変数のいずれかになります。角括弧は配列のインデックス付けに使用されます。行列の視覚的表現を参照すると、最初の角括弧は列 (水平) インデックスとして使用され、2 番目の角括弧は行 (垂直) インデックスとして使用されます。"
    },
    {
      "indent": 3,
      "text": "A specification of values of the entries in rows and columns of an array may be denoted by {{...}{...}}, where each inner pair of brackets specifies the values of the elements within a row in increasing column order and the rows are ordered in increasing row order. Thus, setting a matrix s equal to {{1 6}{4 9}} specifies that s[0][0] is set equal to 1, s[1][0] is set equal to 6, s[0][1] is set equal to 4, and s[1][1] is set equal to 9.",
      "ja": "配列の行と列のエントリの値の指定は、{{...}{...}} で表すことができます。ここで、括弧の内側の各ペアは、行内の要素の値を列の昇順で指定し、行は行の昇順に並べられます。したがって、行列 s を {{1 6}{4 9}} に設定することは、s[0][0] が 1 に設定され、s[1][0] が 6 に設定され、s[0][1] が 4 に設定され、s[1][1] が 9 に設定されることを指定します。"
    },
    {
      "indent": 3,
      "text": "Binary notation is indicated by enclosing the string of bit values in single quote marks. For example, '0b01000001' represents an eight-bit string having only its second and its last bits (counted from the most to the least significant bit) equal to 1.",
      "ja": "バイナリ表記は、ビット値の文字列を一重引用符で囲むことによって示されます。たとえば、「0b01000001」は、2 番目と最後のビット (最上位ビットから最下位ビットまで数えて) のみが 1 に等しい 8 ビット文字列を表します。"
    },
    {
      "indent": 3,
      "text": "Hexadecimal notation, indicated by prefixing the hexadecimal number by \"0x\", may be used instead of binary notation when the number of bits is an integer multiple of 4. For example, 0x41 represents an eight-bit string having only its second and its last bits (counted from the most to the least significant bit) equal to 1.",
      "ja": "ビット数が 4 の整数倍の場合、16 進数の前に「0x」を付けることで示される 16 進数表記が、2 進数表記の代わりに使用されることがあります。たとえば、0x41 は、2 番目と最後のビット (最上位ビットから最下位ビットまで数えて) のみが 1 に等しい 8 ビット文字列を表します。"
    },
    {
      "indent": 3,
      "text": "A value equal to 0 represents a FALSE condition in a test statement. The value TRUE is represented by any value different from zero.",
      "ja": "0 に等しい値は、テスト ステートメント内の FALSE 条件を表します。値 TRUE は、ゼロ以外の任意の値で表されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Processes",
      "section_title": true,
      "ja": "3.5. プロセス"
    },
    {
      "indent": 3,
      "text": "Processes are used to describe the decoding of syntax elements. A process has a separate specification and invoking. When invoking a process, the assignment of variables is specified as follows:",
      "ja": "プロセスは、構文要素のデコードを記述するために使用されます。プロセスには個別の仕様と呼び出しがあります。プロセスを呼び出すとき、変数の割り当ては次のように指定されます。"
    },
    {
      "indent": 6,
      "text": "* If the variables at the invoking and the process specification do not have the same name, the variables are explicitly assigned to lower case input or output variables of the process specification.",
      "ja": "* 呼び出し時の変数とプロセス仕様の名前が同じでない場合、変数はプロセス仕様の小文字の入力変数または出力変数に明示的に割り当てられます。"
    },
    {
      "indent": 6,
      "text": "* Otherwise (the variables at the invoking and the process specification have the same name), the assignment is implied.",
      "ja": "* それ以外の場合 (呼び出し時の変数とプロセス仕様の名前が同じである場合)、割り当ては暗黙的に行われます。"
    },
    {
      "indent": 3,
      "text": "In the specification of a process, a specific coding block is referred to by the variable name having a value equal to the address of the specific coding block.",
      "ja": "プロセスの仕様において、特定のコーディングブロックは、そのアドレスに等しい値を持つ変数名によって参照される。"
    },
    {
      "indent": 0,
      "text": "4. Formats and Processes Used in This Document",
      "section_title": true,
      "ja": "4. この文書で使用されるフォーマットとプロセス"
    },
    {
      "indent": 0,
      "text": "4.1. Bitstream Formats",
      "section_title": true,
      "ja": "4.1. ビットストリームフォーマット"
    },
    {
      "indent": 3,
      "text": "This section specifies the bitstream format of the Advanced Professional Video (APV) codec.",
      "ja": "このセクションでは、Advanced Professional Video (APV) コーデックのビットストリーム形式を指定します。"
    },
    {
      "indent": 3,
      "text": "A raw bitstream format consists of a sequence of AUs where the field indicating the size of access units precedes each of them. The raw bitstream format is specified in Appendix A.",
      "ja": "生のビットストリーム形式は、アクセス ユニットのサイズを示すフィールドが各 AU の前にある一連の AU で構成されます。生のビットストリーム形式は付録 A で指定されています。"
    },
    {
      "indent": 0,
      "text": "4.2. Source, Decoded, and Output Frame Formats",
      "section_title": true,
      "ja": "4.2. ソース、デコード、および出力フレーム形式"
    },
    {
      "indent": 3,
      "text": "This section specifies the relationship between the source and decoded frames.",
      "ja": "このセクションでは、ソース フレームとデコードされたフレームの間の関係を指定します。"
    },
    {
      "indent": 3,
      "text": "The video source that is represented by the bitstream is a sequence of frames.",
      "ja": "ビットストリームによって表されるビデオ ソースは、一連のフレームです。"
    },
    {
      "indent": 3,
      "text": "Source and decoded frames are each comprised of one or more sample arrays:",
      "ja": "ソース フレームとデコードされたフレームは、それぞれ 1 つ以上のサンプル配列で構成されます。"
    },
    {
      "indent": 6,
      "text": "* Monochrome (for example, Luma only)",
      "ja": "* モノクロ (たとえば、Luma のみ)"
    },
    {
      "indent": 6,
      "text": "* Luma and two chroma (for example, YCbCr or YCgCo as specified in [H273]).",
      "ja": "* 輝度と 2 つの彩度 (たとえば、[H273] で指定されている YCbCr または YCgCo)。"
    },
    {
      "indent": 6,
      "text": "* Green, blue, and red (GBR, also known as RGB).",
      "ja": "* 緑、青、赤 (GBR、RGB とも呼ばれる)。"
    },
    {
      "indent": 6,
      "text": "* Arrays representing other unspecified tri-stimulus color samplings (for example, YZX, also known as XYZ as specified in [CIE15]).",
      "ja": "* 他の未指定の 3 刺激カラー サンプリングを表す配列 (たとえば、[CIE15] で指定されている XYZ とも呼ばれる YZX)。"
    },
    {
      "indent": 6,
      "text": "* Arrays representing other unspecified four color samplings",
      "ja": "* 他の不特定の 4 つのカラー サンプリングを表す配列"
    },
    {
      "indent": 3,
      "text": "For the convenience of notation and terminology in this document, the variables and terms associated with these arrays can be referred to as luma and chroma regardless of the actual color representation method in use.",
      "ja": "このドキュメントでの表記と用語の便宜上、これらの配列に関連付けられた変数と用語は、使用されている実際の色表現方法に関係なく、輝度と彩度と呼ばれることがあります。"
    },
    {
      "indent": 3,
      "text": "The values of the variables SubWidthC, SubHeightC, and NumComps depend on the chroma format sampling structure as specified in Table 2. The chroma format sampling structure is signaled through chroma_format_idc. Other values of chroma_format_idc, SubWidthC, SubHeightC, and NumComps may be specified in future versions of this document.",
      "ja": "変数 SubWidthC、SubHeightC、および NumComps の値は、表 2 で指定されているクロマ フォーマット サンプリング構造によって異なります。クロマ フォーマット サンプリング構造は、chroma_format_idc を通じて通知されます。chroma_format_idc、SubWidthC、SubHeightC、および NumComps の他の値は、このドキュメントの将来のバージョンで指定される可能性があります。"
    },
    {
      "indent": 3,
      "text": "+===================+==========+===========+============+==========+\n| chroma_format_idc |  Chroma  | SubWidthC | SubHeightC | NumComps |\n|                   |  format  |           |            |          |\n+===================+==========+===========+============+==========+\n|         0         |  4:0:0   |     1     |     1      |    1     |\n+-------------------+----------+-----------+------------+----------+\n|         1         | reserved |  reserved |  reserved  | reserved |\n+-------------------+----------+-----------+------------+----------+\n|         2         |  4:2:2   |     2     |     1      |    3     |\n+-------------------+----------+-----------+------------+----------+\n|         3         |  4:4:4   |     1     |     1      |    3     |\n+-------------------+----------+-----------+------------+----------+\n|         4         | 4:4:4:4  |     1     |     1      |    4     |\n+-------------------+----------+-----------+------------+----------+\n|        5..7       | reserved |  reserved |  reserved  | reserved |\n+-------------------+----------+-----------+------------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Table 2: SubWidthC, SubHeightC, and NumComps values derived from chroma_format_idc",
      "ja": "表 2: chroma_format_idc から導出された SubWidthC、SubHeightC、および NumComps の値"
    },
    {
      "indent": 3,
      "text": "In 4:0:0 sampling, there is only one sample array that can be considered as the luma array.",
      "ja": "4:0:0 サンプリングでは、luma 配列とみなせるサンプル配列は 1 つだけです。"
    },
    {
      "indent": 3,
      "text": "In 4:2:2 sampling, each of the two chroma arrays has the same height and half the width of the luma array.",
      "ja": "4:2:2 サンプリングでは、2 つのクロマ配列はそれぞれ同じ高さで、ルマ配列の半分の幅を持ちます。"
    },
    {
      "indent": 3,
      "text": "In 4:4:4 sampling and 4:4:4:4 sampling, all the sample arrays have the same height and width as the luma array.",
      "ja": "4:4:4 サンプリングおよび 4:4:4:4 サンプリングでは、すべてのサンプル配列の高さと幅は luma 配列と同じになります。"
    },
    {
      "indent": 3,
      "text": "The number of bits necessary for the representation of each of the samples in the luma and chroma arrays in a video sequence is in the range of 10 to 16, inclusive.",
      "ja": "ビデオ シーケンスのルマ配列とクロマ配列内の各サンプルの表現に必要なビット数は、10 ～ 16 の範囲内です。"
    },
    {
      "indent": 3,
      "text": "When the value of chroma_format_idc is equal to 2, the chroma samples are co-sited with the corresponding luma samples; the nominal locations in a frame are as shown in Figure 1.",
      "ja": "chroma_format_idc の値が 2 に等しい場合、クロマ サンプルは対応するルミナンス サンプルと同じ場所に配置されます。フレーム内の公称位置は図 1 に示すとおりです。"
    },
    {
      "indent": 3,
      "text": "              & * & * & * & * & * ...\n\n              & * & * & * & * & * ...\n\n              & * & * & * & * & * ...\n\n              & * & * & * & * & * ...\n\n                       ...\n\n& - location where both luma and chroma sample exist\n* - location where only luma sample exist",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 1: Nominal vertical and horizontal locations of 4:2:2 luma and chroma samples in a frame",
      "ja": "図 1: フレーム内の 4:2:2 輝度サンプルと彩度サンプルの公称垂直位置と水平位置"
    },
    {
      "indent": 3,
      "text": "For each frame, when the value of chroma_format_idc is equal to 3 or 4, all of the array samples are co-sited; the nominal locations in a frame are as shown in Figure 2.",
      "ja": "各フレームで、chroma_format_idc の値が 3 または 4 に等しい場合、すべての配列サンプルが共存します。フレーム内の公称位置は図 2 に示すとおりです。"
    },
    {
      "indent": 3,
      "text": "              & & & & & & & & & & ...\n\n              & & & & & & & & & & ...\n\n              & & & & & & & & & & ...\n\n              & & & & & & & & & & ...\n\n                       ...\n\n& - location where both luma and chroma sample exist",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 2: Nominal vertical and horizontal locations of 4:4:4 and 4:4:4:4 luma and chroma samples in a frame",
      "ja": "図 2: フレーム内の 4:4:4 および 4:4:4:4 輝度および彩度サンプルの公称垂直および水平位置"
    },
    {
      "indent": 3,
      "text": "Samples are processed in units of MBs. The variables MbWidth and MbHeight, which specify the width and height of the luma arrays for each MB, are defined as follows:",
      "ja": "サンプルは MB 単位で処理されます。各 MB の luma 配列の幅と高さを指定する変数 MbWidth と MbHeight は、次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "* MbWidth = 16",
      "ja": "* MB幅 = 16"
    },
    {
      "indent": 6,
      "text": "* MbHeight = 16",
      "ja": "* MB高さ = 16"
    },
    {
      "indent": 3,
      "text": "The variables MbWidthC and MbHeightC, which specify the width and height of the chroma arrays for each MB, are derived as follows:",
      "ja": "各 MB のクロマ配列の幅と高さを指定する変数 MbWidthC および MbHeightC は、次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* MbWidthC = MbWidth // SubWidthC",
      "ja": "* MbWidthC = MbWidth // サブ幅 C"
    },
    {
      "indent": 6,
      "text": "* MbHeightC = MbHeight // SubHeightC",
      "ja": "* MbHeightC = MbHeight // サブハイト C"
    },
    {
      "indent": 0,
      "text": "4.3. Partitioning of a Frame",
      "section_title": true,
      "ja": "4.3. フレームの分割"
    },
    {
      "indent": 0,
      "text": "4.3.1. Partitioning of a Frame into Tiles",
      "section_title": true,
      "ja": "4.3.1. フレームのタイルへの分割"
    },
    {
      "indent": 3,
      "text": "This section specifies how a frame is partitioned into tiles.",
      "ja": "このセクションでは、フレームをタイルに分割する方法を指定します。"
    },
    {
      "indent": 3,
      "text": "A frame is divided into tiles. A tile is a group of MBs that cover a rectangular region of a frame and is processed independently of other tiles. Every tile has the same width and height, except possibly tiles at the right or bottom frame boundary when the frame width or height is not a multiple of the tile width or height, respectively. The tiles in a frame are scanned in raster order. Within a tile, the MBs are scanned in raster order. Each MB is comprised of one (MbWidth) x (MbHeight) luma array and zero, two, or three corresponding chroma sample arrays.",
      "ja": "フレームはタイルに分割されます。タイルは、フレームの長方形の領域をカバーする MB のグループであり、他のタイルとは独立して処理されます。すべてのタイルの幅と高さは同じですが、フレームの幅または高さがそれぞれタイルの幅または高さの倍数ではない場合、右または下のフレーム境界にあるタイルが含まれる可能性があります。フレーム内のタイルはラスター順にスキャンされます。タイル内では、MB がラスター順にスキャンされます。各 MB は、1 つの (MbWidth) x (MbHeight) ルマ配列と、0、2、または 3 つの対応するクロマ サンプル配列で構成されます。"
    },
    {
      "indent": 3,
      "text": "For example, a frame is divided into 6 tiles (3 tile columns and 2 tile rows) as shown in Figure 3. In this example, the tile size is defined as 4 column MBs and 4 row MBs. In case of the third and sixth tiles (in raster order), the tile size is 2 column MBs and 4 row MBs since the frame width is not a multiple of the tile width.",
      "ja": "たとえば、図 3 に示すように、フレームは 6 つのタイル (3 タイル列と 2 タイル行) に分割されます。この例では、タイル サイズは 4 列 MB、4 行 MB として定義されています。3 番目と 6 番目のタイル (ラスター順) の場合、フレーム幅がタイル幅の倍数ではないため、タイル サイズは 2 列 MB、4 行 MB になります。"
    },
    {
      "indent": 3,
      "text": "+===================+===================+=========+\n#    |    |    |    # MB | MB | MB | MB # MB | MB #\n+-------------------+-------------------+---------+\n#    |    |    |    # MB | MB | MB | MB # MB | MB #\n+-----   tile  -----+-------------------+---------+\n#    |    |    |    # MB | MB | MB | MB # MB | MB #\n+-------------------+-------------------+---------+\n#    |    |    |    # MB | MB | MB | MB # MB | MB #\n+===================+===================+=========+\n# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #\n+-------------------+-------------------+---------+\n# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #\n+-------------------+-------------------+---------+\n# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #\n+-------------------+-------------------+---------+\n# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #\n+===================+===================+=========+\n\n            #,=  tile boundary\n            |,-  MB boundary",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 3: Frame with 10 by 8 MBs that is partitioned into 6 tiles",
      "ja": "図 3: 6 つのタイルに分割された 10 × 8 MB のフレーム"
    },
    {
      "indent": 0,
      "text": "4.3.2. Spatial or Component-Wise Partitioning",
      "section_title": true,
      "ja": "4.3.2. 空間的またはコンポーネントごとのパーティショニング"
    },
    {
      "indent": 3,
      "text": "The following divisions of processing elements form spatial or component-wise partitioning:",
      "ja": "処理要素の次の分割により、空間的またはコンポーネントごとの分割が形成されます。"
    },
    {
      "indent": 6,
      "text": "* the division of each frame into components;",
      "ja": "* 各フレームをコンポーネントに分割する。"
    },
    {
      "indent": 6,
      "text": "* the division of each frame into tile columns;",
      "ja": "* 各フレームをタイル列に分割します。"
    },
    {
      "indent": 6,
      "text": "* the division of each frame into tile rows;",
      "ja": "* 各フレームをタイル行に分割します。"
    },
    {
      "indent": 6,
      "text": "* the division of each tile column into tiles;",
      "ja": "* 各タイル列をタイルに分割する。"
    },
    {
      "indent": 6,
      "text": "* the division of each tile row into tiles;",
      "ja": "* 各タイル行をタイルに分割する。"
    },
    {
      "indent": 6,
      "text": "* the division of each tile into color components;",
      "ja": "* 各タイルを色成分に分割します。"
    },
    {
      "indent": 6,
      "text": "* the division of each tile into MBs;",
      "ja": "* 各タイルを MB に分割します。"
    },
    {
      "indent": 6,
      "text": "* the division of each MB into blocks.",
      "ja": "* 各 MB をブロックに分割します。"
    },
    {
      "indent": 0,
      "text": "4.4. Scanning Processes",
      "section_title": true,
      "ja": "4.4. スキャンプロセス"
    },
    {
      "indent": 0,
      "text": "4.4.1. Zig-Zag Scan",
      "section_title": true,
      "ja": "4.4.1. ジグザグスキャン"
    },
    {
      "indent": 3,
      "text": "This process converts a two dimensional array into an one-dimensional array. The process starts at the top-left position in the block and then moves diagonally, changing direction at the edges of the block until it reaches the bottom-right position. Figure 4 shows an example of scanning order for 4x4 size block.",
      "ja": "このプロセスでは、2 次元配列を 1 次元配列に変換します。プロセスはブロックの左上の位置から開始され、右下の位置に到達するまでブロックの端で方向を変えながら斜めに移動します。図 4 は、4x4 サイズのブロックのスキャン順序の例を示しています。"
    },
    {
      "indent": 3,
      "text": "+===================+\n# 00 | 01 | 05 | 06 #\n+-------------------+\n# 02 | 04 | 07 | 12 #\n+-------------------+\n# 03 | 08 | 11 | 13 #\n+-------------------+\n# 09 | 10 | 14 | 15 #\n+===================+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 4: Example of zig-zag scanning order for 4x4 block",
      "ja": "図 4: 4x4 ブロックのジグザグ スキャン順序の例"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a variable blkWidth specifying the width of a block, and",
      "ja": "* ブロックの幅を指定する変数 blkWidth、および"
    },
    {
      "indent": 6,
      "text": "* a variable blkHeight specifying the height of a block.",
      "ja": "* ブロックの高さを指定する変数 blkHeight。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the array zigZagScan[sPos].",
      "ja": "このプロセスの出力は、配列 zigZagScan[sPos] です。"
    },
    {
      "indent": 3,
      "text": "The array index sPos specifies the scan position ranging from 0 to (blkWidth * blkHeight)-1. Depending on the value of blkWidth and blkHeight, the array zigZagScan is derived as follows:",
      "ja": "配列インデックス sPos は、0 ～ (blkWidth * blkHeight)-1 の範囲のスキャン位置を指定します。blkWidth と blkHeight の値に応じて、配列 zigZagScan は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": "pos = 0\nzigZagScan[pos] = 0\npos++\nfor(line = 1; line < (blkWidth + blkHeight - 1); line++){\n  if(line % 2){\n    x = min(line, blkWidth - 1)\n    y = max(0, line - (blkWidth - 1))\n    while(x >=0 && y < blkHeight){\n      zigZagScan[pos] = y * blkWidth + x\n      pos++\n      x--\n      y++\n    }\n  }\n  else{\n    y = min(line, blkHeight - 1)\n    x = max(0, line - (blkHeight - 1))\n    while(y >= 0 && x < blkWidth){\n      zigZagScan[pos] = y * blkWidth + x\n      pos++\n      x++\n      y--\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 5: Pseudocode for zig-zag scan",
      "ja": "図 5: ジグザグ スキャンの疑似コード"
    },
    {
      "indent": 0,
      "text": "4.4.2. Inverse Scan",
      "section_title": true,
      "ja": "4.4.2. 逆スキャン"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a variable blkWidth specifying the width of a block, and",
      "ja": "* ブロックの幅を指定する変数 blkWidth、および"
    },
    {
      "indent": 6,
      "text": "* a variable blkHeight specifying the height of a block.",
      "ja": "* ブロックの高さを指定する変数 blkHeight。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the array inverseScan[rPos].",
      "ja": "このプロセスの出力は、配列 inverseScan[rPos] です。"
    },
    {
      "indent": 3,
      "text": "The array index rPos specifies the raster scan position ranging from 0 to (blkWidth * blkHeight)-1. Depending on the value of blkWidth and blkHeight, the array inverseScan is derived as follows:",
      "ja": "配列インデックス rPos は、0 ～ (blkWidth * blkHeight)-1 の範囲のラスター スキャン位置を指定します。blkWidth と blkHeight の値に応じて、配列 inverseScan は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* The variable forwardScan is derived by invoking the zig-zag scan order initialization process as specified in Section 4.4.1 with input parameters blkWidth and blkHeight.",
      "ja": "* 変数 forwardScan は、セクション 4.4.1 で指定されているように、入力パラメータ blkWidth および blkHeight を使用してジグザグ スキャン順序の初期化プロセスを呼び出すことによって導出されます。"
    },
    {
      "indent": 6,
      "text": "* The output variable inverseScan is derived as follows:",
      "ja": "* 出力変数 inverseScan は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": "for(pos = 0; pos < blkWidth * blkHeight; pos++){\n  inverseScan[forwardScan[pos]] = pos\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 6: Pseudocode for inverse zig-zag scan",
      "ja": "図 6: 逆ジグザグ スキャンの疑似コード"
    },
    {
      "indent": 0,
      "text": "5. Syntax and Semantics",
      "section_title": true,
      "ja": "5. 構文とセマンティクス"
    },
    {
      "indent": 0,
      "text": "5.1. Method of Specifying Syntax",
      "section_title": true,
      "ja": "5.1. 構文の指定方法"
    },
    {
      "indent": 3,
      "text": "The syntax tables specify a superset of the syntax of all allowed bitstreams. Note that a decoder MUST implement some means for identifying entry points into the bitstream and some means to identify and handle non-conforming bitstreams. The methods for identifying and handling errors and other such situations are not specified in this document.",
      "ja": "構文テーブルは、許可されているすべてのビットストリームの構文のスーパーセットを指定します。デコーダは、ビットストリームへのエントリポイントを識別するための何らかの手段と、不適合なビットストリームを識別して処理するための何らかの手段を実装しなければならないことに注意してください。エラーなどの状況を特定して処理する方法は、本書では規定されていません。"
    },
    {
      "indent": 3,
      "text": "The APV bitstream is described using syntax code based on the C programming language [ISO9899] -- including use of if/else, while, and for -- as well as functions defined within this document.",
      "ja": "APV ビットストリームは、C プログラミング言語 [ISO9899] に基づく構文コード (if/else、while、for の使用を含む) およびこの文書内で定義されている関数を使用して記述されます。"
    },
    {
      "indent": 3,
      "text": "The syntax table in syntax code is presented in a two-column format such as shown in Figure 7. In this form, the type column provides a type referenced in that same line of syntax code by using the syntax elements processing functions defined in Section 5.2.5.",
      "ja": "構文コードの構文テーブルは、図 7 に示すような 2 列形式で表示されます。この形式では、型列は、セクション 5.2.5 で定義された構文要素処理関数を使用して、構文コードの同じ行で参照される型を提供します。"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nExampleSyntaxCode(){                                          |\n       operations                                             |\n       syntax_element                                         | u(n)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 7: A depiction of type-labeled syntax code for syntax description in this document",
      "ja": "図 7: この文書の構文説明のためのタイプラベル付き構文コードの図"
    },
    {
      "indent": 0,
      "text": "5.2. Syntax Functions and Descriptors",
      "section_title": true,
      "ja": "5.2. 構文関数と記述子"
    },
    {
      "indent": 3,
      "text": "The functions presented in this document are used in the syntactical description. These functions are expressed in terms of the value of a bitstream pointer that indicates the position of the next bit to be read by the decoding process from the bitstream.",
      "ja": "このドキュメントで示されている関数は、構文の説明で使用されています。これらの関数は、デコード プロセスによってビットストリームから読み取られる次のビットの位置を示すビットストリーム ポインターの値によって表現されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. byte_aligned()",
      "section_title": true,
      "ja": "5.2.1. byte_aligned()"
    },
    {
      "indent": 6,
      "text": "* If the current position in the bitstream is on the last bit of a byte, i.e., the next bit in the bitstream is the first bit in a byte, the return value of byte_aligned() is equal to TRUE.",
      "ja": "* ビットストリーム内の現在位置がバイトの最後のビットにある場合、つまり、ビットストリーム内の次のビットがバイトの最初のビットである場合、byte_aligned() の戻り値は TRUE に等しくなります。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, the return value of byte_aligned() is equal to FALSE.",
      "ja": "* それ以外の場合、byte_aligned() の戻り値は FALSE と等しくなります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. more_data_in_tile()",
      "section_title": true,
      "ja": "5.2.2. more_data_in_tile()"
    },
    {
      "indent": 6,
      "text": "* If the current position in the i-th tile() syntax structure is less than TileSize[i] in bytes from the beginning of the tile_header() syntax structure of the i-th tile, the return value of more_data_in_tile() is equal to TRUE.",
      "ja": "* i 番目の tile() 構文構造内の現在位置が、i 番目のタイルの tile_header() 構文構造の先頭からバイト単位の TileSize[i] より小さい場合、more_data_in_tile() の戻り値は TRUE に等しくなります。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, the return value of more_data_in_tile() is equal to FALSE.",
      "ja": "* それ以外の場合、more_data_in_tile() の戻り値は FALSE と等しくなります。"
    },
    {
      "indent": 0,
      "text": "5.2.3. next_bits(n)",
      "section_title": true,
      "ja": "5.2.3. next_bits(n)"
    },
    {
      "indent": 3,
      "text": "This function provides the next n bits in the bitstream for comparison purposes, without advancing the bitstream pointer.",
      "ja": "この関数は、ビットストリーム ポインタを進めることなく、比較目的でビットストリーム内の次の n ビットを提供します。"
    },
    {
      "indent": 0,
      "text": "5.2.4. read_bits(n)",
      "section_title": true,
      "ja": "5.2.4. 読み取りビット(n)"
    },
    {
      "indent": 3,
      "text": "This function indicates that the next n bits from the bitstream are to be read and it advances the bitstream pointer by n bit positions. When n is equal to 0, read_bits(n) is specified to return a value equal to 0 and to not advance the bitstream pointer.",
      "ja": "この関数は、ビットストリームから次の n ビットを読み取ることを示し、ビットストリーム ポインタを n ビット位置だけ進めます。n が 0 に等しい場合、read_bits(n) は 0 に等しい値を返し、ビットストリーム ポインタを進めないよう指定されます。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Syntax Element Processing Functions",
      "section_title": true,
      "ja": "5.2.5. 構文要素の処理関数"
    },
    {
      "indent": 3,
      "text": "b(8):",
      "ja": "b(8):"
    },
    {
      "indent": 12,
      "text": "byte having any pattern of bit string (8 bits). The parsing process for this descriptor is specified by the return value of the function read_bits(8).",
      "ja": "任意のパターンのビット列(8ビット)を持つバイト。このディスクリプタの解析処理は、関数 read_bits(8) の戻り値によって指定されます。"
    },
    {
      "indent": 3,
      "text": "f(n):",
      "ja": "f(n):"
    },
    {
      "indent": 12,
      "text": "fixed-pattern bit string using n bits written (from left to right) with the left bit first, i.e., big endian format. The parsing process for this descriptor is specified by the return value of the function read_bits(n).",
      "ja": "n ビットを使用し、左ビットから順に (左から右に) 書き込まれる固定パターンのビット文字列、つまりビッグ エンディアン形式。このディスクリプタの解析処理は、関数 read_bits(n) の戻り値によって指定されます。"
    },
    {
      "indent": 3,
      "text": "u(n):",
      "ja": "国連）："
    },
    {
      "indent": 12,
      "text": "unsigned integer using n bits. The parsing process for this descriptor is specified by the return value of the function read_bits(n) interpreted as a binary representation of an unsigned integer with the most significant bit written first.",
      "ja": "n ビットを使用する符号なし整数。この記述子の解析プロセスは、最上位ビットが最初に書き込まれる符号なし整数のバイナリ表現として解釈される関数 read_bits(n) の戻り値によって指定されます。"
    },
    {
      "indent": 3,
      "text": "h(v):",
      "ja": "h(v):"
    },
    {
      "indent": 12,
      "text": "variable-length entropy coded syntax element with the left bit first, i.e., big endian format. The parsing process for this descriptor is specified in Section 7.1.",
      "ja": "左ビットが最初になる可変長エントロピー符号化構文要素、つまりビッグ エンディアン形式。この記述子の解析プロセスはセクション 7.1 で規定されています。"
    },
    {
      "indent": 0,
      "text": "5.3. List of Syntax and Semantics",
      "section_title": true,
      "ja": "5.3. 構文と意味のリスト"
    },
    {
      "indent": 0,
      "text": "5.3.1. Access Unit",
      "section_title": true,
      "ja": "5.3.1. アクセスユニット"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\naccess_unit(au_size){                                         |\n    signature                                                 | f(32)\n    currReadSize = 4                                          |\n    do(){                                                     |\n        pbu_size                                              | u(32)\n        currReadSize += 4                                     |\n        pbu()                                                 |\n        currReadSize += pbu_size                              |\n    } while (au_size > currReadSize)                          |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 8: access unit syntax code",
      "ja": "図 8: アクセスユニットの構文コード"
    },
    {
      "indent": 3,
      "text": "signature",
      "ja": "サイン"
    },
    {
      "indent": 12,
      "text": "A four-character code that identifies the bitstream as an APV AU. The value MUST be 'aPv1' (0x61507631).",
      "ja": "ビットストリームを APV AU として識別する 4 文字のコード。値は「aPv1」(0x61507631) でなければなりません。"
    },
    {
      "indent": 3,
      "text": "pbu_size",
      "ja": "pbu_size"
    },
    {
      "indent": 12,
      "text": "the size of a primitive bitstream unit in bytes. A value of 0 is prohibited and the value of 0xFFFFFFFF for pbu_size is reserved for future use.",
      "ja": "プリミティブ ビットストリーム ユニットのバイト単位のサイズ。値 0 は禁止されており、pbu_size の値 0xFFFFFFFF は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note: An AU consists of one primary frame, zero or more non-primary frames such as a frame for additional view, zero or more alpha frames, zero or more depth frames, zero or more preview frames such as a frame with smaller resolution, zero or more metadata, and zero or more fillers.",
      "ja": "注: AU は、1 つのプライマリ フレーム、追加ビュー用のフレームなどの 0 個以上の非プライマリ フレーム、0 個以上のアルファ フレーム、0 個以上の深度フレーム、より解像度の低いフレームなどの 0 個以上のプレビュー フレーム、0 個以上のメタデータ、および 0 個以上のフィラーで構成されます。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Primitive Bitstream Unit",
      "section_title": true,
      "ja": "5.3.2. プリミティブビットストリームユニット"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\npbu(){                                                        |\n    pbu_header()                                              |\n    if((1 <= pbu_type && pbu_type <=2) ||                     |\n      (25 <= pbu_type && pbu_type <= 27))                     |\n      frame()                                                 |\n    else if(pbu_type == 65)                                   |\n      au_info()                                               |\n    else if(pbu_type == 66)                                   |\n      metadata()                                              |\n    else if (pbu_type == 67)                                  |\n      filler()                                                |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 9: primitive bitstream unit syntax code",
      "ja": "図 9: プリミティブ ビットストリーム ユニットの構文コード"
    },
    {
      "indent": 0,
      "text": "5.3.3. Primitive Bitstream Unit Header",
      "section_title": true,
      "ja": "5.3.3. プリミティブビットストリームユニットヘッダー"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\npbu_header(){                                                 |\n    pbu_type                                                  | u(8)\n    group_id                                                  | u(16)\n    reserved_zero_8bits                                       | u(8)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 10: primitive bitstream unit header syntax code",
      "ja": "図 10: プリミティブ ビットストリーム ユニット ヘッダーの構文コード"
    },
    {
      "indent": 3,
      "text": "pbu_type",
      "ja": "pbu_type"
    },
    {
      "indent": 12,
      "text": "indicates the type of data in a PBU listed in Table 3. Other values of pbu_type are reserved for future use.",
      "ja": "は、表 3 にリストされている PBU 内のデータのタイプを示します。pbu_type のその他の値は、将来の使用のために予約されています。"
    },
    {
      "indent": 13,
      "text": "+==========+=========================+=======+\n| pbu_type |         meaning         | notes |\n+==========+=========================+=======+\n|    0     |         reserved        |       |\n+----------+-------------------------+-------+\n|    1     |      primary frame      |       |\n+----------+-------------------------+-------+\n|    2     |    non-primary frame    |       |\n+----------+-------------------------+-------+\n|  3...24  |         reserved        |       |\n+----------+-------------------------+-------+\n|    25    |      preview frame      |       |\n+----------+-------------------------+-------+\n|    26    |       depth frame       |       |\n+----------+-------------------------+-------+\n|    27    |       alpha frame       |       |\n+----------+-------------------------+-------+\n| 28...64  |         reserved        |       |\n+----------+-------------------------+-------+\n|    65    | access unit information |       |\n+----------+-------------------------+-------+\n|    66    |         metadata        |       |\n+----------+-------------------------+-------+\n|    67    |          filler         |       |\n+----------+-------------------------+-------+\n| 68...255 |         reserved        |       |\n+----------+-------------------------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 3: List of PBU types",
      "ja": "表 3: PBU タイプのリスト"
    },
    {
      "indent": 12,
      "text": "Note: A PBU with pbu_type equal to 65 (access unit information) may happen in an AU. If it exists, it MUST be the first PBU in an AU, and it can be ignored by a decoder.",
      "ja": "注: pbu_type が 65 (アクセス ユニット情報) の PBU が AU で発生する可能性があります。存在する場合、それは AU 内の最初の PBU でなければならず、デコーダは無視できます。"
    },
    {
      "indent": 3,
      "text": "group_id",
      "ja": "グループID"
    },
    {
      "indent": 12,
      "text": "indicates the identifier to associate a coded frame with metadata. More than two frames can have the same group_id in a single AU. A primary frame and a non-primary frame MUST have different group_id values, and two non-primary frames MUST have different group_id values. When the value of group_id is equal to 0, the value of pbu_type MUST be greater than 64. The value of 0xFFFF for group_id is reserved for future use.",
      "ja": "符号化フレームとメタデータを関連付ける識別子を示します。1 つの AU 内で 3 つ以上のフレームが同じ group_id を持つことができます。プライマリ フレームと非プライマリ フレームは異なる group_id 値を持たなければなりません (MUST)。また、2 つの非プライマリ フレームは異なる group_id 値を持たなければなりません (MUST)。group_id の値が 0 に等しい場合、pbu_type の値は 64 より大きくなければなりません。group_id の値 0xFFFF は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Frame",
      "section_title": true,
      "ja": "5.3.4. フレーム"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nframe(){                                                      |\n    frame_header()                                            |\n    for(i = 0; i < NumTiles; i++){                            |\n        tile_size[i]                                          | u(32)\n        tile(i)                                               |\n    }                                                         |\n    filler()                                                  |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 11: frame() syntax code",
      "ja": "図 11: Frame() 構文コード"
    },
    {
      "indent": 3,
      "text": "tile_size[i]",
      "ja": "タイルサイズ[i]"
    },
    {
      "indent": 12,
      "text": "indicates the size in bytes of i-th tile data (i.e., tile(i)) in raster order in a frame. The value of 0 for tile_size[i] is reserved for future use.",
      "ja": "フレーム内のラスター順の i 番目のタイル データ (つまり、tile(i)) のサイズをバイト単位で示します。tile_size[i] の値 0 は、将来の使用のために予約されています。"
    },
    {
      "indent": 12,
      "text": "The variable TileSize[i] is set equal to tile_size[i].",
      "ja": "変数 TileSize[i] は tile_size[i] に等しく設定されます。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Frame Header",
      "section_title": true,
      "ja": "5.3.5. フレームヘッダー"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nframe_header(){                                               |\n  frame_info()                                                |\n  reserved_zero_8bits                                         | u(8)\n  color_description_present_flag                              | u(1)\n  if(color_description_present_flag){                         |\n    color_primaries                                           | u(8)\n    transfer_characteristics                                  | u(8)\n    matrix_coefficients                                       | u(8)\n    full_range_flag                                           | u(1)\n  }                                                           |\n  use_q_matrix                                                | u(1)\n  if(use_q_matrix){                                           |\n    quantization_matrix()                                     |\n  }                                                           |\n  tile_info()                                                 |\n  reserved_zero_8bits                                         | u(8)\n  byte_alignment()                                            |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 12: frame_header() syntax code",
      "ja": "図 12: Frame_header() 構文コード"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 3,
      "text": "color_description_present_flag equal to 1",
      "ja": "color_description_present_flag が 1 に等しい"
    },
    {
      "indent": 12,
      "text": "specifies that color_primaries, transfer_characteristics, and matrix_coefficients are present. color_description_present_flag equal to 0 specifies that color_primaries, transfer_characteristics, and matrix_coefficients are not present.",
      "ja": "color_primaries、transfer_characteristics、matrix_coefficients が存在することを指定します。color_description_present_flag が 0 に等しい場合は、color_primaries、transfer_characteristics、matrix_coefficients が存在しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "color_primaries",
      "ja": "color_primaries"
    },
    {
      "indent": 12,
      "text": "MUST have the semantics of ColourPrimaries as specified in [H273]. When the color_primaries syntax element is not present, the value of color_primaries is inferred to be equal to 2.",
      "ja": "[H273] で指定されているように、ColourPrimaries のセマンティクスを持たなければなりません。color_primaries 構文要素が存在しない場合、color_primaries の値は 2 に等しいと推測されます。"
    },
    {
      "indent": 3,
      "text": "transfer_characteristics",
      "ja": "伝達特性"
    },
    {
      "indent": 12,
      "text": "MUST have the semantics of TransferCharacteristics as specified in [H273]. When the transfer_characteristics syntax element is not present, the value of transfer_characteristics is inferred to be equal to 2.",
      "ja": "[H273] で指定されている TransferCharacteristics のセマンティクスを持たなければなりません (MUST)。transfer_characteristics 構文要素が存在しない場合、transfer_characteristics の値は 2 に等しいと推測されます。"
    },
    {
      "indent": 3,
      "text": "matrix_coefficients",
      "ja": "行列係数"
    },
    {
      "indent": 12,
      "text": "MUST have the semantics of MatrixCoefficients as specified in [H273]. When the matrix_coefficients syntax element is not present, the value of matrix_coefficients is inferred to be equal to 2.",
      "ja": "[H273] で指定されている MatrixCoefficients のセマンティクスを持たなければなりません (MUST)。math_coefficients 構文要素が存在しない場合、matrix_coefficients の値は 2 に等しいと推測されます。"
    },
    {
      "indent": 3,
      "text": "full_range_flag",
      "ja": "フルレンジフラグ"
    },
    {
      "indent": 12,
      "text": "MUST have the semantics of VideoFullRangeFlag as specified in [H273]. When the full_range_flag syntax element is not present, the value of full_range_flag is inferred to be equal to 0.",
      "ja": "[H273] で指定されている VideoFullRangeFlag のセマンティクスを持たなければなりません (MUST)。full_range_flag 構文要素が存在しない場合、full_range_flag の値は 0 に等しいと推測されます。"
    },
    {
      "indent": 3,
      "text": "use_q_matrix",
      "ja": "use_q_matrix"
    },
    {
      "indent": 12,
      "text": "with a value of 1 specifies that the quantization matrices are present. A value of 0 specifies that the quantization matrices are not present.",
      "ja": "値 1 は、量子化行列が存在することを指定します。値 0 は、量子化行列が存在しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 0,
      "text": "5.3.6. Frame Information",
      "section_title": true,
      "ja": "5.3.6. フレーム情報"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nframe_info(){                                                 |\n  profile_idc                                                 | u(8)\n  level_idc                                                   | u(8)\n  band_idc                                                    | u(3)\n  reserved_zero_5bits                                         | u(5)\n  frame_width                                                 | u(24)\n  frame_height                                                | u(24)\n  chroma_format_idc                                           | u(4)\n  bit_depth_minus8                                            | u(4)\n  capture_time_distance                                       | u(8)\n  reserved_zero_8bits                                         | u(8)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 13: frame_info() syntax code",
      "ja": "図 13: Frame_info() 構文コード"
    },
    {
      "indent": 3,
      "text": "profile_idc",
      "ja": "プロフィールIDC"
    },
    {
      "indent": 12,
      "text": "indicates a profile to which the coded frame conforms as specified in Section 9. Bitstreams SHALL NOT contain values of profiles_idc other than those specified in Section 9. Other values of profile_idc are reserved for future use.",
      "ja": "セクション 9 で指定されているように、符号化されたフレームが準拠するプロファイルを示します。ビットストリームには、セクション 9 で指定されたもの以外の profiles_idc の値が含まれてはなりません (SHALL NOT)。profile_idc の他の値は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "level_idc",
      "ja": "レベルIDC"
    },
    {
      "indent": 12,
      "text": "indicates a level to which the coded frame conforms as specified in Section 9. Bitstreams SHALL NOT contain values of level_idc other than those specified in Section 9. Other values of level_idc are reserved for future use.",
      "ja": "セクション 9 で指定されているように、符号化されたフレームが準拠するレベルを示します。ビットストリームには、セクション 9 で指定されたもの以外の level_idc の値を含めてはなりません (SHALL NOT)。level_idc の他の値は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "band_idc",
      "ja": "バンドIDC"
    },
    {
      "indent": 12,
      "text": "specifies a maximum coded data rate of level_idc as specified in Section 9. Bitstreams SHALL NOT contain values of band_idc other than those specified in Section 9. The value of band_idc MUST be in the range of 0 to 3. Other values of band_idc are reserved for future use.",
      "ja": "セクション 9 で指定されているように、level_idc の最大符号化データ レートを指定します。ビットストリームには、セクション 9 で指定されたもの以外の Band_idc の値が含まれてはなりません (SHALL NOT)。band_idc の値は 0 から 3 の範囲内でなければなりません (MUST)。band_idc の他の値は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_5bits",
      "ja": "予約済み_zero_5bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 3,
      "text": "frame_width",
      "ja": "フレーム幅"
    },
    {
      "indent": 12,
      "text": "specifies the width of the frame in units of luma samples. frame_width MUST be a multiple of 2 when chroma_format_idc has a value of 2. The value 0 is reserved for future use.",
      "ja": "フレームの幅を輝度サンプルの単位で指定します。chroma_format_idc の値が 2 の場合、frame_width は 2 の倍数でなければなりません。値 0 は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "frame_height",
      "ja": "フレームの高さ"
    },
    {
      "indent": 12,
      "text": "specifies the height of the frame in units of luma samples. The value 0 is reserved for future use.",
      "ja": "フレームの高さを輝度サンプルの単位で指定します。値 0 は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The variables FrameWidthInMbsY, FrameHeightInMbsY, FrameWidthInSamplesY, FrameHeightInSamplesY, FrameWidthInSamplesC, FrameHeightInSamplesC, FrameSizeInMbsY, and FrameSizeInSamplesY are derived as follows:",
      "ja": "変数 FrameWidthInMbsY、FrameHeightInMbsY、FrameWidthInSamplesY、FrameHeightInSamplesY、FrameWidthInSamplesC、FrameHeightInSamplesC、FrameSizeInMbsY、および FrameSizeInSamplesY は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* FrameWidthInSamplesY = frame_width",
      "ja": "* FrameWidthInSamplesY = フレーム幅"
    },
    {
      "indent": 6,
      "text": "* FrameHeightInSamplesY = frame_height",
      "ja": "* FrameHeightInSamplesY = フレームの高さ"
    },
    {
      "indent": 6,
      "text": "* FrameWidthInMbsY = ceil(FrameWidthInSamplesY / MbWidth)",
      "ja": "* FrameWidthInMbsY = ceil(FrameWidthInSamplesY / MbWidth)"
    },
    {
      "indent": 6,
      "text": "* FrameHeightInMbsY = ceil(FrameHeightInSamplesY / MbHeight)",
      "ja": "* FrameHeightInMbsY = ceil(FrameHeightInSamplesY / MbHeight)"
    },
    {
      "indent": 6,
      "text": "* FrameWidthInSamplesC = FrameWidthInSamplesY // SubWidthC",
      "ja": "* FrameWidthInSamplesC = FrameWidthInSamplesY // SubWidthC"
    },
    {
      "indent": 6,
      "text": "* FrameHeightInSamplesC = FrameHeightInSamplesY // SubHeightC",
      "ja": "* FrameHeightInSamplesC = FrameHeightInSamplesY // サブハイト C"
    },
    {
      "indent": 6,
      "text": "* FrameSizeInMbsY = FrameWidthInMbsY * FrameHeightInMbsY",
      "ja": "* FrameSizeInMbsY = FrameWidthInMbsY * FrameHeightInMbsY"
    },
    {
      "indent": 6,
      "text": "* FrameSizeInSamplesY = FrameWidthInSamplesY * FrameHeightInSamplesY",
      "ja": "* FrameSizeInSamplesY = FrameWidthInSamplesY * FrameHeightInSamplesY"
    },
    {
      "indent": 3,
      "text": "chroma_format_idc",
      "ja": "chroma_format_idc"
    },
    {
      "indent": 12,
      "text": "specifies the chroma sampling relative to the luma sampling as specified in Table 2. The value of chroma_format_idc MUST be 0, 2, 3, or 4. Other values are reserved for future use.",
      "ja": "表 2 で指定されている輝度サンプリングを基準とした彩度サンプリングを指定します。chroma_format_idc の値は 0、2、3、または 4 でなければなりません。他の値は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "bit_depth_minus8",
      "ja": "bit_ Depth_minus8"
    },
    {
      "indent": 12,
      "text": "specifies the bit depth of the samples. The variables BitDepth and QpBdOffset are derived as follows:",
      "ja": "サンプルのビット深度を指定します。変数 BitDepth と QpBdOffset は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* BitDepth = bit_depth_minus8 + 8",
      "ja": "* ビット深度 = ビット深度マイナス 8 + 8"
    },
    {
      "indent": 6,
      "text": "* QpBdOffset = bit_depth_minus8 * 6",
      "ja": "* QpBdOffset = ビット深度マイナス 8 * 6"
    },
    {
      "indent": 12,
      "text": "bit_depth_minus8 MUST be in the range of 2 to 8, inclusive. Other values are reserved for future use.",
      "ja": "bit_ Depth_minus8 は 2 ～ 8 の範囲内でなければなりません (両端の値を含む)。他の値は将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "capture_time_distance",
      "ja": "キャプチャ時間_距離"
    },
    {
      "indent": 12,
      "text": "indicates the time difference between the capture time of the frames in the previous access unit and frames in the current access unit in milliseconds if there has been any access unit preceding the access unit this frame belongs to.",
      "ja": "このフレームが属するアクセス ユニットの前にアクセス ユニットがあった場合、前のアクセス ユニットのフレームのキャプチャ時間と現在のアクセス ユニットのフレームの時間差をミリ秒単位で示します。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 0,
      "text": "5.3.7. Quantization Matrix",
      "section_title": true,
      "ja": "5.3.7. 量子化マトリックス"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nquantization_matrix(){                                        |\n  for(i = 0; i < NumComps; i++){                              |\n    for(y = 0; y < 8; y++){                                   |\n      for(x = 0; x < 8; x++){                                 |\n        q_matrix[i][x][y]                                     | u(8)\n      }                                                       |\n    }                                                         |\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 14: quantization_matrix() syntax code",
      "ja": "図 14: quantization_matrix() 構文コード"
    },
    {
      "indent": 3,
      "text": "q_matrix[i][x][y]",
      "ja": "q_matrix[i][x][y]"
    },
    {
      "indent": 12,
      "text": "specifies a scaling value in the quantization matrices. When q_matrix[i][x][y] is not present, it is inferred to be equal to 16. The array index i specifies an indicator for the color component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The value of 0 for q_matrix[i][x][y] is reserved for future use.",
      "ja": "量子化行列のスケーリング値を指定します。q_matrix[i][x][y] が存在しない場合、16 に等しいと推測されます。配列インデックス i は色コンポーネントのインジケーターを指定します。chroma_format_idc が 2 または 3 に等しい場合、インデックス i の値は、Y コンポーネントの場合は 0、Cb の場合は 1、Cr の場合は 2 に等しくなります。q_matrix[i][x][y] の値 0 は、将来の使用のために予約されています。"
    },
    {
      "indent": 12,
      "text": "The quantization matrix, QMatrix[i][x][y], is derived as follows:",
      "ja": "量子化行列 QMatrix[i][x][y] は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* QMatrix[i][x][y] = q_matrix[i][x][y]",
      "ja": "* QMatrix[i][x][y] = q_matrix[i][x][y]"
    },
    {
      "indent": 0,
      "text": "5.3.8. Tile Info",
      "section_title": true,
      "ja": "5.3.8. タイル情報"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\ntile_info(){                                                  |\n  tile_width_in_mbs                                           | u(20)\n  tile_height_in_mbs                                          | u(20)\n  startMb = 0                                                 |\n  for(i = 0; startMb < FrameWidthInMbsY; i++){                |\n    ColStarts[i] = startMb * MbWidth                          |\n    startMb += tile_width_in_mbs                              |\n  }                                                           |\n  ColStarts[i] = FrameWidthInMbsY*MbWidth                     |\n  TileCols = i                                                |\n  startMb = 0                                                 |\n  for(i = 0; startMb < FrameHeightInMbsY; i++){               |\n    RowStarts[i] = startMb * MbHeight                         |\n    startMb += tile_height_in_mbs                             |\n  }                                                           |\n  RowStarts[i] = FrameHeightInMbsY*MbHeight                   |\n  TileRows = i                                                |\n  NumTiles = TileCols * TileRows                              |\n  tile_size_present_in_fh_flag                                | u(1)\n  if(tile_size_present_in_fh_flag){                           |\n    for(i = 0; i < NumTiles; i++){                            |\n      tile_size_in_fh[i]                                      | u(32)\n    }                                                         |\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 15: tile_info() syntax code",
      "ja": "図 15: tile_info() 構文コード"
    },
    {
      "indent": 3,
      "text": "tile_width_in_mbs",
      "ja": "tile_width_in_mbs"
    },
    {
      "indent": 12,
      "text": "specifies the width of a tile in units of MBs.",
      "ja": "タイルの幅を MB 単位で指定します。"
    },
    {
      "indent": 3,
      "text": "tile_height_in_mbs",
      "ja": "tile_height_in_mbs"
    },
    {
      "indent": 12,
      "text": "specifies the height of a tile in units of MBs.",
      "ja": "タイルの高さを MB 単位で指定します。"
    },
    {
      "indent": 3,
      "text": "tile_size_present_in_fh_flag",
      "ja": "tile_size_present_in_fh_flag"
    },
    {
      "indent": 12,
      "text": "equal to 1 specifies that tile_size_in_fh[i] is present in the frame header. tile_size_present_in_fh_flag equal to 0 specifies that tile_size_in_fh[i] is not present in the frame header.",
      "ja": "1 に等しい場合は、tile_size_in_fh[i] がフレーム ヘッダーに存在することを指定します。tile_size_present_in_fh_flagが0に等しい場合は、tile_size_in_fh[i]がフレームヘッダーに存在しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "tile_size_in_fh[i]",
      "ja": "タイルサイズ_in_fh[i]"
    },
    {
      "indent": 12,
      "text": "indicates the size in bytes of i-th tile data in raster order in a frame. The value of tile_size_in_fh[i] MUST have the same value with tile_size[i]. When it is not present, the value of tile_size_in_fh[i] is inferred to be equal to tile_size[i]. The value of 0 for tile_size_in_fh[i] is reserved for future use.",
      "ja": "フレーム内のラスター順の i 番目のタイル データのサイズをバイト単位で示します。tile_size_in_fh[i] の値は、tile_size[i] と同じ値でなければなりません。存在しない場合、tile_size_in_fh[i] の値は tile_size[i] と等しいと推測されます。tile_size_in_fh[i] の値 0 は、将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "5.3.9. Access Unit Information",
      "section_title": true,
      "ja": "5.3.9. ユニット情報にアクセスする"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nau_info(){                                                    |\n  num_frames                                                  | u(16)\n  for(i = 0; i < num_frames; i++){                            |\n    pbu_type                                                  | u(8)\n    group_id                                                  | u(16)\n    reserved_zero_8bits                                       | u(8)\n    frame_info()                                              |\n  }                                                           |\n  reserved_zero_8bits                                         | u(8)\n  byte_alignment()                                            |\n  filler()                                                    |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 16: au_info() syntax code",
      "ja": "図 16: au_info() 構文コード"
    },
    {
      "indent": 3,
      "text": "num_frames",
      "ja": "num_frames"
    },
    {
      "indent": 12,
      "text": "indicates the number of frames contained in the current AU.",
      "ja": "は、現在のAUに含まれるフレームの数を示します。"
    },
    {
      "indent": 3,
      "text": "pbu_type",
      "ja": "pbu_type"
    },
    {
      "indent": 12,
      "text": "has the same semantics as pbu_type in the pbu_header() syntax.",
      "ja": "pbu_header() 構文の pbu_type と同じセマンティクスを持ちます。"
    },
    {
      "indent": 12,
      "text": "Note: The value of pbu_type MUST be 1, 2, 25, 26, or 27 in bitstreams conforming to this document.",
      "ja": "注: この文書に準拠するビットストリームでは、pbu_type の値は 1、2、25、26、または 27 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "group_id",
      "ja": "グループID"
    },
    {
      "indent": 12,
      "text": "has the same semantics as group_id in the pbu_header() syntax.",
      "ja": "pbu_header() 構文の group_id と同じセマンティクスを持ちます。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 0,
      "text": "5.3.10. Metadata",
      "section_title": true,
      "ja": "5.3.10. メタデータ"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata(){                                                   |\n  metadata_size                                               | u(32)\n  currReadSize = 0                                            |\n  do{                                                         |\n    payloadType = 0                                           |\n    while(next_bits(8) == 0xFF){                              |\n      ff_byte                                                 | f(8)\n      payloadType += ff_byte                                  |\n      currReadSize++                                          |\n    }                                                         |\n    metadata_payload_type                                     | u(8)\n    payloadType += metadata_payload_type                      |\n    currReadSize++                                            |\n                                                              |\n    payloadSize = 0                                           |\n    while(next_bits(8) == 0xFF){                              |\n      ff_byte                                                 | f(8)\n      payloadSize += ff_byte                                  |\n      currReadSize++                                          |\n    }                                                         |\n    metadata_payload_size                                     | u(8)\n    payloadSize += metadata_payload_size                      |\n    currReadSize++                                            |\n                                                              |\n    metadata_payload(payloadType, payloadSize)                |\n    currReadSize += payloadSize                               |\n  } while(metadata_size > currReadSize)                       |\n  filler()                                                    |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 17: metadata() syntax code",
      "ja": "図 17:metadata() 構文コード"
    },
    {
      "indent": 3,
      "text": "metadata_size",
      "ja": "メタデータのサイズ"
    },
    {
      "indent": 12,
      "text": "specifies the size of metadata before filler() in the current PBU.",
      "ja": "現在の PBU 内の filler() の前のメタデータのサイズを指定します。"
    },
    {
      "indent": 3,
      "text": "ff_byte",
      "ja": "ff_バイト"
    },
    {
      "indent": 12,
      "text": "is a byte equal to 0xFF.",
      "ja": "は 0xFF に等しいバイトです。"
    },
    {
      "indent": 3,
      "text": "metadata_payload_type",
      "ja": "メタデータペイロードタイプ"
    },
    {
      "indent": 12,
      "text": "specifies the last byte of the payload type of a metadata.",
      "ja": "メタデータのペイロード タイプの最後のバイトを指定します。"
    },
    {
      "indent": 3,
      "text": "metadata_payload_size",
      "ja": "メタデータペイロードサイズ"
    },
    {
      "indent": 12,
      "text": "specifies the last byte of the payload size of a metadata.",
      "ja": "メタデータのペイロード サイズの最後のバイトを指定します。"
    },
    {
      "indent": 3,
      "text": "Syntax and semantics of metadata_payload() are specified in Section 8.",
      "ja": "metadata_payload() の構文とセマンティクスはセクション 8 で規定されています。"
    },
    {
      "indent": 0,
      "text": "5.3.11. Filler",
      "section_title": true,
      "ja": "5.3.11. フィラー"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nfiller(){                                                     |\n  while(next_bits(8) == 0xFF)                                 |\n    ff_byte                                                   | f(8)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 18: filler() syntax code",
      "ja": "図 18: filler() 構文コード"
    },
    {
      "indent": 3,
      "text": "ff_byte",
      "ja": "ff_バイト"
    },
    {
      "indent": 12,
      "text": "is a byte equal to 0xFF.",
      "ja": "は 0xFF に等しいバイトです。"
    },
    {
      "indent": 0,
      "text": "5.3.12. Tile",
      "section_title": true,
      "ja": "5.3.12. タイル"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\ntile(tileIdx){                                                |\n  tile_header(tileIdx)                                        |\n  for(i = 0; i < NumComps; i++){                              |\n    tile_data(tileIdx, i)                                     |\n  }                                                           |\n  while(more_data_in_tile()){                                 |\n    tile_dummy_byte                                           | b(8)\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 19: tile() syntax code",
      "ja": "図 19: tile() 構文コード"
    },
    {
      "indent": 3,
      "text": "tile_dummy_byte",
      "ja": "タイル_ダミー_バイト"
    },
    {
      "indent": 12,
      "text": "has any pattern of 8-bit string.",
      "ja": "8 ビット文字列の任意のパターンを持ちます。"
    },
    {
      "indent": 0,
      "text": "5.3.13. Tile Header",
      "section_title": true,
      "ja": "5.3.13. タイルヘッダー"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\ntile_header(tileIdx){                                         |\n  tile_header_size                                            | u(16)\n  tile_index                                                  | u(16)\n  for(i = 0; i < NumComps; i++){                              |\n    tile_data_size[i]                                         | u(32)\n  }                                                           |\n  for(i = 0; i < NumComps; i++){                              |\n    tile_qp[i]                                                | u(8)\n  }                                                           |\n  reserved_zero_8bits                                         | u(8)\n  byte_alignment()                                            |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 20: tile_header() syntax code",
      "ja": "図 20: tile_header() 構文コード"
    },
    {
      "indent": 3,
      "text": "tile_header_size",
      "ja": "タイルヘッダーサイズ"
    },
    {
      "indent": 12,
      "text": "indicates the size of the tile header in bytes.",
      "ja": "タイルヘッダーのサイズをバイト単位で示します。"
    },
    {
      "indent": 3,
      "text": "tile_index",
      "ja": "タイルインデックス"
    },
    {
      "indent": 12,
      "text": "specifies the tile index in raster order in a frame. tile_index MUST have the same value as tileIdx.",
      "ja": "フレーム内のラスター順にタイル インデックスを指定します。tile_index は、tileIdx と同じ値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "tile_data_size[i]",
      "ja": "タイルデータサイズ[i]"
    },
    {
      "indent": 12,
      "text": "indicates the size of the i-th color component data in a tile in bytes. The array index i specifies an indicator for the color component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The value of 0 for tile_data_size[i] is reserved for future use.",
      "ja": "タイル内の i 番目の色成分データのサイズをバイト単位で示します。配列インデックス i は、色コンポーネントのインジケーターを指定します。chroma_format_idc が 2 または 3 に等しい場合、インデックス i の値は、Y コンポーネントの場合は 0、Cb の場合は 1、Cr の場合は 2 に等しくなります。tile_data_size[i] の値 0 は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "tile_qp[i]",
      "ja": "タイル_qp[i]"
    },
    {
      "indent": 12,
      "text": "specifies the quantization parameter value for i-th color component. The array index i specifies an indicator for the color component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The Qp[i] to be used for the MBs in the tile are derived as follows:",
      "ja": "i 番目の色成分の量子化パラメータ値を指定します。配列インデックス i は、色コンポーネントのインジケーターを指定します。chroma_format_idc が 2 または 3 に等しい場合、インデックス i の値は、Y コンポーネントの場合は 0、Cb の場合は 1、Cr の場合は 2 に等しくなります。タイル内の MB に使用される Qp[i] は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* Qp[i] = tile_qp[i] - QpBdOffset",
      "ja": "* Qp[i] = tile_qp[i] - QpBdOffset"
    },
    {
      "indent": 6,
      "text": "* Qp[i] MUST be in the range of -QpBdOffset to 51, inclusive.",
      "ja": "* Qp[i] は、-QpBdOffset から 51 までの範囲内でなければなりません (両端の値を含む)。"
    },
    {
      "indent": 3,
      "text": "reserved_zero_8bits",
      "ja": "予約済み_zero_8bits"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0 in bitstreams conforming to the profiles specified in Section 9. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in Section 9 MUST ignore PBU with values of reserved_zero_8bits greater than 0.",
      "ja": "セクション9で指定されたプロファイルに準拠するビットストリームでは、0に等しくなければなりません。0より大きいreserved_zero_8bitsの値は、将来の使用のために予約されています。セクション9で指定されたプロファイルに準拠するデコーダは、reserved_zero_8bitsの値が0より大きいPBUを無視しなければなりません(MUST)。"
    },
    {
      "indent": 0,
      "text": "5.3.14. Tile Data",
      "section_title": true,
      "ja": "5.3.14. タイルデータ"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\ntile_data(tileIdx, cIdx){                                     |\n  x0 = ColStarts[tileIdx % TileCols]                          |\n  y0 = RowStarts[tileIdx // TileCols]                         |\n  numMbColsInTile = (ColStarts[tileIdx % TileCols + 1] -      |\n          ColStarts[tileIdx % TileCols]) // MbWidth           |\n  numMbRowsInTile = (RowStarts[tileIdx // TileCols + 1] -     |\n          RowStarts[tileIdx // TileCols]) // MbHeight         |\n  numMbsInTile = numMbColsInTile * numMbRowsInTile            |\n  PrevDC = 0                                                  |\n  PrevDcDiff = 20                                             |\n  Prev1stAcLevel = 0                                          |\n  for(i = 0; i < numMbsInTile; i++){                          |\n    xMb = x0 + ((i % numMbColsInTile) * MbWidth)              |\n    yMb = y0 + ((i // numMbColsInTile) * MbHeight)            |\n    macroblock_layer(xMb, yMb, cIdx)                          |\n  }                                                           |\n  byte_alignment()                                            |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 21: tile_data() syntax code",
      "ja": "図 21: tile_data() 構文コード"
    },
    {
      "indent": 3,
      "text": "The tile_data() syntax calculates the location of the macroblocks belonging to each tile and collects them.",
      "ja": "tile_data() 構文は、各タイルに属するマクロブロックの位置を計算し、それらを収集します。"
    },
    {
      "indent": 0,
      "text": "5.3.15. Macroblock Layer",
      "section_title": true,
      "ja": "5.3.15. マクロブロックレイヤー"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmacroblock_layer(xMb, yMb, cIdx){                             |\n  subW = (cIdx == 0)? 1 : SubWidthC                           |\n  subH = (cIdx == 0)? 1 : SubHeightC                          |\n  blkWidth = (cIdx == 0)? MbWidth : MbWidthC                  |\n  blkHeight = (cIdx == 0)? MbHeight : MbHeightC               |\n  TrSize = 8                                                  |\n  for(y = 0; y < blkHeight; y += TrSize){                     |\n    for(x = 0; x < blkWidth; x += TrSize){                    |\n      abs_dc_coeff_diff                                       | h(v)\n      if(abs_dc_coeff_diff)                                   |\n        sign_dc_coeff_diff                                    | u(1)\n      TransCoeff[cIdx][xMb // subW + x][yMb // subH + y] =    |\n            PrevDC + abs_dc_coeff_diff *                      |\n            (1 - 2*sign_dc_coeff_diff)                        |\n      PrevDC =                                                |\n        TransCoeff[cIdx][xMb // subW + x][yMb // subH + y]    |\n      PrevDcDiff = abs_dc_coeff_diff                          |\n      ac_coeff_coding(xMb // subW + x, yMb // subH + y,       |\n            log2(TrSize), log2(TrSize), cIdx)                 |\n    }                                                         |\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 22: macroblock_layer() syntax code",
      "ja": "図 22:macroblock_layer() 構文コード"
    },
    {
      "indent": 3,
      "text": "abs_dc_coeff_diff",
      "ja": "abs_dc_coeff_diff"
    },
    {
      "indent": 12,
      "text": "specifies the absolute value of the difference between the current DC transform coefficient level and PrevDC.",
      "ja": "現在の DC 変換係数レベルと PrevDC の差の絶対値を指定します。"
    },
    {
      "indent": 3,
      "text": "sign_dc_coeff_diff",
      "ja": "サイン_dc_coeff_diff"
    },
    {
      "indent": 12,
      "text": "specifies the sign of the difference between the current DC transform coefficient level and PrevDC. sign_dc_coeff_diff equal to 0 specifies that the difference has a positive value. sign_dc_coeff_diff equal to 1 specifies that the difference has a negative value.",
      "ja": "現在の DC 変換係数レベルと PrevDC の差の符号を指定します。0 に等しいsign_dc_coeff_diff は、差が正の値であることを指定します。1 に等しいsign_dc_coeff_diff は、差が負の値であることを指定します。"
    },
    {
      "indent": 3,
      "text": "The transform coefficients are represented by the arrays TransCoeff[cIdx][x0][y0]. The array indices x0, y0 specify the location (x0, y0) relative to the top-left sample for each component of the frame. The array index cIdx specifies an indicator for the color component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The value of TransCoeff[cIdx][x0][y0] MUST be in the range of -32768 to 32767, inclusive.",
      "ja": "変換係数は、配列 TransCoeff[cIdx][x0][y0] で表されます。配列インデックス x0、y0 は、フレームの各コンポーネントの左上のサンプルを基準とした位置 (x0、y0) を指定します。配列インデックス cIdx は、色コンポーネントのインジケーターを指定します。chroma_format_idc が 2 または 3 に等しい場合、インデックス i の値は、Y コンポーネントの場合は 0、Cb の場合は 1、Cr の場合は 2 に等しくなります。TransCoeff[cIdx][x0][y0] の値は、-32768 ～ 32767 の範囲内でなければなりません (両端の値を含む)。"
    },
    {
      "indent": 0,
      "text": "5.3.16. AC Coefficient Coding",
      "section_title": true,
      "ja": "5.3.16. AC係数コーディング"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nac_coeff_coding(x0, y0, log2BlkWidth, log2BlkHeight, cIdx){   |\n  scanPos = 1                                                 |\n  firstAC = 1                                                 |\n  PrevLevel = Prev1stAcLevel                                  |\n  PrevRun = 0                                                 |\n  do{                                                         |\n    coeff_zero_run                                            | h(v)\n    for(i = 0; i < coeff_zero_run; i++){                      |\n      blkPos = ScanOrder[scanPos]                             |\n      xC = blkPos & ((1 << log2BlkWidth) - 1)                 |\n      yC = blkPos >> log2BlkWidth                             |\n      TransCoeff[cIdx][x0+xC][y0 + yC] = 0                    |\n      scanPos++                                               |\n    }                                                         |\n    PrevRun = coeff_zero_run                                  |\n    if(scanPos < (1 << (log2BlkWidth + log2BlkHeight))){      |\n      abs_ac_coeff_minus1                                     | h(v)\n      sign_ac_coeff                                           | u(1)\n      level = (abs_ac_coeff_minus1 + 1) *                     |\n        (1 - 2 * sign_ac_coeff)                               |\n      blkPos = ScanOrder[scanPos]                             |\n      xC = blkPos & ((1 << log2BlkWidth) - 1)                 |\n      yC = blkPos >> log2BlkWidth                             |\n      TransCoeff[cIdx][x0 + xC][y0 + yC] = level              |\n      scanPos++                                               |\n      PrevLevel = abs_ac_coeff_minus1 + 1                     |\n      if(firstAC == 1){                                       |\n        firstAC = 0                                           |\n        Prev1stAcLevel = PrevLevel                            |\n      }                                                       |\n    }                                                         |\n  } while(scanPos < (1 << (log2BlkWidth + log2BlkHeight)))    |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 23: ac_coeff_coding() syntax code",
      "ja": "図 23: ac_coeff_coding() 構文コード"
    },
    {
      "indent": 3,
      "text": "coeff_zero_run",
      "ja": "coeff_zero_run"
    },
    {
      "indent": 12,
      "text": "specifies the number of zero-valued transform coefficient levels that are located before the position of the next non-zero transform coefficient level in a scan of transform coefficient levels.",
      "ja": "変換係数レベルのスキャンにおいて、次の非ゼロ変換係数レベルの位置の前に位置するゼロ値の変換係数レベルの数を指定します。"
    },
    {
      "indent": 3,
      "text": "abs_ac_coeff_minus1",
      "ja": "abs_ac_coeff_minus1"
    },
    {
      "indent": 12,
      "text": "plus 1 specifies the absolute value of an AC transform coefficient level at the given scanning position.",
      "ja": "プラス 1 は、指定されたスキャン位置での AC 変換係数レベルの絶対値を指定します。"
    },
    {
      "indent": 3,
      "text": "sign_ac_coeff",
      "ja": "サイン_ac_coeff"
    },
    {
      "indent": 12,
      "text": "specifies the sign of an AC transform coefficient level for the given scanning position. sign_ac_coeff equal to 0 specifies that the corresponding AC transform coefficient level has a positive value. sign_ac_coeff equal to 1 specifies that the corresponding AC transform coefficient level has a negative value.",
      "ja": "指定されたスキャン位置の AC 変換係数レベルの符号を指定します。０に等しいｓｉｇｎ＿ａｃ＿ｃｏｅｆｆは、対応するＡＣ変換係数レベルが正の値を持つことを指定する。１に等しいｓｉｇｎ＿ａｃ＿ｃｏｅｆｆは、対応するＡＣ変換係数レベルが負の値を持つことを指定する。"
    },
    {
      "indent": 3,
      "text": "The array ScanOrder[sPos] specifies the mapping of the zig-zag scan position sPos, ranging from 0 to (1 << log2BlkWidth) * (1 << log2BlkHeight) - 1, inclusive, to a raster scan position rPos. ScanOrder is derived by invoking Section 4.4.1 with input parameters blkWidth equal to (1 << log2BlkWidth) and blkHeight equal to (1 << log2BlkHeight).",
      "ja": "配列 ScanOrder[sPos] は、ジグザグ スキャン位置 sPos のマッピングを指定します。範囲は 0 ～ (1 << log2BlkWidth) * (1 << log2BlkHeight) - 1 (両端の値を含む) で、ラスター スキャン位置 rPos までです。ScanOrder は、(1 << log2BlkWidth) に等しい入力パラメータ blkWidth および (1 << log2BlkHeight) に等しい blkHeight を使用してセクション 4.4.1 を呼び出すことによって導出されます。"
    },
    {
      "indent": 0,
      "text": "5.3.17. Byte Alignment",
      "section_title": true,
      "ja": "5.3.17. バイトアライメント"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nbyte_alignment(){                                             |\n  while(!byte_aligned())                                      |\n    alignment_bit_equal_to_zero                               | f(1)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 24: byte_alignment() syntax code",
      "ja": "図 24: byte_alignment() 構文コード"
    },
    {
      "indent": 3,
      "text": "alignment_bit_equal_to_zero",
      "ja": "アラインメントビットがゼロに等しい"
    },
    {
      "indent": 12,
      "text": "MUST be equal to 0.",
      "ja": "0に等しくなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Decoding Process",
      "section_title": true,
      "ja": "6. デコード処理"
    },
    {
      "indent": 3,
      "text": "This process is invoked to obtain a decoded frame from a bitstream. Input to this process is a bitstream of a coded frame. Output of this process is a decoded frame.",
      "ja": "このプロセスは、ビットストリームからデコードされたフレームを取得するために呼び出されます。このプロセスへの入力は、コード化されたフレームのビットストリームです。このプロセスの出力は、デコードされたフレームです。"
    },
    {
      "indent": 3,
      "text": "The decoding process operates as follows for the current frame:",
      "ja": "デコード プロセスは、現在のフレームに対して次のように動作します。"
    },
    {
      "indent": 6,
      "text": "* The syntax structure for a coded frame is parsed to obtain the parsed syntax structures.",
      "ja": "* コード化されたフレームの構文構造が解析されて、解析された構文構造が取得されます。"
    },
    {
      "indent": 6,
      "text": "* The processes in Sections 6.1, 6.2, and 6.3 specify the decoding processes using syntax elements in all syntax structures. For bitstreams conforming to this document, the coded tiles of the frame MUST contain tile data for every MB of the frame, such that the division of the frame into tiles and the division of the tiles into MBs form a partitioning of the frame.",
      "ja": "* セクション 6.1、6.2、および 6.3 のプロセスは、すべての構文構造の構文要素を使用して復号化プロセスを指定します。この文書に準拠するビットストリームの場合、フレームの符号化されたタイルには、フレームのタイルへの分割とタイルの MB への分割がフレームの分割を形成するように、フレームのすべての MB のタイル データが含まれなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* After all the tiles in the current frame have been decoded, the decoded frame is cropped using the cropping rectangle if FrameWidthInSamplesY is not equal to FrameWidthInMbsY * MbWidth or FrameHeightInSamplesY is not equal to FrameHeightInMbsY * MbHeight.",
      "ja": "* 現在のフレーム内のすべてのタイルがデコードされた後、FrameWidthInSamplesY が FrameWidthInMbsY * MbWidth に等しくない、または FrameHeightInSamplesY が FrameHeightInMbsY * MbHeight に等しくない場合、デコードされたフレームはトリミング四角形を使用してトリミングされます。"
    },
    {
      "indent": 6,
      "text": "* The cropping rectangle, which specifies the samples of a frame that are output, is derived as follows:",
      "ja": "* 出力されるフレームのサンプルを指定するトリミング四角形は、次のように導出されます。"
    },
    {
      "indent": 12,
      "text": "- The cropping rectangle contains the luma samples with horizontal frame coordinates from 0 to FrameWidthInSampleY - 1 and vertical frame coordinates from 0 to FrameHeightInSamplesY - 1, inclusive.",
      "ja": "- トリミング四角形には、0 ～ FrameWidthInSampleY - 1 の水平フレーム座標と 0 ～ FrameHeightInSamplesY - 1 の垂直フレーム座標を持つ輝度サンプルが含まれます。"
    },
    {
      "indent": 12,
      "text": "- The cropping rectangle contains the two chroma arrays having frame coordinates (x//SubWidthC, y//SubHeightC), where (x,y) are the frame coordinates of the specified luma samples.",
      "ja": "- トリミング四角形には、フレーム座標 (x//SubWidthC, y//SubHeightC) を持つ 2 つのクロマ配列が含まれています。ここで、(x,y) は指定された輝度サンプルのフレーム座標です。"
    },
    {
      "indent": 0,
      "text": "6.1. MB Decoding Process",
      "section_title": true,
      "ja": "6.1. MB デコード処理"
    },
    {
      "indent": 3,
      "text": "This process is invoked for each MB.",
      "ja": "このプロセスは MB ごとに呼び出されます。"
    },
    {
      "indent": 3,
      "text": "Input to this process is a luma location (xMb, yMb) specifying the top-left sample of the current luma MB relative to the top-left luma sample of the current frame. Outputs of this process are the reconstructed samples of all color components. The total number of color components is indicated by the value of NumComps for the current MB. For example, when chroma_format_idc is equal to 2 or 3, the value of NumComps is equal to 3 and three components, Y component, Cb component, and Cr component, are reconstructed",
      "ja": "このプロセスへの入力は、現在のフレームの左上の輝度サンプルを基準とした現在の輝度 MB の左上のサンプルを指定する輝度位置 (xMb、yMb) です。このプロセスの出力は、すべての色成分の再構成されたサンプルです。カラーコンポーネントの総数は、現在の MB の NumComps の値によって示されます。たとえば、chroma_format_idc が 2 または 3 の場合、NumComps の値は 3 に等しく、Y 成分、Cb 成分、Cr 成分の 3 つの成分が再構築されます。"
    },
    {
      "indent": 3,
      "text": "The following steps apply:",
      "ja": "次の手順が適用されます。"
    },
    {
      "indent": 6,
      "text": "* Let recSamples[0] be a (MbWidth)x(MbHeight) array of the reconstructed samples of the first color component (when chroma_format_idc is equal to 2 or 3, Y).",
      "ja": "* recSamples[0] を、最初の色成分の再構成サンプルの (MbWidth)x(MbHeight) 配列とします (chroma_format_idc が 2 または 3、Y に等しい場合)。"
    },
    {
      "indent": 6,
      "text": "* The block reconstruction process as specified in Section 6.2 is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidth, the variable nBlkH set equal to MbHeight, the variable cIdx set equal to 0, and the (MbWidth)x(MbHeight) array recSamples[0] as inputs. The output is a modified version of the (MbWidth)x(MbHeight) array recSamples[0], which is the reconstructed samples of the first color component for the current MB.",
      "ja": "* セクション 6.2 で指定されているブロック再構成プロセスは、輝度位置 (xMb, yMb)、MbWidth に等しく設定された変数 nBlkW、MbHeight に等しく設定された変数 nBlkH、0 に等しく設定された変数 cIdx、および (MbWidth)x(MbHeight) 配列 recSamples[0] を入力として呼び出されます。出力は、(MbWidth)x(MbHeight) 配列 recSamples[0] の修正バージョンであり、現在の MB の最初の色成分の再構築されたサンプルです。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is not equal to 0, let recSamples[1] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the second color component. For example, when chroma_format_idc is equal to 2 or 3, recSamples[1] is the Cb color component.",
      "ja": "* chroma_format_idc が 0 に等しくない場合、recSamples[1] を 2 番目の色成分の再構成サンプルの (MbWidthC)x(MbHeightC) 配列とします。たとえば、chroma_format_idc が 2 または 3 に等しい場合、recSamples[1] は Cb カラー コンポーネントになります。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is not equal to 0, the block reconstruction process as specified in Section 6.2 is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 1, and the (MbWidthC)x(MbHeightC) array recSamples[1] as inputs. The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[1], which is the reconstructed samples of the second color component for the current MB.",
      "ja": "* chroma_format_idc が 0 に等しくない場合、セクション 6.2 で指定されているブロック再構成プロセスが、輝度位置 (xMb, yMb)、MbWidthC に等しく設定された変数 nBlkW、MbHeightC に等しく設定された変数 nBlkH、1 に等しく設定された変数 cIdx、および (MbWidthC)x(MbHeightC) 配列 recSamples[1] を入力として呼び出されます。出力は、(MbWidthC)x(MbHeightC) 配列 recSamples[1] の修正バージョンであり、現在の MB の 2 番目の色成分の再構築されたサンプルです。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is not equal to 0, let recSamples[2] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the third color component. For example, when chroma_format_idc is equal to 2 or 3, recSamples[2] is the Cr color component.",
      "ja": "* chroma_format_idc が 0 に等しくない場合、recSamples[2] を 3 番目の色成分の再構成サンプルの (MbWidthC)x(MbHeightC) 配列とします。たとえば、chroma_format_idc が 2 または 3 の場合、recSamples[2] は Cr カラー コンポーネントになります。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is not equal to 0, the block reconstruction process as specified in Section 6.2 is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 2, and the (MbWidthC)x(MbHeightC) array recSamples[2] as inputs. The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[2], which is the reconstructed samples of the third color component for the current MB.",
      "ja": "* chroma_format_idc が 0 に等しくない場合、セクション 6.2 で指定されているブロック再構成プロセスが、輝度位置 (xMb, yMb)、MbWidthC に等しく設定された変数 nBlkW、MbHeightC に等しく設定された変数 nBlkH、2 に等しく設定された変数 cIdx、および (MbWidthC)x(MbHeightC) 配列 recSamples[2] を入力として呼び出されます。出力は、(MbWidthC)x(MbHeightC) 配列 recSamples[2] の修正バージョンであり、現在の MB の 3 番目の色コンポーネントの再構築されたサンプルです。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is equal to 4, let recSamples[3] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the fourth color component.",
      "ja": "* chroma_format_idc が 4 に等しい場合、recSamples[3] を 4 番目の色成分の再構成サンプルの (MbWidthC)x(MbHeightC) 配列とします。"
    },
    {
      "indent": 6,
      "text": "* When chroma_format_idc is equal to 4, the block reconstruction process as specified in Section 6.2 is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 3, and the (MbWidthC)x(MbHeightC) array recSamples[3] as inputs. The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[3], which is the reconstructed samples of the fourth color component for the current MB.",
      "ja": "* chroma_format_idc が 4 に等しい場合、セクション 6.2 で指定されているブロック再構築プロセスが、輝度位置 (xMb, yMb)、MbWidthC に設定された変数 nBlkW、MbHeightC に設定された変数 nBlkH、3 に設定された変数 cIdx、および (MbWidthC)x(MbHeightC) 配列 recSamples[3] を入力として呼び出されます。出力は、(MbWidthC)x(MbHeightC) 配列 recSamples[3] の修正バージョンであり、現在の MB の 4 番目の色コンポーネントの再構築されたサンプルです。"
    },
    {
      "indent": 0,
      "text": "6.2. Block Reconstruction Process",
      "section_title": true,
      "ja": "6.2. ブロック再構築プロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a luma location (xMb, yMb) specifying the top-left sample of the current MB relative to the top-left luma sample of the current frame,",
      "ja": "* 現在のフレームの左上の輝度サンプルを基準とした現在の MB の左上のサンプルを指定する輝度位置 (xMb、yMb)、"
    },
    {
      "indent": 6,
      "text": "* two variables nBlkW and nBlkH specifying the width and the height of the current block,",
      "ja": "* 現在のブロックの幅と高さを指定する 2 つの変数 nBlkW と nBlkH、"
    },
    {
      "indent": 6,
      "text": "* a variable cIdx specifying the color component of the current block, and",
      "ja": "* 現在のブロックの色コンポーネントを指定する変数 cIdx、および"
    },
    {
      "indent": 6,
      "text": "* an (nBlkW)x(nBlkH) array of recSamples of a reconstructed block.",
      "ja": "* 再構成されたブロックの recSamples の (nBlkW)x(nBlkH) 配列。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a modified version of the (nBlkW)x(nBlkH) array recSamples of reconstructed samples.",
      "ja": "このプロセスの出力は、再構成されたサンプルの (nBlkW)x(nBlkH) 配列 recSamples の修正バージョンです。"
    },
    {
      "indent": 3,
      "text": "The following applies:",
      "ja": "以下が適用されます。"
    },
    {
      "indent": 6,
      "text": "* The variables numBlkX and numBlkY are derived as follows:",
      "ja": "* 変数 numBlkX と numBlkY は次のように導出されます。"
    },
    {
      "indent": 12,
      "text": "- numBlkX = nBlkW // TrSize",
      "ja": "- numBlkX = nBlkW // TrSize"
    },
    {
      "indent": 12,
      "text": "- numBlkY = nBlkH // TrSize",
      "ja": "- numBlkY = nBlkH // TrSize"
    },
    {
      "indent": 6,
      "text": "* For yIdx = 0..numBlkY - 1, the following applies:",
      "ja": "* yIdx = 0..numBlkY - 1 の場合、次が適用されます。"
    },
    {
      "indent": 12,
      "text": "- For xIdx = 0..numBlkX - 1, the following applies:",
      "ja": "- xIdx = 0..numBlkX - 1 の場合、次が適用されます。"
    },
    {
      "indent": 18,
      "text": "o The variables xBlk and yBlk are derived as follows:",
      "ja": "o 変数 xBlk と yBlk は次のように導出されます。"
    },
    {
      "indent": 24,
      "text": "+ xBlk = xMb // (cIdx==0? 1: SubWidthC) + xIdx*TrSize",
      "ja": "+ xBlk = xMb // (cIdx==0? 1: SubWidthC) + xIdx*TrSize"
    },
    {
      "indent": 24,
      "text": "+ yBlk = yMb // (cIdx==0? 1: SubHeightC) + yIdx*TrSize",
      "ja": "+ yBlk = yMb // (cIdx==0? 1: SubHeightC) + yIdx*TrSize"
    },
    {
      "indent": 18,
      "text": "o The scaling and transformation process as specified in Section 6.3 is invoked with the location (xBlk, yBlk), the variable cIdx set equal to cIdx, the transform width nBlkW set equal to TrSize, and the transform height nBlkH set equal to TrSize as inputs. The output is a (TrSize)x(TrSize) array r of a reconstructed block.",
      "ja": "o セクション 6.3 で指定されているスケーリングおよび変換プロセスは、位置 (xBlk, yBlk)、cIdx に等しく設定された変数 cIdx、TrSize に等しく設定された変換幅 nBlkW、および TrSize に等しく設定された変換高さ nBlkH を入力として呼び出されます。出力は、再構成されたブロックの (TrSize)x(TrSize) 配列 r です。"
    },
    {
      "indent": 18,
      "text": "o The (TrSize)x(TrSize) array recSamples is modified as follows:",
      "ja": "o (TrSize)x(TrSize) 配列 recSamples は次のように変更されます。"
    },
    {
      "indent": 24,
      "text": "+ recSamples[(xIdx * TrSize) + i, (yIdx * TrSize) + j] = r[i,j], with i=0..TrSize-1, j=0..TrSize-1",
      "ja": "+ recSamples[(xIdx * TrSize) + i, (yIdx * TrSize) + j] = r[i,j]、i=0..TrSize-1、j=0..TrSize-1"
    },
    {
      "indent": 0,
      "text": "6.3. Scaling and Transformation Process",
      "section_title": true,
      "ja": "6.3. スケーリングと変換のプロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,",
      "ja": "* 現在のフレームの左上のサンプルを基準とした現在のブロックの左上のサンプルを指定する現在のカラー コンポーネントの位置 (xBlkY、yBlkY)、"
    },
    {
      "indent": 6,
      "text": "* a variable cIdx specifying the color component of the current block,",
      "ja": "* 現在のブロックの色コンポーネントを指定する変数 cIdx、"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkW specifying the width of the current block, and",
      "ja": "* 現在のブロックの幅を指定する変数 nBlkW、および"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkH specifying the height of the current block.",
      "ja": "* 現在のブロックの高さを指定する変数 nBlkH。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the (nBlkW)x(nBlkH) array of reconstructed samples r with elements r[x][y].",
      "ja": "このプロセスの出力は、要素 r[x][y] を含む再構成されたサンプル r の (nBlkW)x(nBlkH) 配列です。"
    },
    {
      "indent": 3,
      "text": "The quantization parameter qP is derived as follows:",
      "ja": "量子化パラメータ qP は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* qP = Qp[cIdx] + QpBdOffset",
      "ja": "* qP = Qp[cIdx] + QpBdOffset"
    },
    {
      "indent": 3,
      "text": "The (nBlKW)x(nBlkH) array of reconstructed samples r is derived as follows:",
      "ja": "再構成されたサンプル r の (nBlKW)x(nBlkH) 配列は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* The scaling process for transform coefficients as specified in Section 6.3.1 is invoked with the block location (xBlkY, yBlkY), the block width nBlkW and the block height nBlkH, the color component variable cIdx, and the quantization parameter qP as inputs. The output is an (nBlkW)x(nBlkH) array of scaled transform coefficients d.",
      "ja": "* セクション 6.3.1 で指定された変換係数のスケーリング プロセスは、ブロック位置 (xBlkY、yBlkY)、ブロック幅 nBlkW およびブロック高さ nBlkH、色成分変数 cIdx、および量子化パラメータ qP を入力として呼び出されます。出力は、スケーリングされた変換係数 d の (nBlkW)x(nBlkH) 配列です。"
    },
    {
      "indent": 6,
      "text": "* The transformation process for scaled transform coefficients as specified in Section 6.3.2 is invoked with the block location (xBlkY, yBlkY), the block width nBlkW and the block height nBlkH, the color component variable cIdx, and the (nBlkW)x(nBlkH) array of scaled transform coefficients d as inputs. The output is an (nBlkW)x(nBlkH) array of reconstructed samples r.",
      "ja": "* セクション 6.3.2 で指定されているスケーリングされた変換係数の変換プロセスは、ブロック位置 (xBlkY, yBlkY)、ブロック幅 nBlkW およびブロック高さ nBlkH、色成分変数 cIdx、およびスケーリングされた変換係数 d の (nBlkW)x(nBlkH) 配列を入力として呼び出します。出力は、再構成されたサンプル r の (nBlkW)x(nBlkH) 配列です。"
    },
    {
      "indent": 6,
      "text": "* The variable bdShift is derived as follows:",
      "ja": "* 変数 bdShift は次のように導出されます。"
    },
    {
      "indent": 12,
      "text": "- bdShift = 20 - BitDepth",
      "ja": "- bdShift = 20 - ビット深度"
    },
    {
      "indent": 6,
      "text": "* The reconstructed sample values r[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 are modified as follows:",
      "ja": "* x = 0..nBlkW - 1、y = 0..nBlkH - 1 の再構成されたサンプル値 r[x][y] は次のように変更されます。"
    },
    {
      "indent": 12,
      "text": "- r[x][y] = clip(0, (1 << BitDepth)-1, ((r[x][y]+(1 << (bdShift-1)))>>bdShift) + (1 << (BitDepth-1)))",
      "ja": "- r[x][y] = クリップ(0, (1 << BitDepth)-1, ((r[x][y]+(1 << (bdShift-1)))>>bdShift) + (1 << (BitDepth-1)))"
    },
    {
      "indent": 0,
      "text": "6.3.1. Scaling Process for Transform Coefficients",
      "section_title": true,
      "ja": "6.3.1. 変換係数のスケーリング プロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,",
      "ja": "* 現在のフレームの左上のサンプルを基準とした現在のブロックの左上のサンプルを指定する現在のカラー コンポーネントの位置 (xBlkY、yBlkY)、"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkW specifying the width of the current block,",
      "ja": "* 現在のブロックの幅を指定する変数 nBlkW、"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkH specifying the height of the current block,",
      "ja": "* 現在のブロックの高さを指定する変数 nBlkH、"
    },
    {
      "indent": 6,
      "text": "* a variable cIdx specifying the color component of the current block, and",
      "ja": "* 現在のブロックの色コンポーネントを指定する変数 cIdx、および"
    },
    {
      "indent": 6,
      "text": "* a variable qP specifying the quantization parameter.",
      "ja": "* 量子化パラメータを指定する変数 qP。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the (nBlkW)x(nBlkH) array d of scaled transform coefficients with elements d[x][y].",
      "ja": "このプロセスの出力は、要素 d[x][y] を持つスケーリングされた変換係数の (nBlkW)x(nBlkH) 配列 d です。"
    },
    {
      "indent": 3,
      "text": "The variable bdShift is derived as follows:",
      "ja": "変数 bdShift は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* bdShift = BitDepth + ((log2(nBlkW) + log2(nBlkH)) // 2) - 5",
      "ja": "* bdShift = BitDepth + ((log2(nBlkW) + log2(nBlkH)) // 2) - 5"
    },
    {
      "indent": 3,
      "text": "The list levelScale[] is specified as follows:",
      "ja": "リスト levelScale[] は次のように指定されます。"
    },
    {
      "indent": 6,
      "text": "* levelScale[k] = {40, 45, 51, 57, 64, 71} with k = 0..5.",
      "ja": "* levelScale[k] = {40, 45, 51, 57, 64, 71}、k = 0..5。"
    },
    {
      "indent": 3,
      "text": "For the derivation of the scaled transform coefficients d[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1, the following applies:",
      "ja": "x = 0..nBlkW - 1、y = 0..nBlkH - 1 でのスケーリングされた変換係数 d[x][y] の導出には、以下が適用されます。"
    },
    {
      "indent": 6,
      "text": "* The scaled transform coefficient d[x][y] is derived as follows:",
      "ja": "* スケーリングされた変換係数 d[x][y] は次のように導出されます。"
    },
    {
      "indent": 12,
      "text": "- d[x][y] = clip(-32768, 32767, ((TransCoeff[cIdx][xBlkY][yBlkY] * QMatrix[cIdx][x][y] * levelScale[qP % 6] << (qP//6)) + (1 << (bdShift-1)) >> bdShift))",
      "ja": "- d[x][y] = Clip(-32768, 32767, ((TransCoeff[cIdx][xBlkY][yBlkY] * QMatrix[cIdx][x][y] * levelScale[qP % 6] << (qP//6)) + (1 << (bdShift-1)) >> bdShift))"
    },
    {
      "indent": 0,
      "text": "6.3.2. Process for Scaled Transform Coefficients",
      "section_title": true,
      "ja": "6.3.2. スケーリングされた変換係数のプロセス"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. General",
      "section_title": true,
      "ja": "6.3.2.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,",
      "ja": "* 現在のフレームの左上のサンプルを基準とした現在のブロックの左上のサンプルを指定する現在のカラー コンポーネントの位置 (xBlkY、yBlkY)、"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkW specifying the width of the current block,",
      "ja": "* 現在のブロックの幅を指定する変数 nBlkW、"
    },
    {
      "indent": 6,
      "text": "* a variable nBlkH specifying the height of the current block, and",
      "ja": "* 現在のブロックの高さを指定する変数 nBlkH、および"
    },
    {
      "indent": 6,
      "text": "* an (nBlkW)x(nBlkH) array d of scaled transform coefficients with elements d[x][y].",
      "ja": "* 要素 d[x][y] を持つスケーリングされた変換係数の (nBlkW)x(nBlkH) 配列 d。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the (nBlkW)x(nBlkH) array r of reconstructed samples with elements r[x][y].",
      "ja": "このプロセスの出力は、要素 r[x][y] を含む再構成されたサンプルの (nBlkW)x(nBlkH) 配列 r です。"
    },
    {
      "indent": 3,
      "text": "The (nBlkW)x(nBlkH) array r of reconstructed samples is derived as follows:",
      "ja": "再構成されたサンプルの (nBlkW)x(nBlkH) 配列 r は次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* Each (vertical) column of scaled transform coefficients d[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 is transformed to e[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 by invoking the one-dimensional transformation process as specified in Section 6.3.2.2 for each column x = 0..nBlkW - 1 with the size of the transform block nBlkH, and the list d[x][y] with y = 0..nBlkH - 1 as inputs. The output is the list e[x][y] with y = 0..nBlkH - 1.",
      "ja": "* スケーリングされた変換係数 d[x][y] (x = 0..nBlkW - 1、y = 0..nBlkH - 1) の各 (垂直) 列は、各列 x = に対してセクション 6.3.2.2 で指定されている 1 次元変換プロセスを呼び出すことによって、x = 0..nBlkW - 1、y = 0..nBlkH - 1 で e[x][y] に変換されます。0..nBlkW - 1 (変換ブロック nBlkH のサイズ)、および入力として y = 0..nBlkH - 1 を持つリスト d[x][y]。出力は、y = 0..nBlkH - 1 のリスト e[x][y] です。"
    },
    {
      "indent": 6,
      "text": "* The following applies:",
      "ja": "* 以下が適用されます。"
    },
    {
      "indent": 12,
      "text": "- g[x][y] = (e[x][y] + 64) >> 7",
      "ja": "- g[x][y] = (e[x][y] + 64) >> 7"
    },
    {
      "indent": 6,
      "text": "* Each (horizontal) row of the resulting array g[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 is transformed to r[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 by invoking the one-dimensional transformation process as specified in Section 6.3.2.2 for each row y = 0..nBlkH - 1 with the size of the transform block nBlkW, and the list g[x][y] with x = 0..nBlkW - 1 as inputs. The output is the list r[x][y] with x = 0..nBlkW - 1.",
      "ja": "* 結果の配列 g[x][y] (x = 0..nBlkW - 1、y = 0..nBlkH - 1) の各 (水平) 行は、各行 y = に対してセクション 6.3.2.2 で指定されている 1 次元変換プロセスを呼び出すことによって、x = 0..nBlkW - 1、y = 0..nBlkH - 1 の r[x][y] に変換されます。0..nBlkH - 1 (変換ブロック nBlkW のサイズ)、およびリスト g[x][y] (x = 0..nBlkW - 1 を入力)。出力はリスト r[x][y] (x = 0..nBlkW - 1) です。"
    },
    {
      "indent": 0,
      "text": "6.3.2.2. Transformation Process",
      "section_title": true,
      "ja": "6.3.2.2. 変革のプロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are:",
      "ja": "このプロセスへの入力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a variable nTbS specifying the sample size of scaled transform coefficients, and",
      "ja": "* スケーリングされた変換係数のサンプル サイズを指定する変数 nTbS、および"
    },
    {
      "indent": 6,
      "text": "* a list of scaled transform coefficients x with elements x[j], with j = 0..(nTbS - 1).",
      "ja": "* 要素 x[j] を持つスケーリングされた変換係数 x のリスト (j = 0..(nTbS - 1))。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the list of transformed samples y with elements y[i], with i = 0..(nTbS - 1).",
      "ja": "このプロセスの出力は、要素 y[i] (i = 0..(nTbS - 1)) を含む変換されたサンプル y のリストです。"
    },
    {
      "indent": 3,
      "text": "The transformation matrix derivation process as specified in Section 6.3.2.3 is invoked with the transform size nTbS as input, and the transformation matrix transMatrix as output.",
      "ja": "セクション 6.3.2.3 で指定されている変換行列導出プロセスは、変換サイズ nTbS を入力として、変換行列 transMatrix を出力として呼び出されます。"
    },
    {
      "indent": 3,
      "text": "The list of transformed samples y[i] with i = 0..(nTbS - 1) is derived as follows:",
      "ja": "変換されたサンプル y[i] (i = 0..(nTbS - 1)) のリストは次のように導出されます。"
    },
    {
      "indent": 6,
      "text": "* y[i] = sum(j = 0, nTbS - 1, transMatrix[i][j] * x[j])",
      "ja": "* y[i] = sum(j = 0, nTbS - 1, transMatrix[i][j] * x[j])"
    },
    {
      "indent": 0,
      "text": "6.3.2.3. Transformation Matrix Derivation Process",
      "section_title": true,
      "ja": "6.3.2.3. 変換行列の導出プロセス"
    },
    {
      "indent": 3,
      "text": "Input to this process is a variable nTbS specifying the horizontal sample size of scaled transform coefficients.",
      "ja": "このプロセスへの入力は、スケーリングされた変換係数の水平サンプル サイズを指定する変数 nTbS です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is the transformation matrix transMatrix.",
      "ja": "このプロセスの出力は、変換行列 transMatrix です。"
    },
    {
      "indent": 3,
      "text": "The transformation matrix transMatrix is derived based on nTbs as follows:",
      "ja": "変換行列 transMatrix は、次のように nTbs に基づいて導出されます。"
    },
    {
      "indent": 6,
      "text": "* If nTbS is equal to 8, the following applies:",
      "ja": "* nTbS が 8 に等しい場合、次が適用されます。"
    },
    {
      "indent": 3,
      "text": "transMatrix[m][n] =\n   {\n    {  64,  64,  64,  64,  64,  64,  64,  64 }\n    {  89,  75,  50,  18, -18, -50, -75, -89 }\n    {  84,  35, -35, -84, -84, -35,  35,  84 }\n    {  75, -18, -89, -50,  50,  89,  18, -75 }\n    {  64, -64, -64,  64,  64, -64, -64,  64 }\n    {  50, -89,  18,  75, -75, -18,  89, -50 }\n    {  35, -84,  84, -35, -35,  84, -84,  35 }\n    {  18, -50,  75, -89,  89, -75,  50, -18 }\n   }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 25: Transform matrix for nTbS == 8",
      "ja": "図 25: nTbS == 8 の変換行列"
    },
    {
      "indent": 0,
      "text": "7. Parsing Process",
      "section_title": true,
      "ja": "7. 解析プロセス"
    },
    {
      "indent": 0,
      "text": "7.1. Process for Syntax Element Type h(v)",
      "section_title": true,
      "ja": "7.1. 構文要素タイプ h(v) の処理"
    },
    {
      "indent": 3,
      "text": "This process is invoked for the parsing of syntax elements with descriptor h(v) in Section 5.3.15 and Section 5.3.16.",
      "ja": "このプロセスは、セクション 5.3.15 およびセクション 5.3.16 の記述子 h(v) を使用して構文要素を解析するために呼び出されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Process for abs_dc_coeff_diff",
      "section_title": true,
      "ja": "7.1.1. abs_dc_coeff_diff のプロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are bits for the abs_dc_coeff_diff syntax element. Output of this process is a value of the abs_dc_coeff_diff syntax element. The variable kParam is derived as follows:",
      "ja": "このプロセスへの入力は、abs_dc_coeff_diff 構文要素のビットです。このプロセスの出力は、abs_dc_coeff_diff 構文要素の値です。変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 5, PrevDcDiff >> 1)",
      "ja": "kParam = クリップ(0, 5, PrevDcDiff >> 1)"
    },
    {
      "indent": 3,
      "text": "The value of syntax element abs_dc_coeff_diff is obtained by invoking the parsing process for variable-length codes as specified in Section 7.1.4 with kParam.",
      "ja": "構文要素 abs_dc_coeff_diff の値は、セクション 7.1.4 で指定されている可変長コードの解析プロセスを kParam で呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Process for coeff_zero_run",
      "section_title": true,
      "ja": "7.1.2. coeff_zero_runのプロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are bits for the coeff_zero_run syntax element.",
      "ja": "このプロセスへの入力は、coeff_zero_run 構文要素のビットです。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a value of the coeff_zero_run syntax element.",
      "ja": "このプロセスの出力は、coeff_zero_run 構文要素の値です。"
    },
    {
      "indent": 3,
      "text": "The variable kParam is derived as follows:",
      "ja": "変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 2, PrevRun >> 2)",
      "ja": "kParam = クリップ(0, 2, 前の実行 >> 2)"
    },
    {
      "indent": 3,
      "text": "The value of syntax element coeff_zero_run is obtained by invoking the parsing process for variable-length codes as specified in Section 7.1.4 with kParam.",
      "ja": "構文要素 coeff_zero_run の値は、セクション 7.1.4 で kParam を使用して指定された可変長コードの解析プロセスを呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Process for abs_ac_coeff_minus1",
      "section_title": true,
      "ja": "7.1.3. abs_ac_coeff_minus1 のプロセス"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are bits for the abs_ac_coeff_minus1 syntax element.",
      "ja": "このプロセスへの入力は、abs_ac_coeff_minus1 構文要素のビットです。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a value of the abs_ac_coeff_minus1 syntax element.",
      "ja": "このプロセスの出力は、abs_ac_coeff_minus1 構文要素の値です。"
    },
    {
      "indent": 3,
      "text": "The variable kParam is derived as follows:",
      "ja": "変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 4, PrevLevel >> 2)",
      "ja": "kParam = クリップ(0, 4, PrevLevel >> 2)"
    },
    {
      "indent": 3,
      "text": "The value of syntax element abs_ac_coeff_minus1 is obtained by invoking the parsing process for variable-length codes as specified in Section 7.1.4 with kParam.",
      "ja": "構文要素 abs_ac_coeff_minus1 の値は、セクション 7.1.4 で指定されている可変長コードの解析プロセスを kParam で呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.1.4. Process for Variable-Length Codes",
      "section_title": true,
      "ja": "7.1.4. 可変長コードの処理"
    },
    {
      "indent": 3,
      "text": "Input to this process is kParam.",
      "ja": "このプロセスへの入力は kParam です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a value, symbolValue, of a syntax element.",
      "ja": "このプロセスの出力は、構文要素の値、symbolValue です。"
    },
    {
      "indent": 3,
      "text": "The symbolValue is derived as follows:",
      "ja": "symbolValue は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": "symbolValue = 0\nparseExpGolomb = 1\nk = kParam\nstopLoop = 0\n\nif(read_bits(1) == 1){\n  parseExpGolomb = 0\n}\nelse{\n  if(read_bits (1) == 0){\n    symbolValue += (1 << k)\n    parseExpGolomb = 0\n  }\n  else{\n    symbolValue += (2 << k)\n    parseExpGolomb = 1\n  }\n}\n\nif(parseExpGolomb){\n  do{\n    if(read_bits(1) == 1){\n      stopLoop = 1\n    }\n    else{\n      symbolValue += (1 << k)\n      k++\n    }\n  } while(!stopLoop)\n}\n\nif(k > 0)\n  symbolValue += read_bits(k)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 26: Parsing process of symbolValue",
      "ja": "図 26:symbolValue の解析プロセス"
    },
    {
      "indent": 3,
      "text": "where the value returned from read_bits(n) is interpreted as a binary representation of an n-bit unsigned integer with the most significant bit written first.",
      "ja": "ここで、read_bits(n) から返される値は、最上位ビットが最初に書き込まれる n ビットの符号なし整数のバイナリ表現として解釈されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Codeword Generation Process for h(v) (Informative)",
      "section_title": true,
      "ja": "7.2. h(v) のコードワード生成プロセス (参考)"
    },
    {
      "indent": 3,
      "text": "This process specifies the code generation process for syntax elements with descriptor h(v).",
      "ja": "このプロセスは、記述子 h(v) を使用して構文要素のコード生成プロセスを指定します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Process for abs_dc_coeff_diff",
      "section_title": true,
      "ja": "7.2.1. abs_dc_coeff_diff のプロセス"
    },
    {
      "indent": 3,
      "text": "Input to this process is a symbol value of the abs_dc_coeff_diff syntax element.",
      "ja": "このプロセスへの入力は、abs_dc_coeff_diff 構文要素のシンボル値です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a codeword of the abs_dc_coeff_diff syntax element.",
      "ja": "このプロセスの出力は、abs_dc_coeff_diff 構文要素のコードワードです。"
    },
    {
      "indent": 3,
      "text": "The variable kParam is derived as follows:",
      "ja": "変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 5, PrevDcDiff >> 1)",
      "ja": "kParam = クリップ(0, 5, PrevDcDiff >> 1)"
    },
    {
      "indent": 3,
      "text": "The codeword of syntax element abs_dc_coeff_diff is obtained by invoking the generation process for variable-length codes as specified in Section 7.2.4 with the symbol value symbolValue and kParam.",
      "ja": "シンタックス要素 abs_dc_coeff_diff のコードワードは、セクション 7.2.4 で指定された可変長コードの生成プロセスを、シンボル値 simpleValue および kParam を使用して呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Process for coeff_zero_run",
      "section_title": true,
      "ja": "7.2.2. coeff_zero_runのプロセス"
    },
    {
      "indent": 3,
      "text": "Input to this process is a symbol value of the coeff_zero_run syntax element.",
      "ja": "このプロセスへの入力は、coeff_zero_run 構文要素のシンボル値です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a codeword of the coeff_zero_run syntax element.",
      "ja": "このプロセスの出力は、coeff_zero_run 構文要素のコードワードです。"
    },
    {
      "indent": 3,
      "text": "The variable kParam is derived as follows:",
      "ja": "変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 2, PrevRun >> 2)",
      "ja": "kParam = クリップ(0, 2, 前の実行 >> 2)"
    },
    {
      "indent": 3,
      "text": "The codeword of syntax element coeff_zero_run is obtained by invoking the generation process for variable-length codes as specified in Section 7.2.4 with the symbol value symbolValue and kParam.",
      "ja": "シンタックス要素 coeff_zero_run のコードワードは、セクション 7.2.4 で指定されているように、シンボル値 simpleValue および kParam を使用して可変長コードの生成プロセスを呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Process for abs_ac_coeff_minus1",
      "section_title": true,
      "ja": "7.2.3. abs_ac_coeff_minus1 のプロセス"
    },
    {
      "indent": 3,
      "text": "Input to this process is a symbol value of the abs_ac_coeff_minus1 syntax element.",
      "ja": "このプロセスへの入力は、abs_ac_coeff_minus1 構文要素のシンボル値です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a codeword of the abs_ac_coeff_minus1 syntax element.",
      "ja": "このプロセスの出力は、abs_ac_coeff_minus1 構文要素のコードワードです。"
    },
    {
      "indent": 3,
      "text": "The variable kParam is derived as follows:",
      "ja": "変数 kParam は次のように導出されます。"
    },
    {
      "indent": 3,
      "text": " kParam = clip(0, 4, PrevLevel >> 2)",
      "ja": "kParam = クリップ(0, 4, PrevLevel >> 2)"
    },
    {
      "indent": 3,
      "text": "The codeword of syntax element abs_ac_coeff_minus1 is obtained by invoking the generation for variable-length codes as specified in Section 7.2.4 with the symbol value symbolValue and kParam.",
      "ja": "構文要素 abs_ac_coeff_minus1 のコードワードは、セクション 7.2.4 で指定されているように、シンボル値 simpleValue および kParam を使用して可変長コードの生成を呼び出すことによって取得されます。"
    },
    {
      "indent": 0,
      "text": "7.2.4. Process for Variable-Length Codes",
      "section_title": true,
      "ja": "7.2.4. 可変長コードの処理"
    },
    {
      "indent": 3,
      "text": "Inputs to this process are symbolVal and kParam",
      "ja": "このプロセスへの入力は、symbolVal と kParam です。"
    },
    {
      "indent": 3,
      "text": "Output of this process is a codeword of a syntax element.",
      "ja": "このプロセスの出力は、構文要素のコードワードです。"
    },
    {
      "indent": 3,
      "text": "The codeword is derived as follows:",
      "ja": "コードワードは次のように導出されます。"
    },
    {
      "indent": 3,
      "text": "PrefixVLCTable[3][2] = {{1, 0}, {0, 0}, {0, 1}}\n\nsymbolValue = symbolVal\nvalPrefixVLC = clip(0, 2, symbolVal >> kParam)\nbitCount = 0\nk = kParam\n\nwhile(symbolValue >= (1 << k)){\n  symbolValue -= (1 << k)\n  if(bitCount < 2)\n    put_bits(PrefixVLCTable[valPrefixVLC][bitCount], 1)\n  else\n    put_bits(0, 1)\n  if(bitCount >= 2)\n    k++\n  bitCount++\n}\n\nif(bitCount < 2)\n  put_bits(PrefixVLCTable[valPrefixVLC][bitCount], 1)\nelse\n  put_bits(1, 1)\n\nif(k > 0)\n  put_bits(symbolValue, k)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 27: Generating bits from symbolValue",
      "ja": "図 27:symbolValue からのビットの生成"
    },
    {
      "indent": 3,
      "text": "where a codeword generated from put_bits(v, n) is interpreted as a binary representation of an n-bit unsigned integer value v with the most significant bit written first.",
      "ja": "ここで、put_bits(v, n) から生成されたコードワードは、n ビットの符号なし整数値 v のバイナリ表現として解釈され、最上位ビットが最初に書き込まれます。"
    },
    {
      "indent": 0,
      "text": "8. Metadata Information",
      "section_title": true,
      "ja": "8. メタデータ情報"
    },
    {
      "indent": 0,
      "text": "8.1. Metadata Payload",
      "section_title": true,
      "ja": "8.1. メタデータペイロード"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_payload(payloadType, payloadSize){                   |\n  if(payloadType == 4){                                       |\n    metadata_itu_t_t35(payloadSize)                           |\n  }                                                           |\n  else if(payloadType == 5){                                  |\n    metadata_mdcv(payloadSize)                                |\n  }                                                           |\n  else if(payloadType == 6){                                  |\n    metadata_cll(payloadSize)                                 |\n  }                                                           |\n  else if(payloadType == 10){                                 |\n    metadata_filler(payloadSize)                              |\n  }                                                           |\n  else if(payloadType == 170){                                |\n    metadata_user_defined(payloadSize)                        |\n  }                                                           |\n  else{                                                       |\n    metadata_undefined(payloadSize)                           |\n  }                                                           |\n  byte_alignment()                                            |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 28: metadata_payload() syntax code",
      "ja": "図 28:metadata_payload() 構文コード"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics of each type of metadata are defined in Section 8.2.",
      "ja": "各タイプのメタデータの構文とセマンティクスはセクション 8.2 で定義されています。"
    },
    {
      "indent": 0,
      "text": "8.2. List of Metadata Syntax and Semantics",
      "section_title": true,
      "ja": "8.2. メタデータの構文とセマンティクスのリスト"
    },
    {
      "indent": 0,
      "text": "8.2.1. Filler Metadata",
      "section_title": true,
      "ja": "8.2.1. フィラーメタデータ"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_filler(payloadSize){                                 |\n  for(i = 0; i < payloadSize; i++){                           |\n    ff_byte                                                   | f(8)\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ff_byte",
      "ja": "ff_バイト"
    },
    {
      "indent": 12,
      "text": "is a byte equal to 0xFF.",
      "ja": "は 0xFF に等しいバイトです。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Recommendation ITU-T T.35 Metadata",
      "section_title": true,
      "ja": "8.2.2. 推奨 ITU-T T.35 メタデータ"
    },
    {
      "indent": 3,
      "text": "This metadata contains information registered as specified in [ITUT-T35].",
      "ja": "このメタデータには、[ITUT-T35] で指定されているように登録された情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_itu_t_t35(payloadSize){                              |\n  itu_t_t35_country_code                                      | b(8)\n  readSize = payloadSize - 1                                  |\n                                                              |\n  if(itu_t_t35_country_code == 0xFF){                         |\n    itu_t_t35_country_code_extension                          | b(8)\n    readSize--                                                |\n  }                                                           |\n                                                              |\n  for(i = 0; i < readSize; i++){                              |\n    itu_t_t35_payload[i]                                      | b(8)\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 29: metadata_itu_t_t35() syntax code",
      "ja": "図 29:metadata_itu_t_t35() 構文コード"
    },
    {
      "indent": 3,
      "text": "itu_t_t35_country_code",
      "ja": "itu_t_t35_国コード"
    },
    {
      "indent": 12,
      "text": "MUST be a byte having the semantics of country code as specified in Annex A of [ITUT-T35].",
      "ja": "[ITUT-T35] の付録 A で指定されている国コードのセマンティクスを持つバイトでなければなりません (MUST)。"
    },
    {
      "indent": 3,
      "text": "itu_t_t35_country_code_extension",
      "ja": "itu_t_t35_国コード拡張子"
    },
    {
      "indent": 12,
      "text": "MUST be a byte having the semantics of country code as specified in Annex B of [ITUT-T35].",
      "ja": "[ITUT-T35] の付録 B で指定されている国コードのセマンティクスを持つバイトでなければなりません (MUST)。"
    },
    {
      "indent": 3,
      "text": "itu_t_t35_payload[i]",
      "ja": "itu_t_t35_ペイロード[i]"
    },
    {
      "indent": 12,
      "text": "MUST be a byte having the semantics of data registered as specified in [ITUT-T35].",
      "ja": "[ITUT-T35] で指定されているように登録されたデータのセマンティクスを持つバイトでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The terminal provider code and terminal provider oriented code as specified in [ITUT-T35] MUST be contained in the first one or more bytes of the itu_t_t35_payload. Any remaining bytes in itu_t_t35_payload data MUST be data having syntax and semantics as specified by the entity identified by the [ITUT-T35] country code and terminal provider code. Note that any metadata to be carried with this type of payload is expected to have been registered through either national administrator, the Alliance for Telecommunications Industry Solutions (ATIS) or the ITUT-T Telecommunication Standardization Bureau (TSB) as specified in [ITUT-T35].",
      "ja": "[ITUT-T35] で指定されている端末プロバイダー コードおよび端末プロバイダー指向コードは、itu_t_t35_payload の最初の 1 バイト以上に含まれなければなりません (MUST)。itu_t_t35_payload データ内の残りのバイトは、[ITUT-T35] 国コードと端末プロバイダー コードで識別されるエンティティによって指定された構文とセマンティクスを持つデータでなければなりません (MUST)。このタイプのペイロードで運ばれるメタデータは、[ITUT-T35] で指定されているように、国家管理者、電気通信産業ソリューション同盟 (ATIS)、または ITUT-T 電気通信標準化局 (TSB) のいずれかを通じて登録されていることが期待されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.2.3. Mastering Display Color Volume Metadata",
      "section_title": true,
      "ja": "8.2.3. 表示色ボリュームメタデータのマスタリング"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_mdcv(payloadSize){                                   |\n  for(i = 0; i < 3; i++){                                     |\n    primary_chromaticity_x[i]                                 | u(16)\n    primary_chromaticity_y[i]                                 | u(16)\n  }                                                           |\n  white_point_chromaticity_x                                  | u(16)\n  white_point_chromaticity_y                                  | u(16)\n  max_mastering_luminance                                     | u(32)\n  min_mastering_luminance                                     | u(32)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 30: metadata_mdcv() syntax code",
      "ja": "図 30:metadata_mdcv() 構文コード"
    },
    {
      "indent": 3,
      "text": "primary_chromaticity_x[i]",
      "ja": "プライマリ色度_x[i]"
    },
    {
      "indent": 12,
      "text": "specifies a 0.16 fixed-point format of X chromaticity coordinate of mastering display in terms of CIE 1931 as specified in [ISO11664-1], where i = 0, 1, 2 specifies Red, Green, Blue, respectively.",
      "ja": "[ISO11664-1] で指定されている CIE 1931 に基づくマスタリング ディスプレイの X 色度座標の 0.16 固定小数点形式を指定します。ここで、i = 0、1、2 はそれぞれ赤、緑、青を指定します。"
    },
    {
      "indent": 3,
      "text": "primary_chromaticity_y[i]",
      "ja": "プライマリ色度_y[i]"
    },
    {
      "indent": 12,
      "text": "specifies a 0.16 fixed-point format of Y chromaticity coordinate of mastering display in terms of CIE 1931 as specified in [ISO11664-1], where i = 0, 1, 2 specifies Red, Green, Blue, respectively.",
      "ja": "[ISO11664-1] で指定されている CIE 1931 に基づくマスタリング ディスプレイの Y 色度座標の 0.16 固定小数点形式を指定します。ここで、i = 0、1、2 はそれぞれ赤、緑、青を指定します。"
    },
    {
      "indent": 3,
      "text": "white_point_chromaticity_x",
      "ja": "ホワイトポイント_クロマシティ_x"
    },
    {
      "indent": 12,
      "text": "specifies a 0.16 fixed-point format of white point X chromaticity coordinate of mastering display in terms of CIE 1931 as specified in [ISO11664-1].",
      "ja": "[ISO11664-1] で規定されている CIE 1931 に基づくマスタリング ディスプレイの白色点 X 色度座標の 0.16 固定小数点形式を指定します。"
    },
    {
      "indent": 3,
      "text": "white_point_chromaticity_y",
      "ja": "ホワイトポイント色度_y"
    },
    {
      "indent": 12,
      "text": "specifies a 0.16 fixed-point format of white point Y chromaticity coordinate as mastering display in terms of CIE 1931 as specified in [ISO11664-1].",
      "ja": "[ISO11664-1] で規定されている CIE 1931 に基づくマスタリング表示として、白色点 Y 色度座標の 0.16 固定小数点形式を指定します。"
    },
    {
      "indent": 3,
      "text": "max_mastering_luminance",
      "ja": "max_mastering_luminance"
    },
    {
      "indent": 12,
      "text": "is a 24.8 fixed-point format of maximum display mastering luminance, represented in candelas per square meter.",
      "ja": "最大ディスプレイ マスタリング輝度の 24.8 固定小数点形式であり、平方メートルあたりのカンデラで表されます。"
    },
    {
      "indent": 3,
      "text": "min_mastering_luminance",
      "ja": "min_mastering_luminance"
    },
    {
      "indent": 12,
      "text": "is an 18.14 fixed-point format of minimum display mastering luminance, represented in candelas per square meter.",
      "ja": "最小ディスプレイ マスタリング輝度の 18.14 固定小数点形式であり、平方メートルあたりのカンデラで表されます。"
    },
    {
      "indent": 0,
      "text": "8.2.4. Content Light-Level Information Metadata",
      "section_title": true,
      "ja": "8.2.4. コンテンツのライトレベル情報のメタデータ"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_cll(payloadSize){                                    |\n  max_cll                                                     | u(16)\n  max_fall                                                    | u(16)\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 31: metadata_cll() syntax code",
      "ja": "図 31:metadata_cll() 構文コード"
    },
    {
      "indent": 3,
      "text": "max_cll",
      "ja": "max_cll"
    },
    {
      "indent": 12,
      "text": "specifies the maximum content light level information as specified in [CTA-861.3], Appendix A.",
      "ja": "[CTA-861.3]、付録 A で指定されている最大コンテンツ ライト レベル情報を指定します。"
    },
    {
      "indent": 3,
      "text": "max_fall",
      "ja": "max_fall"
    },
    {
      "indent": 12,
      "text": "specifies the maximum frame-average light level information as specified in [CTA-861.3], Appendix A.",
      "ja": "[CTA-861.3]、付録 A で指定されている最大フレーム平均光レベル情報を指定します。"
    },
    {
      "indent": 0,
      "text": "8.2.5. User-Defined Metadata",
      "section_title": true,
      "ja": "8.2.5. ユーザー定義のメタデータ"
    },
    {
      "indent": 3,
      "text": "This metadata has user data identified by a universal unique identifier as specified in [RFC9562], the contents of which are not specified in this document.",
      "ja": "このメタデータには、[RFC9562] で指定されている汎用一意識別子によって識別されるユーザー データが含まれていますが、その内容はこの文書では指定されていません。"
    },
    {
      "indent": 3,
      "text": "syntax code                                                 | type\n------------------------------------------------------------|-----\nmetadata_user_defined(payloadSize){                         |\n  uuid                                                      | u(128)\n  for(i = 0; i < (payloadSize - 16); i++)                   |\n    user_defined_data_payload[i]                            | b(8)\n}                                                           |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 32: metadata_user_defined() syntax code",
      "ja": "図 32:metadata_user_define() 構文コード"
    },
    {
      "indent": 3,
      "text": "uuid",
      "ja": "uuid"
    },
    {
      "indent": 12,
      "text": "MUST be a 128-bit value specified as a generated Universally Unique Identifier (UUID) according to the procedures specified in [RFC9562].",
      "ja": "[RFC9562] で指定された手順に従って、生成された汎用固有識別子 (UUID) として指定された 128 ビット値でなければなりません (MUST)。"
    },
    {
      "indent": 3,
      "text": "user_defined_data_payload[i]",
      "ja": "ユーザー定義データペイロード[i]"
    },
    {
      "indent": 12,
      "text": "MUST be a byte having user-defined syntax and semantics as specified by the UUID generator.",
      "ja": "UUID ジェネレーターによって指定されたユーザー定義の構文とセマンティクスを持つバイトでなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.6. Undefined Metadata",
      "section_title": true,
      "ja": "8.2.6. 未定義のメタデータ"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nmetadata_undefined(payloadSize){                              |\n  for(i = 0; i < payloadSize; i++){                           |\n    undefined_metadata_payload_byte[i]                        | b(8)\n  }                                                           |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 33: metadata_undefined() syntax code",
      "ja": "図 33:metadata_unknown() 構文コード"
    },
    {
      "indent": 3,
      "text": "undefined_metadata_payload_byte[i]",
      "ja": "未定義_メタデータ_ペイロード_バイト[i]"
    },
    {
      "indent": 12,
      "text": "is a byte reserved for future use.",
      "ja": "は将来の使用のために予約されているバイトです。"
    },
    {
      "indent": 0,
      "text": "9. Profiles, Levels, and Bands",
      "section_title": true,
      "ja": "9. プロファイル、レベル、バンド"
    },
    {
      "indent": 0,
      "text": "9.1. Overview of Profiles, Levels, and Bands",
      "section_title": true,
      "ja": "9.1. プロファイル、レベル、バンドの概要"
    },
    {
      "indent": 3,
      "text": "Profiles, levels, and bands specify restrictions on a coded frame and hence limits on the capabilities needed to decode the coded frame. Profiles, levels, and bands are also used to indicate interoperability points between individual decoder implementations.",
      "ja": "プロファイル、レベル、および帯域は、符号化されたフレームに対する制限を指定するため、符号化されたフレームを復号化するために必要な機能も制限されます。プロファイル、レベル、バンドは、個々のデコーダ実装間の相互運用性ポイントを示すためにも使用されます。"
    },
    {
      "indent": 3,
      "text": "Each profile specifies a subset of algorithmic features and limits that MUST be supported by all decoders conforming to that profile.",
      "ja": "各プロファイルは、そのプロファイルに準拠するすべてのデコーダによってサポートされなければならないアルゴリズム機能と制限のサブセットを指定します。"
    },
    {
      "indent": 3,
      "text": " NOTE: This document does not include individually selectable \"options\" at the decoder, as this would increase interoperability difficulties.",
      "ja": "注: このドキュメントには、デコーダで個別に選択できる「オプション」は含まれていません。これは、相互運用性がさらに困難になるためです。"
    },
    {
      "indent": 3,
      "text": " NOTE: Encoders are not required to make use of any particular subset of features supported in a profile.",
      "ja": "注: エンコーダは、プロファイルでサポートされている機能の特定のサブセットを利用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Each level with a band specifies a set of limits on the values that may be taken by the syntax elements of this document. For any given profile, a level with a band generally corresponds to a particular decoder processing load and memory capability. The constraints set by levels and bands are orthogonal to the constraints defined by profiles so that the same set of level and band definitions is used with all profiles. For example, a certain level L and a certain band B can be combined with either profile X or profile Y to specifically define two different sets of constraints.",
      "ja": "バンドが付いた各レベルは、このドキュメントの構文要素が取り得る値に対する一連の制限を指定します。任意のプロファイルについて、帯域のあるレベルは通常、特定のデコーダ処理負荷とメモリ能力に対応します。レベルおよびバンドによって設定された制約は、プロファイルによって定義された制約と直交しているため、同じレベルおよびバンド定義のセットがすべてのプロファイルで使用されます。たとえば、特定のレベル L および特定の帯域 B をプロファイル X またはプロファイル Y と組み合わせて、2 つの異なる制約セットを具体的に定義できます。"
    },
    {
      "indent": 3,
      "text": " NOTE: Individual implementations may support a different level for each supported profile.",
      "ja": "注: 個々の実装では、サポートされているプロファイルごとに異なるレベルがサポートされる場合があります。"
    },
    {
      "indent": 0,
      "text": "9.2. Requirements on Video Decoder Capability",
      "section_title": true,
      "ja": "9.2. ビデオ デコーダ機能の要件"
    },
    {
      "indent": 3,
      "text": "Capabilities of video decoders conforming to this document are specified in terms of the ability to decode video streams conforming to the constraints of profiles, levels, and bands specified in this section. When expressing the capabilities of a decoder for a specified profile, the level and the band supported for that profile MUST also be expressed.",
      "ja": "この文書に準拠するビデオ デコーダの機能は、このセクションで指定されるプロファイル、レベル、および帯域の制約に準拠するビデオ ストリームをデコードする能力の観点から指定されます。指定されたプロファイルのデコーダの機能を表現する場合、そのプロファイルでサポートされるレベルと帯域も表現しなければなりません(MUST)。"
    },
    {
      "indent": 3,
      "text": "Specific values are specified for the syntax elements profile_idc, level_idc, and band_idc. All other values of profile_idc, level_idc, and band_idc are reserved for future use.",
      "ja": "構文要素 profile_idc、level_idc、および Band_idc には特定の値が指定されます。profile_idc、level_idc、およびband_idcの他のすべての値は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": " NOTE: Decoders SHALL NOT infer that a reserved value of profile_idc between the values specified in this document indicates intermediate capabilities between the specified profiles, as there are no restrictions on the method to be chosen for the use of such future reserved values. However, decoders MUST infer that a reserved value of level_idc and a reserved value of band_idc between the values specified in this document indicates intermediate capabilities between the specified levels.",
      "ja": "注: デコーダは、この文書で指定された値の間にある profile_idc の予約値が、指定されたプロファイル間の中間機能を示すものであると推論してはならない (SHALL NOT)。これは、そのような将来の予約値の使用のために選択される方法に制限がないためである。ただし、デコーダは、この文書で指定された値の間の level_idc の予約値と Band_idc の予約値が、指定されたレベル間の中間機能を示すと推論しなければなりません (MUST)。"
    },
    {
      "indent": 0,
      "text": "9.3. Profiles",
      "section_title": true,
      "ja": "9.3. プロフィール"
    },
    {
      "indent": 0,
      "text": "9.3.1. General",
      "section_title": true,
      "ja": "9.3.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "All constraints for a coded frame that are specified are constraints for the coded frame that are activated when the bitstream of the access unit is decoded.",
      "ja": "指定された符号化フレームの制約はすべて、アクセス ユニットのビットストリームが復号化されるときにアクティブになる符号化フレームの制約です。"
    },
    {
      "indent": 0,
      "text": "9.3.2. 422-10 Profile",
      "section_title": true,
      "ja": "9.3.2. 422-10 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 422-10 profile is indicated by profile_idc equal to 33.",
      "ja": "コード化フレームが 422-10 プロファイルに準拠していることは、profile_idc が 33 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 422-10 profile MUST obey the following constraints:",
      "ja": "422-10 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be equal to 2.",
      "ja": "* chroma_format_idc は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be equal to 2.",
      "ja": "* bit_ Depth_minus8 は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 422-10 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 422-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "422-10 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 422-10 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 422-10 profile.",
      "ja": "* コード化されたフレームは 422-10 プロファイルに準拠していることが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.3. 422-12 Profile",
      "section_title": true,
      "ja": "9.3.3. 422-12 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 422-12 profile is indicated by profile_idc equal to 44.",
      "ja": "コード化フレームが 422-12 プロファイルに準拠していることは、profile_idc が 44 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 422-12 profile MUST obey the following constraints:",
      "ja": "422-12 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be equal to 2.",
      "ja": "* chroma_format_idc は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be in the range of 2 to 4.",
      "ja": "* bit_ Depth_minus8 は 2 ～ 4 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 422-12 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 422-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "422-12 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 422-12 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 422-12 profile or the 422-10 profile.",
      "ja": "* コード化されたフレームは、422-12 プロファイルまたは 422-10 プロファイルに準拠することが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.4. 444-10 Profile",
      "section_title": true,
      "ja": "9.3.4. 444-10 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 444-10 profile is indicated by profile_idc equal to 55.",
      "ja": "コード化フレームが 444-10 プロファイルに準拠していることは、profile_idc が 55 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 444-10 profile MUST obey the following constraints:",
      "ja": "444-10 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be in the range of 2 to 3.",
      "ja": "* chroma_format_idc は 2 ～ 3 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be equal to 2.",
      "ja": "* bit_ Depth_minus8 は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 444-10 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 444-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "444-10 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 444-10 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 444-10 profile or the 422-10 profile.",
      "ja": "* コード化されたフレームは、444-10 プロファイルまたは 422-10 プロファイルに準拠することが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.5. 444-12 Profile",
      "section_title": true,
      "ja": "9.3.5. 444-12 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 444-12 profile is indicated by profile_idc equal to 66.",
      "ja": "コード化フレームが 444-12 プロファイルに準拠していることは、profile_idc が 66 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 444-12 profile MUST obey the following constraints:",
      "ja": "444-12 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be in the range of 2 to 3.",
      "ja": "* chroma_format_idc は 2 ～ 3 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be in the range of 2 to 4.",
      "ja": "* bit_ Depth_minus8 は 2 ～ 4 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 444-12 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 444-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "444-12 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 444-12 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 444-12 profile, the 444-10 profile, the 422-12 profile, or the 422-10 profile.",
      "ja": "* コード化されたフレームは、444-12 プロファイル、444-10 プロファイル、422-12 プロファイル、または 422-10 プロファイルに準拠することが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.6. 4444-10 Profile",
      "section_title": true,
      "ja": "9.3.6. 4444-10 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 4444-10 profile is indicated by profile_idc equal to 77.",
      "ja": "コード化フレームが 4444-10 プロファイルに準拠していることは、profile_idc が 77 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 4444-10 profile MUST obey the following constraints:",
      "ja": "4444-10 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be in the range of 2 to 4.",
      "ja": "* chroma_format_idc は 2 ～ 4 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be equal to 2.",
      "ja": "* bit_ Depth_minus8 は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 4444-10 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 4444-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "4444-10 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 4444-10 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 4444-10 profile, the 444-10 profile, or the 422-10 profile.",
      "ja": "* コード化されたフレームは、4444-10 プロファイル、444-10 プロファイル、または 422-10 プロファイルに準拠することが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.7. 4444-12 Profile",
      "section_title": true,
      "ja": "9.3.7. 4444-12 プロフィール"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 4444-12 profile is indicated by profile_idc equal to 88.",
      "ja": "コード化フレームが 4444-12 プロファイルに準拠していることは、profile_idc が 88 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 4444-12 profile MUST obey the following constraints:",
      "ja": "4444-12 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be in the range of 2 to 4.",
      "ja": "* chroma_format_idc は 2 ～ 4 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be in the range of 2 to 4.",
      "ja": "* bit_ Depth_minus8 は 2 ～ 4 の範囲でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 4444-12 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 4444-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "4444-12 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 4444-12 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 4444-12 profile, the 4444-10 profile, the 444-12 profile, the 444-10 profile, the 422-12 profile, or the 422-10 profile.",
      "ja": "* コード化されたフレームは、4444-12 プロファイル、4444-10 プロファイル、444-12 プロファイル、444-10 プロファイル、422-12 プロファイル、または 422-10 プロファイルに準拠することが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.3.8. 400-10 Profile",
      "section_title": true,
      "ja": "9.3.8. 400-10 プロファイル"
    },
    {
      "indent": 3,
      "text": "Conformance of a coded frame to the 400-10 profile is indicated by profile_idc equal to 99.",
      "ja": "コード化フレームが 400-10 プロファイルに準拠していることは、profile_idc が 99 に等しいことで示されます。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 400-10 profile MUST obey the following constraints:",
      "ja": "400-10 プロファイルに準拠するコード化フレームは、次の制約に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "* chroma_format_idc MUST be equal to 0.",
      "ja": "* chroma_format_idc は 0 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* bit_depth_minus8 MUST be equal to 2.",
      "ja": "* bit_ Depth_minus8 は 2 に等しくなければなりません。"
    },
    {
      "indent": 6,
      "text": "* pbu_type MUST be equal to 1.",
      "ja": "* pbu_type は 1 でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Coded frames conforming to the 400-10 profile MUST also conform to any levels and bands constraints specified in Section 9.4. Decoders conforming to the 400-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) MUST be capable of decoding all coded frames for which all of the following conditions apply:",
      "ja": "400-10 プロファイルに準拠する符号化フレームは、セクション 9.4 で指定されたレベルおよび帯域の制約にも準拠しなければなりません (MUST)。特定のレベル (L の特定の値で識別される) および特定の帯域 (B の特定の値で識別される) で 400-10 プロファイルに準拠するデコーダは、以下の条件がすべて適用されるすべての符号化フレームを復号できなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to the 400-10 profile.",
      "ja": "* コード化されたフレームは 400-10 プロファイルに準拠していることが示されています。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.",
      "ja": "* コード化されたフレームは、レベル L 以下のレベル (level_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 6,
      "text": "* The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.",
      "ja": "* 符号化されたフレームは、帯域 B 以下の帯域 (band_idc の特定の値によって) に準拠することが示されます。"
    },
    {
      "indent": 0,
      "text": "9.4. Levels and Bands",
      "section_title": true,
      "ja": "9.4. レベルとバンド"
    },
    {
      "indent": 0,
      "text": "9.4.1. General",
      "section_title": true,
      "ja": "9.4.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "For purposes of comparison of level capabilities, a particular level of each band is considered to be a lower level than some other level when the value of the level_idc of the particular level of each band is less than that of the other level.",
      "ja": "レベル機能を比較する目的で、各帯域の特定のレベルの level_idc の値が他のレベルの値よりも小さい場合、各帯域の特定のレベルは他のレベルよりも低いレベルであると見なされます。"
    },
    {
      "indent": 6,
      "text": "* The luma sample rate (luma samples per second) MUST be less than or equal to the \"Max luma sample rate\".",
      "ja": "* ルマ サンプル レート (1 秒あたりのルマ サンプル) は、「最大ルマ サンプル レート」以下でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The coded data rate (bits per second) MUST be less than or equal to the \"Max coded data rate\".",
      "ja": "* コード化データ レート (ビット/秒) は、「最大コード化データ レート」以下でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The value of tile_width_in_mbs MUST be greater than or equal to 16.",
      "ja": "* tile_width_in_mbs の値は 16 以上でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The value of tile_height_in_mbs MUST be greater than or equal to 8.",
      "ja": "* tile_height_in_mbs の値は 8 以上でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The value of TileCols MUST be less than or equal to 20.",
      "ja": "* TileCols の値は 20 以下でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The value of TileRows MUST be less than or equal to 20.",
      "ja": "* TileRows の値は 20 以下でなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Limits of Levels and Bands",
      "section_title": true,
      "ja": "9.4.2. レベルとバンドの制限"
    },
    {
      "indent": 3,
      "text": "Table 4 specifies the limits for each level of each band. A level to which a coded frame conforms is indicated by the syntax elements level_idc and band_idc as follows:",
      "ja": "表 4 に、各帯域の各レベルの制限を示します。符号化されたフレームが準拠するレベルは、次のように構文要素 level_idc および Band_idc によって示されます。"
    },
    {
      "indent": 6,
      "text": "* level_idc MUST be set equal to a value of 30 times the level number specified in Table 4.",
      "ja": "* level_idc は、表 4 で指定されたレベル番号の 30 倍の値に設定しなければなりません (MUST)。"
    },
    {
      "indent": 4,
      "text": "+=======+==================+=====================================+\n| level | Max luma sample  |     Max coded data rate (Mbit/s)    |\n|       | rate (samples/s) |                                     |\n|       |                  +=====================================+\n|       |                  |              band_idc==             |\n|       |                  +========+========+=========+=========+\n|       |                  |      0 |      1 |       2 |       3 |\n+=======+==================+========+========+=========+=========+\n| 1     |        3,041,280 |      8 |     11 |      15 |      23 |\n+-------+------------------+--------+--------+---------+---------+\n| 1.1   |        6,082,560 |     16 |     21 |      30 |      45 |\n+-------+------------------+--------+--------+---------+---------+\n| 2     |       15,667,200 |     39 |     54 |      76 |     114 |\n+-------+------------------+--------+--------+---------+---------+\n| 2.1   |       31,334,400 |     78 |    108 |     152 |     227 |\n+-------+------------------+--------+--------+---------+---------+\n| 3     |       66,846,720 |    114 |    159 |     222 |     333 |\n+-------+------------------+--------+--------+---------+---------+\n| 3.1   |      133,693,440 |    227 |    317 |     444 |     666 |\n+-------+------------------+--------+--------+---------+---------+\n| 4     |      265,420,800 |    455 |    637 |     892 |   1,338 |\n+-------+------------------+--------+--------+---------+---------+\n| 4.1   |      530,841,600 |    910 |  1,274 |   1,784 |   2,675 |\n+-------+------------------+--------+--------+---------+---------+\n| 5     |    1,061,683,200 |  1,820 |  2,548 |   3,567 |   5,350 |\n+-------+------------------+--------+--------+---------+---------+\n| 5.1   |    2,123,366,400 |  3,639 |  5,095 |   7,133 |  10,699 |\n+-------+------------------+--------+--------+---------+---------+\n| 6     |    4,777,574,400 |  7,278 | 10,189 |  14,265 |  21,397 |\n+-------+------------------+--------+--------+---------+---------+\n| 6.1   |    8,493,465,600 | 14,556 | 20,378 |  28,529 |  42,793 |\n+-------+------------------+--------+--------+---------+---------+\n| 7     |   16,986,931,200 | 29,111 | 40,756 |  57,058 |  85,586 |\n+-------+------------------+--------+--------+---------+---------+\n| 7.1   |   33,973,862,400 | 58,222 | 81,511 | 114,115 | 171,172 |\n+-------+------------------+--------+--------+---------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 4: General level limits",
      "ja": "表 4: 一般的なレベル制限"
    },
    {
      "indent": 3,
      "text": "Table 5 shows widely used typical configurations of resolution and frame rates of video and corresponding levels for them.",
      "ja": "表 5 は、ビデオの解像度とフレーム レートの広く使用されている一般的な構成と、それらに対応するレベルを示しています。"
    },
    {
      "indent": 3,
      "text": "+==========+============+==================+===============+=======+\n| use case | resolution | frame per second |   luma sample | level |\n|          |            |                  |    per second |       |\n+==========+============+==================+===============+=======+\n|   720p   | 1280 x 720 |               30 |    27,648,000 | 2.1   |\n+----------+------------+------------------+---------------+-------+\n|   FHD    |   1920 x   |               30 |    62,208,000 | 3     |\n|          |    1080    |                  |               |       |\n+----------+------------+------------------+---------------+-------+\n|  UHD 4K  |   3840 x   |               60 |   497,664,000 | 4.1   |\n|          |    2160    |                  |               |       |\n+----------+------------+------------------+---------------+-------+\n|  UHD 4K  |   3840 x   |              120 |   995,328,000 | 5     |\n|          |    2160    |                  |               |       |\n+----------+------------+------------------+---------------+-------+\n|  UHD 8K  |   7680 x   |               60 | 1,990,656,000 | 5.1   |\n|          |    4320    |                  |               |       |\n+----------+------------+------------------+---------------+-------+\n|  UHD 8K  |   7680 x   |              120 | 3,981,312,000 | 6     |\n|          |    4320    |                  |               |       |\n+----------+------------+------------------+---------------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 5: Example of typical video configurations and corresponding levels (informative)",
      "ja": "表 5: 一般的なビデオ構成と対応するレベルの例 (参考)"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Like any other audio or video codec, APV should not be used with insecure ciphers or cipher modes that are vulnerable to known plaintext attacks. Some of the header bits as well as the padding are easily predictable.",
      "ja": "他のオーディオまたはビデオ コーデックと同様に、APV は、既知の平文攻撃に対して脆弱な安全でない暗号または暗号モードでは使用しないでください。ヘッダー ビットの一部とパディングは簡単に予測できます。"
    },
    {
      "indent": 3,
      "text": "A decoder MUST be robust against any non-compliant or malicious payloads. Malicious payloads MUST NOT cause the decoder to overrun its allocated memory or to take an excessive amount of resources to decode. An overrun in allocated memory could lead to arbitrary code execution by an attacker. The same applies to the encoder, even though problems in encoders are typically rare. Malicious video streams MUST NOT cause the encoder to misbehave because this would allow an attacker to attack transcoding gateways. A frequent security problem in image and video codecs is failure to check for integer overflows. An example is allocating \"frame_width * frame_height\" in pixel count computations without considering that the multiplication result may have overflowed the range of the arithmetic type. The implementation MUST ensure that any data outside of allocated and initialized memory cannot be read.",
      "ja": "デコーダは、非準拠または悪意のあるペイロードに対して堅牢でなければなりません。悪意のあるペイロードにより、デコーダが割り当てられたメモリをオーバーランしたり、デコードに過剰なリソースを消費したりしてはなりません。割り当てられたメモリがオーバーランすると、攻撃者による任意のコードの実行につながる可能性があります。エンコーダでの問題は通常はまれですが、同じことがエンコーダにも当てはまります。悪意のあるビデオ ストリームは、攻撃者がトランスコーディング ゲートウェイを攻撃できるようになるため、エンコーダの誤動作を引き起こしてはなりません。画像およびビデオ コーデックで頻繁に発生するセキュリティ問題は、整数オーバーフローのチェックに失敗することです。例としては、乗算結果が算術タイプの範囲をオーバーフローした可能性を考慮せずに、ピクセル数の計算で「frame_width * Frame_height」を割り当てることが挙げられます。実装では、割り当てられ初期化されたメモリ以外のデータは読み取れないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "A decoder MUST NOT try to process the metadata whose type is not recognized by the implementation. Failure to process any metadata exactly according to the syntax structure specified MAY put a decoder in an unknown status.",
      "ja": "デコーダは、実装によってタイプが認識されないメタデータを処理しようとしてはなりません (MUST NOT)。指定された構文構造に従ってメタデータを正確に処理できない場合、デコーダが不明なステータスになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "None of the content carried in APV is intended to be executable.",
      "ja": "APV に含まれるコンテンツはいずれも、実行可能であることを意図したものではありません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no actions for IANA.",
      "ja": "この文書には IANA に対する措置はありません。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[CIE15]    CIE, \"Colorimetry, 4th Edition\", DOI 10.25039/TR.015.2018,\n           2018,\n           <https://cie.co.at/publications/colorimetry-4th-edition>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CTA-861.3]\n           CTA, \"HDR Static Metadata Extensions\", CTA-861.3-A,\n           September 2019.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[H273]     ITU-T, \"Coding-independent code points for video signal\n           type identification\", ITU-T Recommendation H.273, ISO/\n           IEC 23091-2:2025, July 2024,\n           <https://www.itu.int/rec/T-REC-H.273>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ISO11664-1]\n           ISO, \"Colorimetry - Part 1: CIE standard colorimetric\n           observers\", ISO/CIE 11664-1:2019, 2019,\n           <https://www.iso.org/standard/74164.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ISO9899]  ISO/IEC, \"Information technology - Programming languages -\n           C\", ISO/IEC 9899:2024, 2024,\n           <https://www.iso.org/standard/82075.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ITUT-T35] ITU-T, \"Procedure for the allocation of ITU-T defined\n           codes for non-standard facilities\", ITU-T\n           Recommendation T.35, February 2000,\n           <https://www.itu.int/rec/T-REC-T.35>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9562]  Davis, K., Peabody, B., and P. Leach, \"Universally Unique\n           IDentifiers (UUIDs)\", RFC 9562, DOI 10.17487/RFC9562, May\n           2024, <https://www.rfc-editor.org/info/rfc9562>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AMPAS]    \"Academy of Motion Picture Arts and Sciences\",\n           <https://www.oscars.org/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[AOSP16APV]\n           \"Android open source project version 16\",\n           <https://developer.android.com/about/versions/16/\n           features#apv>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ASWF]     \"The Academy Software Foundation\", <https://www.aswf.io/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FFmpegAPVdec]\n           \"FFmpeg implementation of APV decoder\", 20 November 2025,\n           <https://ffmpeg.org/download.html#release_8.0>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FFmpegAPVenc]\n           \"FFmpeg implementation of APV encoder\", 4 May 2025,\n           <https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/\n           fab691edaf53bbf10429ef3448f1f274e5078395>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OpenAPV]  \"OpenAPV\", commit 1a7845a, 16 December 2025,\n           <https://github.com/AcademySoftwareFoundation/openapv>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Raw Bitstream Format",
      "section_title": true,
      "ja": "付録A. 生のビットストリーム形式"
    },
    {
      "indent": 3,
      "text": "syntax code                                                   | type\n--------------------------------------------------------------|-----\nraw_bitstream_access_unit(){                                  |\n    au_size                                                   | u(32)\n    access_unit(au_size)                                      |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 34: raw_bitstream_access_unit() syntax code",
      "ja": "図 34: raw_bitstream_access_unit() 構文コード"
    },
    {
      "indent": 3,
      "text": "au_size",
      "ja": "au_size"
    },
    {
      "indent": 12,
      "text": "indicates the size of access unit in bytes. 0 is prohibited and 0xFFFFFFFF is reserved.",
      "ja": "アクセスユニットのサイズをバイト単位で示します。0 は禁止されており、0xFFFFFFFF は予約されています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. APV Implementations",
      "section_title": true,
      "ja": "付録B. APVの実装"
    },
    {
      "indent": 0,
      "text": "B.1. OpenAPV Open Source Project",
      "section_title": true,
      "ja": "B.1. OpenAPV オープンソース プロジェクト"
    },
    {
      "indent": 3,
      "text": "The Academy Software Foundation (ASWF) [ASWF], jointly founded by the Academy of Motion Picture Arts and Science (AMPAS) [AMPAS] and the Linux Foundation, has created an open source software development project conformant to this document [OpenAPV]. The project also provides various test vectors for verification of the implementations at <https://github.com/AcademySoftwareFoundation/openapv/tree/main/test/ bitstream>.",
      "ja": "映画芸術科学アカデミー (AMPAS) [AMPAS] と Linux Foundation が共同で設立したアカデミー ソフトウェア財団 (ASWF) [ASWF] は、この文書に準拠したオープン ソース ソフトウェア開発プロジェクト [OpenAPV] を作成しました。このプロジェクトでは、実装を検証するためのさまざまなテスト ベクトルも <https://github.com/AcademySoftwareFoundation/openapv/tree/main/test/bitstream> で提供しています。"
    },
    {
      "indent": 0,
      "text": "B.2. Android Open Source Project",
      "section_title": true,
      "ja": "B.2. Android オープンソース プロジェクト"
    },
    {
      "indent": 3,
      "text": "The Android open source project (AOSP) has implemented Advanced Professional Video (APV) conformant to this document [AOSP16APV].",
      "ja": "Android オープンソース プロジェクト (AOSP) は、この文書 [AOSP16APV] に準拠した Advanced Professional Video (APV) を実装しました。"
    },
    {
      "indent": 0,
      "text": "B.3. FFmpeg Open Source Project",
      "section_title": true,
      "ja": "B.3. FFmpeg オープンソース プロジェクト"
    },
    {
      "indent": 3,
      "text": "The FFmpeg project is developing an APV decoder [FFmpegAPVdec] and an APV encoder [FFmpegAPVenc] conformant to this document.",
      "ja": "FFmpeg プロジェクトは、この文書に準拠した APV デコーダ [FFmpegAPVdec] と APV エンコーダ [FFmpegAPVenc] を開発しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Youngkwon Lim\nSamsung Electronics\n6105 Tennyson Pkwy, Ste 300\nPlano, TX 75024\nUnited States of America\nEmail: yklwhite@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Minwoo Park\nSamsung Electronics\n34, Seongchon-gil, Seocho-gu\nSeoul\n3573\nRepublic of Korea\nEmail: m.w.park@samsung.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Madhukar Budagavi\nSamsung Electronics\n6105 Tennyson Pkwy, Ste 300\nPlano, TX 75024\nUnited States of America\nEmail: m.budagavi@samsung.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rajan Joshi\nSamsung Electronics\n11488 Tree Hollow Ln\nSan Diego, CA 92128\nUnited States of America\nEmail: rajan_joshi@ieee.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kwang Pyo Choi\nSamsung Electronics\n34 Seongchon-gil Seocho-gu\nSeoul\n3573\nRepublic of Korea\nEmail: kwangpyo.choi@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}