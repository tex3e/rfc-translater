{
  "title": {
    "text": "RFC 9449 - OAuth 2.0 Demonstrating Proof of Possession (DPoP)",
    "ja": "RFC 9449 - OAuth 2.0 証明鍵に基づく所有証明 (DPoP)"
  },
  "number": 9449,
  "created_at": "2024-03-02 18:45:19.978799+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           D. Fett\nRequest for Comments: 9449                                      Authlete\nCategory: Standards Track                                    B. Campbell\nISSN: 2070-1721                                            Ping Identity\n                                                              J. Bradley\n                                                                  Yubico\n                                                          T. Lodderstedt\n                                                                 Tuconic\n                                                                M. Jones\n                                                  Self-Issued Consulting\n                                                                D. Waite\n                                                           Ping Identity\n                                                          September 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "OAuth 2.0 Demonstrating Proof of Possession (DPoP)",
      "title": true,
      "section_title": true,
      "ja": "OAuth 2.0 証明鍵に基づく所有証明 (DPoP)"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism for sender-constraining OAuth 2.0 tokens via a proof-of-possession mechanism on the application level. This mechanism allows for the detection of replay attacks with access and refresh tokens.",
      "ja": "このドキュメントでは、アプリケーションレベルでのプルーフポッセッションメカニズムを介して、送信者を制御するOAUTH 2.0トークンのメカニズムについて説明します。このメカニズムにより、アクセストークンと更新されたリプレイ攻撃の検出が可能になります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット技術タスクフォース (IETF) の成果です。これはIETFコミュニティの合意を表しています。公開レビューを受け、インターネット技術ステアリンググループ (IESG) による公開が承認されています。インターネット標準に関する追加情報は、RFC 7841のセクション2で参照できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9449.",
      "ja": "このドキュメントの現在のステータス、正誤表 (errata)、およびフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc9449で参照できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trust および文書の著者として識別された者。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "本ドキュメントは、BCP 78 および本ドキュメントの発行日に有効な IETF Trust の法的規定 (https://trustee.ietf.org/license-info) に従うものとします。これらの文書には、本ドキュメントに関するお客様の権利と制限が記載されていますので、注意深くご確認ください。本ドキュメントから抽出されたコードコンポーネントは、Trust Legal Provisions のセクション 4.e に記載されている Revised BSD License のテキストを含める必要があり、Revised BSD License に記載されている通り無保証で提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Conventions and Terminology\n2.  Objectives\n3.  Concept\n4.  DPoP Proof JWTs\n  4.1.  The DPoP HTTP Header\n  4.2.  DPoP Proof JWT Syntax\n  4.3.  Checking DPoP Proofs\n5.  DPoP Access Token Request\n  5.1.  Authorization Server Metadata\n  5.2.  Client Registration Metadata\n6.  Public Key Confirmation\n  6.1.  JWK Thumbprint Confirmation Method\n  6.2.  JWK Thumbprint Confirmation Method in Token Introspection\n7.  Protected Resource Access\n  7.1.  The DPoP Authentication Scheme\n  7.2.  Compatibility with the Bearer Authentication Scheme\n  7.3.  Client Considerations\n8.  Authorization Server-Provided Nonce\n  8.1.  Nonce Syntax\n  8.2.  Providing a New Nonce Value\n9.  Resource Server-Provided Nonce\n10. Authorization Code Binding to a DPoP Key\n  10.1.  DPoP with Pushed Authorization Requests\n11. Security Considerations\n  11.1.  DPoP Proof Replay\n  11.2.  DPoP Proof Pre-generation\n  11.3.  DPoP Nonce Downgrade\n  11.4.  Untrusted Code in the Client Context\n  11.5.  Signed JWT Swapping\n  11.6.  Signature Algorithms\n  11.7.  Request Integrity\n  11.8.  Access Token and Public Key Binding\n  11.9.  Authorization Code and Public Key Binding\n  11.10. Hash Algorithm Agility\n  11.11. Binding to Client Identity\n12. IANA Considerations\n  12.1.  OAuth Access Token Types Registration\n  12.2.  OAuth Extensions Error Registration\n  12.3.  OAuth Parameters Registration\n  12.4.  HTTP Authentication Schemes Registration\n  12.5.  Media Type Registration\n  12.6.  JWT Confirmation Methods Registration\n  12.7.  JSON Web Token Claims Registration\n    12.7.1.  \"nonce\" Registration Update\n  12.8.  Hypertext Transfer Protocol (HTTP) Field Name Registration\n  12.9.  OAuth Authorization Server Metadata Registration\n  12.10. OAuth Dynamic Client Registration Metadata\n13. References\n  13.1.  Normative References\n  13.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Demonstrating Proof of Possession (DPoP) is an application-level mechanism for sender-constraining OAuth [RFC6749] access and refresh tokens. It enables a client to prove the possession of a public/ private key pair by including a DPoP header in an HTTP request. The value of the header is a JSON Web Token (JWT) [RFC7519] that enables the authorization server to bind issued tokens to the public part of a client's key pair. Recipients of such tokens are then able to verify the binding of the token to the key pair that the client has demonstrated that it holds via the DPoP header, thereby providing some assurance that the client presenting the token also possesses the private key. In other words, the legitimate presenter of the token is constrained to be the sender that holds and proves possession of the private part of the key pair.",
      "ja": "証明鍵に基づく所有証明 (DPoP) は、送信者制限型の OAuth [RFC6749] アクセスおよびリフレッシュトークンを対象としたアプリケーションレベルのメカニズムです。これにより、クライアントはHTTPリクエストにDPoPヘッダーを含めることで、公開鍵/秘密鍵ペアの所有を証明できます。このヘッダーの値はJSON Web Token (JWT) [RFC7519] であり、認可サーバーは発行されたトークンをクライアントの鍵ペアの公開部分にバインドできます。このようなトークンの受信者は、クライアントがDPoPヘッダーを介して所有を実証した鍵ペアとトークンとのバインディングを検証でき、それにより、トークンを提示するクライアントも秘密鍵を所有しているという確証を得られます。言い換えれば、トークンの正当な提示者は、鍵ペアの秘密部分を保持し、その所有を証明する送信者に限定されます。"
    },
    {
      "indent": 3,
      "text": "The mechanism specified herein can be used in cases where other methods of sender-constraining tokens that utilize elements of the underlying secure transport layer, such as [RFC8705] or [TOKEN-BINDING], are not available or desirable. For example, due to a sub-par user experience of TLS client authentication in user agents and a lack of support for HTTP token binding, neither mechanism can be used if an OAuth client is an application that is dynamically downloaded and executed in a web browser (sometimes referred to as a \"single-page application\"). Additionally, applications that are installed and run directly on a user's device are well positioned to benefit from DPoP-bound tokens that guard against the misuse of tokens by a compromised or malicious resource. Such applications often have dedicated protected storage for cryptographic keys.",
      "ja": "本ドキュメントで指定されているメカニズムは、[RFC8705]や[TOKEN-BINDING]のような、基盤となるセキュアなトランスポート層の要素を利用する他の送信者制限型トークン方法が利用できない、または望ましくない場合に使用できます。たとえば、ユーザーエージェントにおけるTLSクライアント認証のユーザーエクスペリエンスが劣悪であることや、HTTPトークンバインディングのサポートが不足しているため、OAuthクライアントがWebブラウザで動的にダウンロードおよび実行されるアプリケーション（「シングルページアプリケーション」と呼ばれることもある）である場合、どちらのメカニズムも使用できません。さらに、ユーザーのデバイスに直接インストールされて実行されるアプリケーションは、侵害された、または悪意のあるリソースによるトークンの不正使用から保護するDPoPバインドされたトークンの恩恵を受けるのに適しています。このようなアプリケーションは、多くの場合、暗号鍵用の専用の保護ストレージを持っています。"
    },
    {
      "indent": 3,
      "text": "DPoP can be used to sender-constrain access tokens regardless of the client authentication method employed, but DPoP itself is not used for client authentication. DPoP can also be used to sender-constrain refresh tokens issued to public clients (those without authentication credentials associated with the client_id).",
      "ja": "DPoPは、使用されるクライアント認証方法に関わらず、送信者制限型のアクセストークンに使用できますが、DPoP自体はクライアント認証には使用されません。DPoPは、パブリッククライアント (client_id に関連付けられた認証情報を持たないクライアント) に発行された送信者制限型のリフレッシュトークンにも使用できます。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions and Terminology",
      "section_title": true,
      "ja": "1.1. 慣習と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」は、すべて大文字で記述されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているとおりに解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].",
      "ja": "この仕様では、[RFC5234]の拡張バッカス・ナウア記法 (ABNF) を使用します。"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"access token\", \"refresh token\", \"authorization server\", \"resource server\", \"authorization endpoint\", \"authorization request\", \"authorization response\", \"token endpoint\", \"grant type\", \"access token request\", \"access token response\", \"client\", \"public client\", and \"confidential client\" defined by \"The OAuth 2.0 Authorization Framework\" [RFC6749].",
      "ja": "この仕様では、「アクセストークン」、「リフレッシュトークン」、「認可サーバー」、「リソースサーバー」、「認可エンドポイント」、「認可リクエスト」、「認可レスポンス」、「トークンエンドポイント」、「グラント種別」、「アクセストークンリクエスト」、「アクセストークンレスポンス」、「クライアント」、「パブリッククライアント」、および「OAuth 2.0 Authorization Framework」[RFC6749]で定義されている「コンフィデンシャルクライアント」という用語を使用します。"
    },
    {
      "indent": 3,
      "text": "The terms \"request\", \"response\", \"header field\", and \"target URI\" are imported from [RFC9110].",
      "ja": "「要求」、「応答」、「ヘッダーフィールド」、「ターゲットURI」という用語は、[RFC9110]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "The terms \"JOSE\" and \"JOSE Header\" are imported from [RFC7515].",
      "ja": "「JOSE」と「JOSE Header」という用語は[RFC7515]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "This document contains non-normative examples of partial and complete HTTP messages. Some examples use a single trailing backslash to indicate line wrapping for long values, as per [RFC8792]. The character and leading spaces on wrapped lines are not part of the value.",
      "ja": "このドキュメントには、部分的および完全なHTTPメッセージの非規範的な例が含まれています。一部の例では、長い値の行折り返しを示すために、[RFC8792] に従って単一の末尾のバックスラッシュを使用しています。折り返された行の文字と先行するスペースは、値の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "2. Objectives",
      "section_title": true,
      "ja": "2. 目的"
    },
    {
      "indent": 3,
      "text": "The primary aim of DPoP is to prevent unauthorized or illegitimate parties from using leaked or stolen access tokens, by binding a token to a public key upon issuance and requiring that the client proves possession of the corresponding private key when using the token. This constrains the legitimate sender of the token to only the party with access to the private key and gives the server receiving the token added assurances that the sender is legitimately authorized to use it.",
      "ja": "DPoPの主な目的は、発行時にトークンを公開鍵に紐付けし、クライアントがトークンを使用するときに対応する秘密鍵の所有を証明することを要求することによって、不正な当事者や悪意のある当事者による、漏洩または盗難されたアクセストークンの使用を防止することです。これにより、トークンの正当な送信者を秘密鍵にアクセスできる当事者のみに限定し、トークンを受け取るサーバーに対して、その送信者が正当にトークンを使用する権限があるという追加の保証を与えます。"
    },
    {
      "indent": 3,
      "text": "Access tokens that are sender-constrained via DPoP thus stand in contrast to the typical bearer token, which can be used by any party in possession of such a token. Although protections generally exist to prevent unintended disclosure of bearer tokens, unforeseen vectors for leakage have occurred due to vulnerabilities and implementation issues in other layers in the protocol or software stack (see, e.g., Compression Ratio Info-leak Made Easy (CRIME) [CRIME], Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext (BREACH) [BREACH], Heartbleed [Heartbleed], and the Cloudflare parser bug [Cloudbleed]). There have also been numerous published token theft attacks on OAuth implementations themselves ([GitHub.Tokens] is just one high-profile example). DPoP provides a general defense in depth against the impact of unanticipated token leakage. DPoP is not, however, a substitute for a secure transport and MUST always be used in conjunction with HTTPS.",
      "ja": "したがって、DPoP によって送信者制限されたアクセストークンは、そのトークンを所持する任意の当事者が使用できる典型的なベアラートークンとは対照的です。ベアラートークンの意図しない開示を防ぐための保護は一般的に存在しますが、プロトコルまたはソフトウェアスタックの他の層における脆弱性や実装上の問題により、予期せぬ情報漏洩経路が発生しています（例えば、CRIME [CRIME]、BREACH [BREACH]、Heartbleed [Heartbleed]、Cloudflare パーサーバグ [Cloudbleed] など）。OAuth の実装自体に対する多数のトークン窃盗攻撃も報告されています（[GitHub.Tokens] はその一例です）。DPoP は、予期せぬトークン漏洩の影響に対する一般的な多層防御を提供します。ただし、DPoP はセキュアなトランスポートの代替ではなく、常にHTTPSと組み合わせて使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The very nature of the typical OAuth protocol interaction necessitates that the client discloses the access token to the protected resources that it accesses. The attacker model in [SECURITY-TOPICS] describes cases where a protected resource might be counterfeit, malicious, or compromised and plays received tokens against other protected resources to gain unauthorized access. Audience-restricted access tokens (e.g., using the JWT [RFC7519] aud claim) can prevent such misuse. However, doing so in practice has proven to be prohibitively cumbersome for many deployments (despite extensions such as [RFC8707]). Sender-constraining access tokens is a more robust and straightforward mechanism to prevent such token replay at a different endpoint, and DPoP is an accessible application-layer means of doing so.",
      "ja": "典型的なOAuthプロトコルによるやり取りの本質上、クライアントはアクセスする保護されたリソースに対してアクセストークンを開示する必要があります。[SECURITY-TOPICS] の攻撃者モデルは、保護されたリソースが偽造、悪意、または侵害されている可能性のあるケースを説明し、受け取ったトークンを他の保護されたリソースに対して再生することで不正アクセスを得る可能性があります。オーディエンス制限されたアクセストークン（例えば、JWT [RFC7519] の aud クレームを使用）は、そのような誤用を防止できます。しかし、実際には、多くの展開でこれが法外に煩雑であることが判明しています（[RFC8707] などの拡張にもかかわらず）。送信者制限型アクセストークンは、異なるエンドポイントでのトークンリプレイを防止するための、より堅牢で分かりやすいメカニズムであり、DPoP は、これを実現するためのアクセスしやすいアプリケーション層の手段です。"
    },
    {
      "indent": 3,
      "text": "Due to the potential for cross-site scripting (XSS), browser-based OAuth clients bring to bear added considerations with respect to protecting tokens. The most straightforward XSS-based attack is for an attacker to exfiltrate a token and use it themselves completely independent of the legitimate client. A stolen access token is used for protected resource access, and a stolen refresh token is used for obtaining new access tokens. If the private key is non-extractable (as is possible with [W3C.WebCryptoAPI]), DPoP renders exfiltrated tokens alone unusable.",
      "ja": "クロスサイトスクリプト（XSS）の可能性があるため、ブラウザベースのOAuthクライアントは、トークンの保護に関して追加の考慮事項をもたらします。最も単純なXSSベースの攻撃は、攻撃者がトークンを窃取し、正当なクライアントから完全に独立してそれを使用することです。窃取されたアクセストークンは保護されたリソースへのアクセスに使用され、窃取されたリフレッシュトークンは新しいアクセストークンを取得するために使用されます。秘密鍵が抽出不可能である場合（[W3C.WebCryptoAPI] のように）、DPoP は、窃取されたトークン単独では使用不可能にします。"
    },
    {
      "indent": 3,
      "text": "XSS vulnerabilities also allow an attacker to execute code in the context of the browser-based client application and maliciously use a token indirectly through the client. That execution context has access to utilize the signing key; thus, it can produce DPoP proofs to use in conjunction with the token. At this application layer, there is most likely no feasible defense against this threat except generally preventing XSS; therefore, it is considered out of scope for DPoP.",
      "ja": "XSSの脆弱性により、攻撃者はブラウザベースのクライアントアプリケーションのコンテキストでコードを実行し、クライアントを介してトークンを間接的に悪用することもできます。その実行コンテキストは、署名鍵を利用するアクセス権限を持ちます。したがって、トークンと組み合わせて使用するDPoP証明を生成できます。このアプリケーション層においては、一般的にXSSを防止することを除いて、この脅威に対する実現可能な防御策はおそらくありません。したがって、これはDPoP の範囲外と見なされます。"
    },
    {
      "indent": 3,
      "text": "Malicious XSS code executed in the context of the browser-based client application is also in a position to create DPoP proofs with timestamp values in the future and exfiltrate them in conjunction with a token. These stolen artifacts can later be used independent of the client application to access protected resources. To prevent this, servers can optionally require clients to include a server-chosen value into the proof that cannot be predicted by an attacker (nonce). In the absence of the optional nonce, the impact of pre-computed DPoP proofs is limited somewhat by the proof being bound to an access token on protected resource access. Because a proof covering an access token that does not yet exist cannot feasibly be created, access tokens obtained with an exfiltrated refresh token and pre-computed proofs will be unusable.",
      "ja": "ブラウザベースのクライアントアプリケーションのコンテキストで実行された悪意のあるXSSコードは、将来のタイムスタンプ値を持つDPoP証明を作成し、トークンと組み合わせて窃取する可能性があります。これらの窃取された成果物は、後でクライアントアプリケーションとは独立して保護されたリソースにアクセスするために使用できます。これを防止するため、サーバーは、攻撃者が予測できないサーバーによって選択された値（nonce）を証明に含めるようクライアントにオプションで要求することができます。オプションの nonce がない場合でも、事前に計算されたDPoP証明の影響は、保護されたリソースアクセス時のアクセストークンへのバインディングによって、ある程度制限されます。まだ存在しないアクセストークンを対象とする証明は現実的に作成できないため、窃取されたリフレッシュトークンと事前に計算された証明で取得されたアクセストークンは使用できなくなります。"
    },
    {
      "indent": 3,
      "text": "Additional security considerations are discussed in Section 11.",
      "ja": "追加のセキュリティ上の考慮事項については、セクション11で説明します。"
    },
    {
      "indent": 0,
      "text": "3. Concept",
      "section_title": true,
      "ja": "3. コンセプト"
    },
    {
      "indent": 3,
      "text": "The main data structure introduced by this specification is a DPoP proof JWT that is sent as a header in an HTTP request, as described in detail below. A client uses a DPoP proof JWT to prove the possession of a private key corresponding to a certain public key.",
      "ja": "この仕様で導入された主なデータ構造は、以下で詳しく説明するように、HTTPリクエストでヘッダーとして送信されるDPoP証明JWTです。クライアントはDPoP証明JWTを使用して、特定の公開鍵に対応する秘密鍵の所有を証明します。"
    },
    {
      "indent": 3,
      "text": "Roughly speaking, a DPoP proof is a signature over:",
      "ja": "大まかに言えば、DPoP証明は以下のものに対する署名です："
    },
    {
      "indent": 6,
      "text": "* some data of the HTTP request to which it is attached,",
      "ja": "* 添付されているHTTP要求のデータ、"
    },
    {
      "indent": 6,
      "text": "* a timestamp,",
      "ja": "* タイムスタンプ、"
    },
    {
      "indent": 6,
      "text": "* a unique identifier,",
      "ja": "* 一意の識別子、"
    },
    {
      "indent": 6,
      "text": "* an optional server-provided nonce, and",
      "ja": "* オプションのサーバーが提供するnonce、および"
    },
    {
      "indent": 6,
      "text": "* a hash of the associated access token when an access token is present within the request.",
      "ja": "* リクエスト内にアクセストークンが存在するときの関連するアクセストークンのハッシュ。"
    },
    {
      "indent": 3,
      "text": "+--------+                                          +---------------+\n|        |--(A)-- Token Request ------------------->|               |\n| Client |        (DPoP Proof)                      | Authorization |\n|        |                                          |     Server    |\n|        |<-(B)-- DPoP-Bound Access Token ----------|               |\n|        |        (token_type=DPoP)                 +---------------+\n|        |\n|        |\n|        |                                          +---------------+\n|        |--(C)-- DPoP-Bound Access Token --------->|               |\n|        |        (DPoP Proof)                      |    Resource   |\n|        |                                          |     Server    |\n|        |<-(D)-- Protected Resource ---------------|               |\n|        |                                          +---------------+\n+--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 1: Basic DPoP Flow",
      "ja": "図1：基本的なDPoPフロー"
    },
    {
      "indent": 3,
      "text": "The basic steps of an OAuth flow with DPoP (without the optional nonce) are shown in Figure 1.",
      "ja": "DPoPを使用したOAuthフローの基本的なステップ（オプションのnonceなし）を図1に示します。"
    },
    {
      "indent": 8,
      "text": "A. In the token request, the client sends an authorization grant (e.g., an authorization code, refresh token, etc.) to the authorization server in order to obtain an access token (and potentially a refresh token). The client attaches a DPoP proof to the request in an HTTP header.",
      "ja": "A.トークンリクエストでは、クライアントは、アクセストークン（および潜在的にリフレッシュトークン）を取得するために、認可グラント（認可コード、リフレッシュトークンなど）を認可サーバーに送信します。クライアントは、HTTPヘッダーのリクエストにDPoP証明を添付します。"
    },
    {
      "indent": 8,
      "text": "B. The authorization server binds (sender-constrains) the access token to the public key claimed by the client in the DPoP proof; that is, the access token cannot be used without proving possession of the respective private key. If a refresh token is issued to a public client, it is also bound to the public key of the DPoP proof.",
      "ja": "B. 認可サーバーは、DPoP証明でクライアントが主張する公開鍵にアクセストークンをバインドします（送信者制限）。つまり、それぞれの秘密鍵の所有を証明せずにアクセストークンを使用することはできません。リフレッシュトークンがパブリッククライアントに発行された場合、それもDPoP証明の公開鍵にバインドされます。"
    },
    {
      "indent": 8,
      "text": "C. To use the access token, the client has to prove possession of the private key by, again, adding a header to the request that carries a DPoP proof for that request. The resource server needs to receive information about the public key to which the access token is bound. This information may be encoded directly into the access token (for JWT-structured access tokens) or provided via token introspection endpoint (not shown). The resource server verifies that the public key to which the access token is bound matches the public key of the DPoP proof. It also verifies that the access token hash in the DPoP proof matches the access token presented in the request.",
      "ja": "C.アクセストークンを使用するには、クライアントは再度、そのリクエストに対するDPoP証明を運ぶヘッダーをリクエストに追加することにより、秘密鍵の所有を証明する必要があります。リソースサーバーは、アクセストークンがバインドされている公開鍵に関する情報を受け取る必要があります。この情報は、アクセストークン（JWT構造のアクセストークンの場合）に直接エンコードされるか、トークンイントロスペクションエンドポイントを介して提供される場合があります（図には示されていません）。リソースサーバーは、アクセストークンがバインドされている公開鍵がDPoP証明の公開鍵と一致することを確認します。また、DPoP証明内のアクセストークンハッシュが、リクエストで提示されたアクセストークンと一致することも確認します。"
    },
    {
      "indent": 8,
      "text": "D. The resource server refuses to serve the request if the signature check fails or if the data in the DPoP proof is wrong, e.g., the target URI does not match the URI claim in the DPoP proof JWT. The access token itself, of course, must also be valid in all other respects.",
      "ja": "D.リソースサーバーは、署名チェックが失敗した場合、またはDPoP証明のデータが不正な場合（例えば、ターゲットURIがDPoP証明JWTのURIクレームと一致しない場合）に、リクエストの処理を拒否します。もちろん、アクセストークン自体も他のすべての点で有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The DPoP mechanism presented herein is not a client authentication method. In fact, a primary use case of DPoP is for public clients (e.g., single-page applications and applications on a user's device) that do not use client authentication. Nonetheless, DPoP is designed to be compatible with private_key_jwt and all other client authentication methods.",
      "ja": "ここで提示されるDPoPメカニズムは、クライアント認証方法ではありません。実際、DPoPの主なユースケースは、クライアント認証を使用しないパブリッククライアント（ユーザーのデバイス上のシングルページアプリケーションやアプリケーションなど）を対象としています。それにもかかわらず、DPoPは、private_key_jwtおよび他のすべてのクライアント認証方法と互換性があるように設計されています。"
    },
    {
      "indent": 3,
      "text": "DPoP does not directly ensure message integrity, but it relies on the TLS layer for that purpose. See Section 11 for details.",
      "ja": "DPoPはメッセージの整合性を直接保証しませんが、その目的のためにTLS層に依存しています。詳細については、セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. DPoP Proof JWTs",
      "section_title": true,
      "ja": "4. DPoP証明JWT"
    },
    {
      "indent": 3,
      "text": "DPoP introduces the concept of a DPoP proof, which is a JWT created by the client and sent with an HTTP request using the DPoP header field. Each HTTP request requires a unique DPoP proof.",
      "ja": "DPoPは、クライアントによって作成されたJWTであり、DPoPヘッダーフィールドを使用してHTTPリクエストで送信されるDPoP証明の概念を導入します。各HTTPリクエストには、一意のDPoP証明が必要です。"
    },
    {
      "indent": 3,
      "text": "A valid DPoP proof demonstrates to the server that the client holds the private key that was used to sign the DPoP proof JWT. This enables authorization servers to bind issued tokens to the corresponding public key (as described in Section 5) and enables resource servers to verify the key-binding of tokens that it receives (see Section 7.1), which prevents said tokens from being used by any entity that does not have access to the private key.",
      "ja": "有効なDPoP証明は、クライアントがDPoP証明JWTの署名に使用した秘密鍵を保持していることをサーバーに示します。これにより、認可サーバーは、発行されたトークンを対応する公開鍵にバインドすることができ（セクション5参照）、リソースサーバーは、受け取ったトークンの鍵バインディングを検証することができます（セクション7.1参照）。これにより、秘密鍵にアクセスできないいかなるエンティティによる当該トークンの使用も防止されます。"
    },
    {
      "indent": 3,
      "text": "The DPoP proof demonstrates possession of a key and, by itself, is not an authentication or access control mechanism. When presented in conjunction with a key-bound access token as described in Section 7.1, the DPoP proof provides additional assurance about the legitimacy of the client to present the access token. However, a valid DPoP proof JWT is not sufficient alone to make access control decisions.",
      "ja": "DPoP証明は鍵の所有を実証するものであり、それ自体が認証またはアクセス制御メカニズムではありません。セクション7.1で説明されているように、鍵にバインドされたアクセストークンと組み合わせて提示された場合、DPoP証明は、アクセストークンを提示するクライアントの正当性に関する追加の保証を提供します。ただし、有効なDPoP証明JWTだけでは、アクセス制御の決定を下すのに十分ではありません。"
    },
    {
      "indent": 0,
      "text": "4.1. The DPoP HTTP Header",
      "section_title": true,
      "ja": "4.1. DPoP HTTPヘッダー"
    },
    {
      "indent": 3,
      "text": "A DPoP proof is included in an HTTP request using the following request header field.",
      "ja": "DPoP証明は、次のリクエストヘッダーフィールドを使用してHTTPリクエストに含まれます。"
    },
    {
      "indent": 3,
      "text": "DPoP:",
      "ja": "DPoP："
    },
    {
      "indent": 12,
      "text": "A JWT that adheres to the structure and syntax of Section 4.2.",
      "ja": "セクション4.2の構造と構文を順守するJWT。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows an example DPoP HTTP header field. The example uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図2は、DPoP HTTPヘッダーフィールドの例を示しています。この例では、[RFC8792] に従って行折り返しを使用します。"
    },
    {
      "indent": 3,
      "text": "DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\\n VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\\n nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\\n QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\\n oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\\n WF0IjoxNTYyMjYyNjE2fQ.2-GxA6T8lP4vfrg8v-FdWP0A0zdrj8igiMLvqRMUvwnQg\\\n 4PtFLbdLXiOSsX0x7NVY-FNyJK70nfbV37xRZT3Lg",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 2: Example DPoP Header",
      "ja": "図2：DPoPヘッダーの例"
    },
    {
      "indent": 3,
      "text": "Note that per [RFC9110], header field names are case insensitive; thus, DPoP, DPOP, dpop, etc., are all valid and equivalent header field names. However, case is significant in the header field value.",
      "ja": "[RFC9110] によると、ヘッダーフィールド名は大文字と小文字を区別しません。したがって、DPoP、DPOP、dpop などはすべて有効かつ同等のヘッダーフィールド名として扱われます。ただし、ヘッダーフィールド値では大文字と小文字が区別されます。"
    },
    {
      "indent": 3,
      "text": "The DPoP HTTP header field value uses the token68 syntax defined in Section 11.2 of [RFC9110] and is repeated below in Figure 3 for ease of reference.",
      "ja": "DPoP HTTPヘッダーフィールド値は、[RFC9110]のセクション11.2で定義されているtoken68構文を使用し、参照を容易にするために図3で以下に繰り返します。"
    },
    {
      "indent": 3,
      "text": "DPoP       = token68\ntoken68    = 1*( ALPHA / DIGIT /\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: DPoP Header Field ABNF",
      "ja": "図3：DPoPヘッダーフィールドABNF"
    },
    {
      "indent": 0,
      "text": "4.2. DPoP Proof JWT Syntax",
      "section_title": true,
      "ja": "4.2. DPoP証明JWT構文"
    },
    {
      "indent": 3,
      "text": "A DPoP proof is a JWT [RFC7519] that is signed (using JSON Web Signature (JWS) [RFC7515]) with a private key chosen by the client (see below). The JOSE Header of a DPoP JWT MUST contain at least the following parameters:",
      "ja": "DPoP証明は、クライアントが選択した秘密鍵を用いて署名された（JSON Web Signature (JWS) [RFC7515] を使用）JWT [RFC7519] です。DPoP JWTのJOSEヘッダーには、少なくとも次のパラメーターが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "typ:",
      "ja": "typ:"
    },
    {
      "indent": 12,
      "text": "A field with the value dpop+jwt, which explicitly types the DPoP proof JWT as recommended in Section 3.11 of [RFC8725].",
      "ja": "[RFC8725]のセクション3.11で推奨されているように、DPoP Proof JWTを明示的にタイプする値 dpop+jwt を持つフィールド。"
    },
    {
      "indent": 3,
      "text": "alg:",
      "ja": "alg:"
    },
    {
      "indent": 12,
      "text": "An identifier for a JWS asymmetric digital signature algorithm from [IANA.JOSE.ALGS]. It MUST NOT be none or an identifier for a symmetric algorithm (Message Authentication Code (MAC)).",
      "ja": "[IANA.JOSE.ALGS]からのJWS非対称デジタル署名アルゴリズムの識別子。none、または対称アルゴリズム（メッセージ認証コード（MAC））の識別子であってはなりません。"
    },
    {
      "indent": 3,
      "text": "jwk:",
      "ja": "jwk:"
    },
    {
      "indent": 12,
      "text": "Represents the public key chosen by the client in JSON Web Key (JWK) [RFC7517] format as defined in Section 4.1.3 of [RFC7515]. It MUST NOT contain a private key.",
      "ja": "[RFC7515]のセクション4.1.3で定義されているように、JSON Web Key (JWK) [RFC7517] 形式のクライアントが選択した公開鍵を表します。秘密鍵を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The payload of a DPoP proof MUST contain at least the following claims:",
      "ja": "DPoP証明のペイロードには、少なくとも次のクレームが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "jti:",
      "ja": "jti:"
    },
    {
      "indent": 12,
      "text": "Unique identifier for the DPoP proof JWT. The value MUST be assigned such that there is a negligible probability that the same value will be assigned to any other DPoP proof used in the same context during the time window of validity. Such uniqueness can be accomplished by encoding (base64url or any other suitable encoding) at least 96 bits of pseudorandom data or by using a version 4 Universally Unique Identifier (UUID) string according to [RFC4122]. The jti can be used by the server for replay detection and prevention; see Section 11.1.",
      "ja": "DPoP証明JWTの一意の識別子。値は、有効性の時間枠で同じコンテキストで使用される他のDPoP証明に同じ値が割り当てられる確率が無視できるほど小さいように割り当てる必要があります。このような一意性は、少なくとも96ビットの擬似ランダムデータをエンコード（base64urlまたはその他の適切なエンコード）するか、[RFC4122]に従ってバージョン4のUUID (Universally Unique Identifier) 文字列を使用することで達成できます。jti は、リプレイの検出と防止のためにサーバーで使用できます。セクション11.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "htm:",
      "ja": "htm:"
    },
    {
      "indent": 12,
      "text": "The value of the HTTP method (Section 9.1 of [RFC9110]) of the request to which the JWT is attached.",
      "ja": "JWTが添付されているリクエストのHTTPメソッド（[RFC9110]のセクション9.1）の値。"
    },
    {
      "indent": 3,
      "text": "htu:",
      "ja": "htu:"
    },
    {
      "indent": 12,
      "text": "The HTTP target URI (Section 7.1 of [RFC9110]) of the request to which the JWT is attached, without query and fragment parts.",
      "ja": "JWTが添付されているリクエストのHTTPターゲットURI（[RFC9110]のセクション7.1）で、クエリとフラグメント部分を含まないもの。"
    },
    {
      "indent": 3,
      "text": "iat:",
      "ja": "iat:"
    },
    {
      "indent": 12,
      "text": "Creation timestamp of the JWT (Section 4.1.6 of [RFC7519]).",
      "ja": "JWTの作成タイムスタンプ（[RFC7519]のセクション4.1.6）。"
    },
    {
      "indent": 3,
      "text": "When the DPoP proof is used in conjunction with the presentation of an access token in protected resource access (see Section 7), the DPoP proof MUST also contain the following claim:",
      "ja": "DPoP証明が、保護されたリソースアクセスでアクセストークンの提示と併せて使用される場合（セクション7を参照）、DPoP証明には次のクレームも含める必要があります。"
    },
    {
      "indent": 3,
      "text": "ath:",
      "ja": "ath:"
    },
    {
      "indent": 12,
      "text": "Hash of the access token. The value MUST be the result of a base64url encoding (as defined in Section 2 of [RFC7515]) the SHA-256 [SHS] hash of the ASCII encoding of the associated access token's value.",
      "ja": "アクセストークンのハッシュ。値は、関連するアクセストークンの値のASCIIエンコーディングのSHA-256 [SHS] ハッシュを、base64urlエンコーディング（[RFC7515] のセクション2で定義）した結果である必要があります。"
    },
    {
      "indent": 3,
      "text": "When the authentication server or resource server provides a DPoP-Nonce HTTP header in a response (see Sections 8 and 9), the DPoP proof MUST also contain the following claim:",
      "ja": "認可サーバーまたはリソースサーバーが応答でDPoP-Nonce HTTPヘッダーを提供する場合（セクション8および9を参照）、DPoP証明には次のクレームも含める必要があります。"
    },
    {
      "indent": 3,
      "text": "nonce:",
      "ja": "nonce:"
    },
    {
      "indent": 12,
      "text": "A recent nonce provided via the DPoP-Nonce HTTP header.",
      "ja": "DPoP-Nonce HTTPヘッダーを介して提供された最近のnonce。"
    },
    {
      "indent": 3,
      "text": "A DPoP proof MAY contain other JOSE Header Parameters or claims as defined by extension, profile, or deployment-specific requirements.",
      "ja": "DPoP証明には、拡張、プロファイル、または展開固有の要件によって定義される、他のJOSEヘッダーパラメーターまたはクレームが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "Figure 4 is a conceptual example showing the decoded content of the DPoP proof in Figure 2. The JSON of the JWT header and payload are shown, but the signature part is omitted. As usual, line breaks and extra spaces are included for formatting and readability.",
      "ja": "図4は、図2のDPoP証明のデコードされたコンテンツを示す概念的例です。JWTヘッダーとペイロードのJSONが示されていますが、署名部分は省略されています。いつものように、フォーマットと読みやすさのために、改行と余分なスペースが含まれています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"typ\":\"dpop+jwt\",\n  \"alg\":\"ES256\",\n  \"jwk\": {\n    \"kty\":\"EC\",\n    \"x\":\"l8tFrhx-34tV3hRICRDY9zCkDlpBhF42UQUfWVAWBFs\",\n    \"y\":\"9VE4jf_Ok_o64zbTTlcuNJajHmt6v9TDVrU0CdvGRDA\",\n    \"crv\":\"P-256\"\n  }\n}\n.\n{\n  \"jti\":\"-BwC3ESc6acc2lTc\",\n  \"htm\":\"POST\",\n  \"htu\":\"https://server.example.com/token\",\n  \"iat\":1562262616\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 4: Example JWT Content of a DPoP Proof",
      "ja": "図4：DPoP証明のJWTコンテンツの例"
    },
    {
      "indent": 3,
      "text": "Of the HTTP request, only the HTTP method and URI are included in the DPoP JWT; therefore, only these two message parts are covered by the DPoP proof. The idea is to sign just enough of the HTTP data to provide reasonable proof of possession with respect to the HTTP request. This design approach of using only a minimal subset of the HTTP header data is to avoid the substantial difficulties inherent in attempting to normalize HTTP messages. Nonetheless, DPoP proofs can be extended to contain other information of the HTTP request (see also Section 11.7).",
      "ja": "HTTPリクエストのうち、HTTPメソッドとURIのみがDPoP JWTに含まれます。したがって、これら2つのメッセージ部分のみがDPoP証明によってカバーされます。このアイデアは、HTTPリクエストに関して合理的な所有の証明を提供できるよう、十分なHTTPデータのみを署名することです。この設計アプローチは、HTTPヘッダーデータの最小限のサブセットのみを使用することで、HTTPメッセージの正規化に内在する実質的な困難を回避します。それにもかかわらず、DPoP証明は、HTTPリクエストの他の情報を含むように拡張できます（セクション11.7も参照）。"
    },
    {
      "indent": 0,
      "text": "4.3. Checking DPoP Proofs",
      "section_title": true,
      "ja": "4.3. DPoP証明の確認"
    },
    {
      "indent": 3,
      "text": "To validate a DPoP proof, the receiving server MUST ensure the following:",
      "ja": "DPoP証明を検証するには、受信サーバーは次のことを確認する必要があります。"
    },
    {
      "indent": 10,
      "text": "1. There is not more than one DPoP HTTP request header field.",
      "ja": "1. DPoP HTTPリクエストヘッダーフィールドは1つ以下です。"
    },
    {
      "indent": 10,
      "text": "2. The DPoP HTTP request header field value is a single and well-formed JWT.",
      "ja": "2. DPoP HTTPリクエストヘッダーフィールド値は、単一で整形式のJWTです。"
    },
    {
      "indent": 10,
      "text": "3. All required claims per Section 4.2 are contained in the JWT.",
      "ja": "3. セクション4.2で定義されているすべての必須クレームがJWTに含まれていること。"
    },
    {
      "indent": 10,
      "text": "4. The typ JOSE Header Parameter has the value dpop+jwt.",
      "ja": "4. typ JOSEヘッダーパラメーターが値 dpop+jwt を持つこと。"
    },
    {
      "indent": 10,
      "text": "5. The alg JOSE Header Parameter indicates a registered asymmetric digital signature algorithm [IANA.JOSE.ALGS], is not none, is supported by the application, and is acceptable per local policy.",
      "ja": "5. alg JOSEヘッダーパラメーターが、登録された非対称デジタル署名アルゴリズム [IANA.JOSE.ALGS] を示しており、none ではなく、アプリケーションによってサポートされており、ローカルポリシーに従って許容されること。"
    },
    {
      "indent": 10,
      "text": "6. The JWT signature verifies with the public key contained in the jwk JOSE Header Parameter.",
      "ja": "6. JWT署名が、jwk JOSEヘッダーパラメーターに含まれる公開鍵で検証されること。"
    },
    {
      "indent": 10,
      "text": "7. The jwk JOSE Header Parameter does not contain a private key.",
      "ja": "7. jwk JOSEヘッダーパラメーターに秘密鍵が含まれていないこと。"
    },
    {
      "indent": 10,
      "text": "8. The htm claim matches the HTTP method of the current request.",
      "ja": "8. htmクレームが、現在のリクエストのHTTPメソッドと一致すること。"
    },
    {
      "indent": 10,
      "text": "9. The htu claim matches the HTTP URI value for the HTTP request in which the JWT was received, ignoring any query and fragment parts.",
      "ja": "9. htuクレームが、JWTが受信されたHTTPリクエストのHTTP URI値と、クエリおよびフラグメント部分を無視して一致すること。"
    },
    {
      "indent": 10,
      "text": "10. If the server provided a nonce value to the client, the nonce claim matches the server-provided nonce value.",
      "ja": "10. サーバーがクライアントにnonce値を提供した場合、nonceクレームがサーバーが提供するnonce値と一致すること。"
    },
    {
      "indent": 10,
      "text": "11. The creation time of the JWT, as determined by either the iat claim or a server managed timestamp via the nonce claim, is within an acceptable window (see Section 11.1).",
      "ja": "11. JWTの作成時間が、iatクレームまたはnonceクレームを介したサーバー管理のタイムスタンプのいずれかによって決定される、許容可能な時間枠内にあること（セクション11.1を参照）。"
    },
    {
      "indent": 10,
      "text": "12. If presented to a protected resource in conjunction with an access token,",
      "ja": "12. アクセストークンと組み合わせて保護されたリソースに提示された場合、"
    },
    {
      "indent": 16,
      "text": "* ensure that the value of the ath claim equals the hash of that access token, and",
      "ja": "* athクレームの値がそのアクセストークンのハッシュと等しいことを確認すること、および"
    },
    {
      "indent": 16,
      "text": "* confirm that the public key to which the access token is bound matches the public key from the DPoP proof.",
      "ja": "* アクセストークンがバインドされている公開鍵が、DPoP証明の公開鍵と一致することを確認すること。"
    },
    {
      "indent": 3,
      "text": "To reduce the likelihood of false negatives, servers SHOULD employ syntax-based normalization (Section 6.2.2 of [RFC3986]) and scheme-based normalization (Section 6.2.3 of [RFC3986]) before comparing the htu claim.",
      "ja": "偽陰性の可能性を減らすために、サーバーは、htuクレームを比較する前に、構文ベースの正規化（[RFC3986]のセクション6.2.2）とスキームベースの正規化（[RFC3986]のセクション6.2.3）を適用すべきです。"
    },
    {
      "indent": 3,
      "text": "These checks may be performed in any order.",
      "ja": "これらのチェックは、任意の順序で実行できます。"
    },
    {
      "indent": 0,
      "text": "5. DPoP Access Token Request",
      "section_title": true,
      "ja": "5. DPoPアクセストークンリクエスト"
    },
    {
      "indent": 3,
      "text": "To request an access token that is bound to a public key using DPoP, the client MUST provide a valid DPoP proof JWT in a DPoP header when making an access token request to the authorization server's token endpoint. This is applicable for all access token requests regardless of grant type (e.g., the common authorization_code and refresh_token grant types and extension grants such as the JWT authorization grant [RFC7523]). The HTTP request shown in Figure 5 illustrates such an access token request using an authorization code grant with a DPoP proof JWT in the DPoP header. Figure 5 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "DPoPを使用して公開鍵にバインドされているアクセストークンを要求するには、クライアントは、認可サーバーのトークンエンドポイントにアクセストークンリクエストを行う際に、DPoPヘッダーに有効なDPoP証明JWTを提供する必要があります。これは、グラント種別に関わらず、すべてのアクセストークンリクエストに適用されます（例えば、一般的なauthorization_codeおよびrefresh_tokenグラント種別、ならびにJWT認可グラント[RFC7523]などの拡張グラント）。図5に示すHTTPリクエストは、DPoPヘッダーにDPoP証明JWTを含んだ認可コードグラントを使用して、そのようなアクセストークンリクエストを示しています。図5は、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\\n VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\\n nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\\n QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\\n oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\\n WF0IjoxNTYyMjYyNjE2fQ.2-GxA6T8lP4vfrg8v-FdWP0A0zdrj8igiMLvqRMUvwnQg\\\n 4PtFLbdLXiOSsX0x7NVY-FNyJK70nfbV37xRZT3Lg\n\ngrant_type=authorization_code\\\n&client_id=s6BhdRkqt\\\n&code=SplxlOBeZQQYbYS6WxSbIA\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\\n&code_verifier=bEaL42izcC-o-xBk0K2vuJ6U-y1p9r_wW2dFWIWgjz-",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 5: Token Request for a DPoP Sender-Constrained Token Using an Authorization Code",
      "ja": "図5：認可コードを使用したDPoP送信者制限型トークンのトークンリクエスト"
    },
    {
      "indent": 3,
      "text": "The DPoP HTTP header field MUST contain a valid DPoP proof JWT. If the DPoP proof is invalid, the authorization server issues an error response per Section 5.2 of [RFC6749] with invalid_dpop_proof as the value of the error parameter.",
      "ja": "DPoP HTTPヘッダーフィールドには、有効なDPoP証明JWTが含まれている必要があります。DPoP証明が無効である場合、認可サーバーは、[RFC6749]のセクション5.2に従って、エラーパラメーターの値としてinvalid_dpop_proofを伴うエラーレスポンスを発行します。"
    },
    {
      "indent": 3,
      "text": "To sender-constrain the access token after checking the validity of the DPoP proof, the authorization server associates the issued access token with the public key from the DPoP proof, which can be accomplished as described in Section 6. A token_type of DPoP MUST be included in the access token response to signal to the client that the access token was bound to its DPoP key and can be used as described in Section 7.1. The example response shown in Figure 6 illustrates such a response.",
      "ja": "DPoP証明の有効性を確認した後、アクセストークンを送信者制限するために、認可サーバーは発行されたアクセストークンをDPoP証明の公開鍵に関連付けます。これはセクション6で説明されているとおりに達成できます。アクセストークンレスポンスには、アクセストークンがそのDPoP鍵にバインドされており、セクション7.1で説明されているとおりに使用できることをクライアントに通知するために、token_typeにDPoPを含める必要があります。図6に示すレスポンスの例は、そのようなレスポンスを示しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\n\n{\n \"access_token\": \"Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\",\n \"token_type\": \"DPoP\",\n \"expires_in\": 2677,\n \"refresh_token\": \"Q..Zkm29lexi8VnWg2zPW1x-tgGad0Ibc3s3EwM_Ni4-g\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 6: Access Token Response",
      "ja": "図6：アクセストークンレスポンス"
    },
    {
      "indent": 3,
      "text": "The example response in Figure 6 includes a refresh token that the client can use to obtain a new access token when the previous one expires. Refreshing an access token is a token request using the refresh_token grant type made to the authorization server's token endpoint. As with all access token requests, the client makes it a DPoP request by including a DPoP proof, as shown in Figure 7. Figure 7 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図6の例のレスポンスには、クライアントが前のアクセストークンの期限が切れたときに新しいアクセストークンを取得するために使用できるリフレッシュトークンが含まれています。アクセストークンのリフレッシュは、認可サーバーのトークンエンドポイントに対して行われる、refresh_tokenグラント種別を使用したトークンリクエストです。すべてのアクセストークンリクエストと同様に、クライアントは図7に示すようにDPoP証明を含めることで、それをDPoPリクエストにします。図7は、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\\n VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\\n nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\\n QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\\n oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\\n WF0IjoxNTYyMjY1Mjk2fQ.pAqut2IRDm_De6PR93SYmGBPXpwrAk90e8cP2hjiaG5Qs\\\n GSuKDYW7_X620BxqhvYC8ynrrvZLTk41mSRroapUA\n\ngrant_type=refresh_token\\\n&client_id=s6BhdRkqt\\\n&refresh_token=Q..Zkm29lexi8VnWg2zPW1x-tgGad0Ibc3s3EwM_Ni4-g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 7: Token Request for a DPoP-Bound Token Using a Refresh Token",
      "ja": "図7：リフレッシュトークンを使用したDPoPバインドされたトークンのトークンリクエスト"
    },
    {
      "indent": 3,
      "text": "When an authorization server supporting DPoP issues a refresh token to a public client that presents a valid DPoP proof at the token endpoint, the refresh token MUST be bound to the respective public key. The binding MUST be validated when the refresh token is later presented to get new access tokens. As a result, such a client MUST present a DPoP proof for the same key that was used to obtain the refresh token each time that refresh token is used to obtain a new access token. The implementation details of the binding of the refresh token are at the discretion of the authorization server. Since the authorization server both produces and validates its refresh tokens, there is no interoperability consideration in the specific details of the binding.",
      "ja": "DPoPをサポートする認可サーバーが、トークンエンドポイントで有効なDPoP証明を提示するパブリッククライアントにリフレッシュトークンを発行する場合、リフレッシュトークンはそれぞれの公開鍵にバインドされる必要があります。新しいアクセストークンを取得するためにリフレッシュトークンが提示される際には、そのバインディングが検証される必要があります。その結果、そのようなクライアントは、リフレッシュトークンが新しいアクセストークンを取得するために使用されるたびに、リフレッシュトークンの取得に使用されたのと同じ鍵に対するDPoP証明を提示する必要があります。リフレッシュトークンのバインディングの実装の詳細は、認可サーバーの裁量に委ねられます。認可サーバーはリフレッシュトークンを生成および検証するため、バインディングの具体的な詳細に関する相互運用性の考慮事項はありません。"
    },
    {
      "indent": 3,
      "text": "An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750]. For a public client that is also issued a refresh token, this has the effect of DPoP-binding the refresh token alone, which can improve the security posture even when protected resources are not updated to support DPoP.",
      "ja": "認可サーバーは、DPoPにバインドされていないアクセストークンを発行することもできます。これは、[RFC6750]に従ってアクセストークンレスポンスのtoken_typeパラメーターにBearerの値をクライアントに通知することで行われます。リフレッシュトークンも発行されているパブリッククライアントの場合、これはリフレッシュトークンのみがDPoPバインディングされる効果があり、保護されたリソースがDPoPをサポートするように更新されていない場合でもセキュリティ体制を改善できます。"
    },
    {
      "indent": 3,
      "text": "If the access token response contains a different token_type value than DPoP, the access token protection provided by DPoP is not given. The client MUST discard the response in this case if this protection is deemed important for the security of the application; otherwise, the client may continue as in a regular OAuth interaction.",
      "ja": "アクセストークンレスポンスにDPoPとは異なるtoken_type値が含まれている場合、DPoPが提供するアクセストークン保護は提供されません。この保護がアプリケーションのセキュリティにとって重要であると見なされる場合、クライアントはこのレスポンスを破棄しなければなりません。それ以外の場合、クライアントは通常のOAuthによるやり取りと同様に続行しても構いません。"
    },
    {
      "indent": 3,
      "text": "Refresh tokens issued to confidential clients (those having established authentication credentials with the authorization server) are not bound to the DPoP proof public key because they are already sender-constrained with a different existing mechanism. The OAuth 2.0 Authorization Framework [RFC6749] already requires that an authorization server bind refresh tokens to the client to which they were issued and that confidential clients authenticate to the authorization server when presenting a refresh token. As a result, such refresh tokens are sender-constrained by way of the client identifier and the associated authentication requirement. This existing sender-constraining mechanism is more flexible (e.g., it allows credential rotation for the client without invalidating refresh tokens) than binding directly to a particular public key.",
      "ja": "コンフィデンシャルクライアント（認可サーバーに対して認証情報が確立されているクライアント）に発行されたリフレッシュトークンは、既に既存の異なるメカニズムによって送信者制限されているため、DPoP証明の公開鍵にはバインドされません。OAuth 2.0 Authorization Framework [RFC6749] は、認可サーバーがリフレッシュトークンを発行されたクライアントにバインドすること、およびコンフィデンシャルクライアントがリフレッシュトークンを提示する際に認可サーバーに対して認証することを既に要求しています。その結果、そのようなリフレッシュトークンは、クライアント識別子と関連する認証要件によって送信者制限されます。この既存の送信者制限メカニズムは、特定の公開鍵に直接バインドするよりも、より柔軟です（例：リフレッシュトークンを無効にすることなくクライアントの資格情報のローテーションを可能にします）。"
    },
    {
      "indent": 0,
      "text": "5.1. Authorization Server Metadata",
      "section_title": true,
      "ja": "5.1. 認可サーバーメタデータ"
    },
    {
      "indent": 3,
      "text": "This document introduces the following authorization server metadata [RFC8414] parameter to signal support for DPoP in general and the specific JWS alg values the authorization server supports for DPoP proof JWTs.",
      "ja": "このドキュメントでは、一般的にDPoPのサポートと、認可サーバーがDPoP証明JWTでサポートする特定のJWS alg値を示すために、次の認可サーバーメタデータ [RFC8414] パラメーターを導入します。"
    },
    {
      "indent": 3,
      "text": "dpop_signing_alg_values_supported:",
      "ja": "dpop_signing_alg_values_supported："
    },
    {
      "indent": 12,
      "text": "A JSON array containing a list of the JWS alg values (from the [IANA.JOSE.ALGS] registry) supported by the authorization server for DPoP proof JWTs.",
      "ja": "DPoP証明JWTで認可サーバーがサポートするJWS alg値のリスト（[IANA.JOSE.ALGS] レジストリから）を含むJSON配列。"
    },
    {
      "indent": 0,
      "text": "5.2. Client Registration Metadata",
      "section_title": true,
      "ja": "5.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "The Dynamic Client Registration Protocol [RFC7591] defines an API for dynamically registering OAuth 2.0 client metadata with authorization servers. The metadata defined by [RFC7591], and registered extensions to it, also imply a general data model for clients that is useful for authorization server implementations even when the Dynamic Client Registration Protocol isn't in play. Such implementations will typically have some sort of user interface available for managing client configuration.",
      "ja": "動的クライアント登録プロトコル[RFC7591]は、OAuth 2.0クライアントメタデータを認可サーバーに動的に登録するためのAPIを定義します。[RFC7591]によって定義されたメタデータ、およびそれに対する登録済みの拡張は、動的クライアント登録プロトコルが使用されていない場合でも、認可サーバーの実装にとって有用なクライアントの一般的なデータモデルを示唆しています。そのような実装では、通常、クライアント設定を管理するための何らかのユーザーインターフェースが利用可能でしょう。"
    },
    {
      "indent": 3,
      "text": "This document introduces the following client registration metadata [RFC7591] parameter to indicate that the client always uses DPoP when requesting tokens from the authorization server.",
      "ja": "このドキュメントでは、クライアントが認可サーバーからトークンをリクエストする際に常にDPoPを使用することを示すため、次のクライアント登録メタデータ [RFC7591] パラメーターを導入します。"
    },
    {
      "indent": 3,
      "text": "dpop_bound_access_tokens:",
      "ja": "dpop_bound_access_tokens："
    },
    {
      "indent": 12,
      "text": "A boolean value specifying whether the client always uses DPoP for token requests. If omitted, the default value is false.",
      "ja": "クライアントがトークンリクエストに常にDPoPを使用するかどうかを指定するブール値。省略された場合、デフォルト値はfalseです。"
    },
    {
      "indent": 3,
      "text": "If the value is true, the authorization server MUST reject token requests from the client that do not contain the DPoP header.",
      "ja": "値がtrueである場合、認可サーバーは、DPoPヘッダーを含まないクライアントからのトークンリクエストを拒否しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Public Key Confirmation",
      "section_title": true,
      "ja": "6. 公開鍵の確認"
    },
    {
      "indent": 3,
      "text": "Resource servers MUST be able to reliably identify whether an access token is DPoP-bound and ascertain sufficient information to verify the binding to the public key of the DPoP proof (see Section 7.1). Such a binding is accomplished by associating the public key with the token in a way that can be accessed by the protected resource, such as embedding the JWK hash in the issued access token directly, using the syntax described in Section 6.1, or through token introspection as described in Section 6.2. Other methods of associating a public key with an access token are possible per an agreement by the authorization server and the protected resource; however, they are beyond the scope of this specification.",
      "ja": "リソースサーバーは、アクセストークンがDPoPバインドされているかどうかを確実に識別し、DPoP証明の公開鍵へのバインディングを検証するのに十分な情報を確認できる必要があります（セクション7.1を参照）。このようなバインディングは、公開鍵を、発行されたアクセストークンに直接JWKハッシュを埋め込むなど、保護されたリソースがアクセスできる方法でトークンに関連付けることによって、セクション6.1で説明されている構文を使用するか、セクション6.2で説明されているトークンイントロスペクションを介して達成されます。公開鍵をアクセストークンに関連付ける他の方法は、認可サーバーと保護されたリソース間の合意に基づいて可能ですが、それらはこの仕様の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "Resource servers supporting DPoP MUST ensure that the public key from the DPoP proof matches the one bound to the access token.",
      "ja": "DPoPをサポートするリソースサーバーは、DPoP証明の公開鍵がアクセストークンにバインドされたものと一致することを確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1. JWK Thumbprint Confirmation Method",
      "section_title": true,
      "ja": "6.1. JWK Thumbprint確認方法"
    },
    {
      "indent": 3,
      "text": "When access tokens are represented as JWTs [RFC7519], the public key information is represented using the jkt confirmation method member defined herein. To convey the hash of a public key in a JWT, this specification introduces the following JWT Confirmation Method [RFC7800] member for use under the cnf claim.",
      "ja": "アクセストークンがJWT [RFC7519] として表現される場合、公開鍵情報は本ドキュメントで定義されているjkt確認方法メンバーを使用して表されます。JWTで公開鍵のハッシュを伝えるために、この仕様では、cnfクレームの下で使用するための次のJWT Confirmation Method [RFC7800] メンバーを導入します。"
    },
    {
      "indent": 3,
      "text": "jkt:",
      "ja": "jkt："
    },
    {
      "indent": 12,
      "text": "JWK SHA-256 Thumbprint confirmation method. The value of the jkt member MUST be the base64url encoding (as defined in [RFC7515]) of the JWK SHA-256 Thumbprint (according to [RFC7638]) of the DPoP public key (in JWK format) to which the access token is bound.",
      "ja": "JWK SHA-256サムプリント確認方法。jktメンバーの値は、アクセストークンがバインドされているDPoP公開鍵（JWK形式）のJWK SHA-256サムプリント（[RFC7638]に従う）を、[RFC7515]のセクション2で定義されているbase64urlエンコードしたものである必要があります。"
    },
    {
      "indent": 3,
      "text": "The following example JWT in Figure 8 with a decoded JWT payload shown in Figure 9 contains a cnf claim with the jkt JWK Thumbprint confirmation method member. The jkt value in these examples is the hash of the public key from the DPoP proofs in the examples shown in Section 5. The example uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図8に示すJWTの次の例は、図9に示すデコードされたJWTペイロードとともに、jkt JWKサムプリント確認方法メンバーを含むcnfクレームを含んでいます。これらの例におけるjkt値は、セクション5に示す例のDPoP証明からの公開鍵のハッシュです。この例では、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 3,
      "text": "eyJhbGciOiJFUzI1NiIsImtpZCI6IkJlQUxrYiJ9.eyJzdWIiOiJzb21lb25lQGV4YW1\\\nwbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLCJuYmYiOjE\\\n1NjIyNjI2MTEsImV4cCI6MTU2MjI2NjIxNiwiY25mIjp7ImprdCI6IjBaY09DT1JaTll\\\n5LURXcHFxMzBqWnlKR0hUTjBkMkhnbEJWM3VpZ3VBNEkifX0.3Tyo8VTcn6u_PboUmAO\\\nYUY1kfAavomW_YwYMkmRNizLJoQzWy2fCo79Zi5yObpIzjWb5xW4OGld7ESZrh0fsrA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 8: JWT Containing a JWK SHA-256 Thumbprint Confirmation",
      "ja": "図8：JWK SHA-256 サムプリントの確認を含むJWT"
    },
    {
      "indent": 3,
      "text": "{\n  \"sub\":\"someone@example.com\",\n  \"iss\":\"https://server.example.com\",\n  \"nbf\":1562262611,\n  \"exp\":1562266216,\n  \"cnf\":\n  {\n    \"jkt\":\"0ZcOCORZNYy-DWpqq30jZyJGHTN0d2HglBV3uiguA4I\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 9: JWT Claims Set with a JWK SHA-256 Thumbprint Confirmation",
      "ja": "図9：JWK SHA-256 サムプリントの確認で設定されたJWTクレーム"
    },
    {
      "indent": 0,
      "text": "6.2. JWK Thumbprint Confirmation Method in Token Introspection",
      "section_title": true,
      "ja": "6.2. トークン内省におけるJWKサムプリント確認方法"
    },
    {
      "indent": 3,
      "text": "\"OAuth 2.0 Token Introspection\" [RFC7662] defines a method for a protected resource to query an authorization server about the active state of an access token. The protected resource also determines metainformation about the token.",
      "ja": "「OAuth 2.0トークン内省」[RFC7662]は、保護されたリソースがアクセストークンのアクティブな状態について認可サーバーに問い合わせる方法を定義します。保護されたリソースは、トークンに関するメタ情報も決定します。"
    },
    {
      "indent": 3,
      "text": "For a DPoP-bound access token, the hash of the public key to which the token is bound is conveyed to the protected resource as metainformation in a token introspection response. The hash is conveyed using the same cnf content with jkt member structure as the JWK Thumbprint confirmation method, described in Section 6.1, as a top-level member of the introspection response JSON. Note that the resource server does not send a DPoP proof with the introspection request, and the authorization server does not validate an access token's DPoP binding at the introspection endpoint. Rather, the resource server uses the data of the introspection response to validate the access token binding itself locally.",
      "ja": "DPoPにバインドされたアクセストークンの場合、トークンがバインドされている公開鍵のハッシュは、トークンイントロスペクションレスポンスにおいてメタ情報として保護されたリソースに伝達されます。ハッシュは、セクション6.1で記述されているJWKサムプリント確認方法と同様に、jktメンバー構造を持つ同じcnfコンテンツを使用して伝達されます。リソースサーバーはイントロスペクションリクエストでDPoP証明を送信せず、認可サーバーは、イントロスペクションエンドポイントでアクセストークンのDPoPバインディングを検証しないことに注意してください。むしろ、リソースサーバーはイントロスペクションレスポンスのデータを使用して、アクセストークンバインディング自体をローカルで検証します。"
    },
    {
      "indent": 3,
      "text": "If the token_type member is included in the introspection response, it MUST contain the value DPoP.",
      "ja": "token_typeメンバーがイントロスペクションレスポンスに含まれている場合、その値はDPoPでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The example introspection request in Figure 10 and corresponding response in Figure 11 illustrate an introspection exchange for the example DPoP-bound access token that was issued in Figure 6.",
      "ja": "図10のイントロスペクションリクエストと、図11の対応するレスポンスの例は、図6で発行されたDPoPバインドされたアクセストークンのイントロスペクションのやり取りを示しています。"
    },
    {
      "indent": 3,
      "text": "POST /as/introspect.oauth2 HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nAuthorization: Basic cnM6cnM6TWt1LTZnX2xDektJZHo0ZnNON2tZY3lhK1Rp\n\ntoken=Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 10: Example Introspection Request",
      "ja": "図10：イントロスペクションリクエストの例"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\n\n{\n  \"active\": true,\n  \"sub\": \"someone@example.com\",\n  \"iss\": \"https://server.example.com\",\n  \"nbf\": 1562262611,\n  \"exp\": 1562266216,\n  \"cnf\":\n  {\n    \"jkt\": \"0ZcOCORZNYy-DWpqq30jZyJGHTN0d2HglBV3uiguA4I\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 11: Example Introspection Response for a DPoP-Bound Access Token",
      "ja": "図11：DPoPバインドされたアクセストークンのイントロスペクションレスポンスの例"
    },
    {
      "indent": 0,
      "text": "7. Protected Resource Access",
      "section_title": true,
      "ja": "7. 保護されたリソースアクセス"
    },
    {
      "indent": 3,
      "text": "Requests to DPoP-protected resources MUST include both a DPoP proof as per Section 4 and the access token as described in Section 7.1. The DPoP proof MUST include the ath claim with a valid hash of the associated access token.",
      "ja": "DPoP保護されたリソースへのリクエストには、セクション4に従ったDPoP証明とセクション7.1で説明されているアクセストークンの両方を含めなければなりません。DPoP証明には、関連するアクセストークンの有効なハッシュを含むathクレームを含めなければなりません。"
    },
    {
      "indent": 3,
      "text": "Binding the token value to the proof in this way prevents a proof to be used with multiple different access token values across different requests. For example, if a client holds tokens bound to two different resource owners, AT1 and AT2, and uses the same key when talking to the authorization server, it's possible that these tokens could be swapped. Without the ath field to bind it, a captured signature applied to AT1 could be replayed with AT2 instead, changing the rights and access of the intended request. This same substitution prevention remains for rotated access tokens within the same combination of client and resource owner -- a rotated token value would require the calculation of a new proof. This binding additionally ensures that a proof intended for use with the access token is not usable without an access token, or vice-versa.",
      "ja": "この方法でトークン値を証明にバインドすると、異なるリクエスト間で複数の異なるアクセストークン値で証明が使用されることが防止されます。例えば、クライアントが2つの異なるリソース所有者、AT1とAT2にバインドされたトークンを保持し、認可サーバーと通信する際に同じ鍵を使用した場合、これらのトークンが入れ替えられる可能性があります。athフィールドによるバインディングがないと、AT1に適用されたキャプチャされた署名がAT2で再生され、意図されたリクエストの権限とアクセスが変更される可能性があります。この同様の置換防止は、クライアントとリソース所有者の同じ組み合わせ内での、ローテーションされたアクセストークンに対しても維持されます。ローテーションされたトークン値には新しい証明の計算が必要になります。このバインディングはさらに、アクセストークンで使用されることを意図した証明が、アクセストークンなしでは使用できないこと、またはその逆も同様であることを保証します。"
    },
    {
      "indent": 3,
      "text": "The resource server is required to calculate the hash of the token value presented and verify that it is the same as the hash value in the ath field as described in Section 4.3. Since the ath field value is covered by the DPoP proof's signature, its inclusion binds the access token value to the holder of the key used to generate the signature.",
      "ja": "リソースサーバーは、提示されたトークン値のハッシュを計算し、セクション4.3で説明されているathフィールドのハッシュ値と同じであることを確認する必要があります。athフィールドの値はDPoP証明の署名によって保護されているため、その含まれている値は、署名の生成に使用された鍵の所有者にアクセストークン値を結合します。"
    },
    {
      "indent": 3,
      "text": "Note that the ath field alone does not prevent replay of the DPoP proof or provide binding to the request in which the proof is presented, and it is still important to check the time window of the proof as well as the included message parameters, such as htm and htu.",
      "ja": "athフィールドだけでは、DPoP証明のリプレイを防止したり、証明が提示されているリクエストへのバインディングを提供したりしないことに注意してください。htmやhtuなどの含まれるメッセージパラメータだけでなく、証明の有効期間もチェックすることが依然として重要です。"
    },
    {
      "indent": 0,
      "text": "7.1. The DPoP Authentication Scheme",
      "section_title": true,
      "ja": "7.1. DPoP認証スキーム"
    },
    {
      "indent": 3,
      "text": "A DPoP-bound access token is sent using the Authorization request header field per Section 11.6.2 of [RFC9110] with an authentication scheme of DPoP. The syntax of the Authorization header field for the DPoP scheme uses the token68 syntax defined in Section 11.2 of [RFC9110] for credentials and is repeated below for ease of reference. The ABNF notation syntax for DPoP authentication scheme credentials is as follows:",
      "ja": "DPoP認証スキームを使用して、[RFC9110]のセクション11.6.2に従ってAuthorizationリクエストヘッダーフィールドを使用してDPoPバインドされたアクセストークンが送信されます。DPoPスキームのAuthorizationヘッダーフィールドの構文は、資格情報のために[RFC9110]のセクション11.2で定義されているtoken68構文を使用しており、参照を容易にするために以下に繰り返します。DPoP認証スキームの資格情報のABNF記法構文は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "token68    = 1*( ALPHA / DIGIT /\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\n\ncredentials = \"DPoP\" 1*SP token68",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 12: DPoP Authentication Scheme ABNF",
      "ja": "図12：DPoP認証スキームABNF"
    },
    {
      "indent": 3,
      "text": "For such an access token, a resource server MUST check that a DPoP proof was also received in the DPoP header field of the HTTP request, check the DPoP proof according to the rules in Section 4.3, and check that the public key of the DPoP proof matches the public key to which the access token is bound per Section 6.",
      "ja": "そのようなアクセストークンの場合、リソースサーバーは、HTTPリクエストのDPoPヘッダーフィールドでDPoP証明も受信されたこと、セクション4.3の規則に従ってDPoP証明を検証すること、およびアクセストークンがバインドされている公開鍵がセクション6に従ってDPoP証明の公開鍵と一致することを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The resource server MUST NOT grant access to the resource unless all checks are successful.",
      "ja": "リソースサーバーは、すべてのチェックが成功しない限り、リソースへのアクセスを許可してはなりません。"
    },
    {
      "indent": 3,
      "text": "Figure 13 shows an example request to a protected resource with a DPoP-bound access token in the Authorization header and the DPoP proof in the DPoP header. The example uses \"\\\" line wrapping per [RFC8792]. Figure 14 shows the decoded content of that DPoP proof. The JSON of the JWT header and payload are shown, but the signature part is omitted. As usual, line breaks and indentation are included for formatting and readability.",
      "ja": "図13は、AuthorizationヘッダーにDPoPバインドされたアクセストークンを、DPoPヘッダーにDPoP証明を含む、保護されたリソースへのリクエストの例を示しています。この例では、[RFC8792] に従って行折り返しを使用しています。図14は、そのDPoP証明のデコードされたコンテンツを示しています。JWTヘッダーとペイロードのJSONが表示されていますが、署名部分は省略されています。いつものように、フォーマットと読みやすさのために、改行とインデントが含まれています。"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1\nHost: resource.example.org\nAuthorization: DPoP Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\\n VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\\n nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\\n QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiJlMWozVl9iS2ljOC1MQUVCIiwiaHRtIj\\\n oiR0VUIiwiaHR1IjoiaHR0cHM6Ly9yZXNvdXJjZS5leGFtcGxlLm9yZy9wcm90ZWN0Z\\\n WRyZXNvdXJjZSIsImlhdCI6MTU2MjI2MjYxOCwiYXRoIjoiZlVIeU8ycjJaM0RaNTNF\\\n c05yV0JiMHhXWG9hTnk1OUlpS0NBcWtzbVFFbyJ9.2oW9RP35yRqzhrtNP86L-Ey71E\\\n OptxRimPPToA1plemAgR6pxHF8y6-yqyVnmcw6Fy1dqd-jfxSYoMxhAJpLjA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 13: DPoP-Protected Resource Request",
      "ja": "図13：DPoP保護されたリソースリクエスト"
    },
    {
      "indent": 3,
      "text": "{\n  \"typ\":\"dpop+jwt\",\n  \"alg\":\"ES256\",\n  \"jwk\": {\n    \"kty\":\"EC\",\n    \"x\":\"l8tFrhx-34tV3hRICRDY9zCkDlpBhF42UQUfWVAWBFs\",\n    \"y\":\"9VE4jf_Ok_o64zbTTlcuNJajHmt6v9TDVrU0CdvGRDA\",\n    \"crv\":\"P-256\"\n  }\n}\n.\n{\n  \"jti\":\"e1j3V_bKic8-LAEB\",\n  \"htm\":\"GET\",\n  \"htu\":\"https://resource.example.org/protectedresource\",\n  \"iat\":1562262618,\n  \"ath\":\"fUHyO2r2Z3DZ53EsNrWBb0xWXoaNy59IiKCAqksmQEo\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 14: Decoded Content of the DPoP Proof JWT in Figure 13",
      "ja": "図14：図13のDPoP証明JWTのデコードされたコンテンツ"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a request to a protected resource within the protection space requiring DPoP authentication, the server can respond with a challenge to the client to provide DPoP authentication information if the request does not include valid credentials or does not contain an access token sufficient for access. Such a challenge is made using the 401 (Unauthorized) response status code ([RFC9110], Section 15.5.2) and the WWW-Authenticate header field ([RFC9110], Section 11.6.1). The server MAY include the WWW-Authenticate header in response to other conditions as well.",
      "ja": "DPoP認証を必要とする保護スペース内の保護されたリソースへのリクエストを受信した場合、サーバーは、リクエストに有効なクレデンシャルが含まれていないか、アクセスに十分なアクセストークンが含まれていない場合に、クライアントに対してDPoP認証情報を提供するようチャレンジで応答できます。このようなチャレンジは、401 (Unauthorized) レスポンスステータスコード（[RFC9110]、セクション15.5.2）およびWWW-Authenticateヘッダーフィールド（[RFC9110]、セクション11.6.1）を使用して行われます。サーバーは、他の状況に応じてWWW-Authenticateヘッダーを含めることもできます。"
    },
    {
      "indent": 3,
      "text": "In such challenges:",
      "ja": "そのようなチャレンジでは、"
    },
    {
      "indent": 6,
      "text": "* The scheme name is DPoP.",
      "ja": "* スキーム名はDPoPです。"
    },
    {
      "indent": 6,
      "text": "* The authentication parameter realm MAY be included to indicate the scope of protection in the manner described in [RFC9110], Section 11.5.",
      "ja": "* [RFC9110]のセクション11.5に記載されている方法で保護の範囲を示すために、認証パラメーターのrealmが含まれてもよい。"
    },
    {
      "indent": 6,
      "text": "* A scope authentication parameter MAY be included as defined in [RFC6750], Section 3.",
      "ja": "* [RFC6750]のセクション3で定義されているように、スコープ認証パラメーターが含まれてもよい。"
    },
    {
      "indent": 6,
      "text": "* An error parameter ([RFC6750], Section 3) SHOULD be included to indicate the reason why the request was declined, if the request included an access token but failed authentication. The error parameter values described in [RFC6750], Section 3.1 are suitable, as are any appropriate values defined by extension. The value use_dpop_nonce can be used as described in Section 9 to signal that a nonce is needed in the DPoP proof of a subsequent request(s). Additionally, invalid_dpop_proof is used to indicate that the DPoP proof itself was deemed invalid based on the criteria of Section 4.3.",
      "ja": "* リクエストにアクセストークンが含まれていたが認証に失敗した場合、リクエストが拒否された理由を示すために、エラーパラメーター（[RFC6750]、セクション3）を含めるべきです。[RFC6750]のセクション3.1で説明されているエラーパラメーター値は適切であり、拡張によって定義される適切な値も同様に適切です。use_dpop_nonce の値は、セクション9で説明されているように、後続のリクエストのDPoP証明で nonce が必要であることを通知するために使用できます。さらに、invalid_dpop_proof は、DPoP証明自体がセクション4.3の基準に基づいて無効であると判断されたことを示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "* An error_description parameter ([RFC6750], Section 3) MAY be included along with the error parameter to provide developers a human-readable explanation that is not meant to be displayed to end-users.",
      "ja": "* error_descriptionパラメーター（[RFC6750]、セクション3）は、エンドユーザーに表示されることを意図していない開発者向けの人間が読める説明を提供するために、エラーパラメーターとともに含められてもよい。"
    },
    {
      "indent": 6,
      "text": "* An algs parameter SHOULD be included to signal to the client the JWS algorithms that are acceptable for the DPoP proof JWT. The value of the parameter is a space-delimited list of JWS alg (Algorithm) header values ([RFC7515], Section 4.1.1).",
      "ja": "* algsパラメーターは、DPoP証明JWTに許容されるJWSアルゴリズムをクライアントに通知するために含めるべきです。パラメーターの値は、JWS alg (Algorithm) ヘッダー値（[RFC7515]、セクション4.1.1）のスペース区切りのリストです。"
    },
    {
      "indent": 6,
      "text": "* Additional authentication parameters MAY be used, and unknown parameters MUST be ignored by recipients.",
      "ja": "* 追加の認証パラメーターが使用されてもよく、未知のパラメーターは受信者が無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Figure 15 shows a response to a protected resource request without authentication.",
      "ja": "図15は、認証なしで保護されたリソース要求に対するレスポンスを示しています。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: DPoP algs=\"ES256 PS256\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 15: HTTP 401 Response to a Protected Resource Request without Authentication",
      "ja": "図15：認証なしで保護されたリソース要求に対するHTTP 401レスポンス"
    },
    {
      "indent": 3,
      "text": "Figure 16 shows a response to a protected resource request that was rejected due to the failed confirmation of the DPoP binding in the access token. Figure 16 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図16は、アクセストークンでのDPoPバインディングの確認が失敗したため拒否された保護されたリソース要求に対するレスポンスを示しています。図16は、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: DPoP error=\"invalid_token\", \\\n   error_description=\"Invalid DPoP key binding\", algs=\"ES256\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 16: HTTP 401 Response to a Protected Resource Request with an Invalid Token",
      "ja": "図16：無効なトークンを使用した保護されたリソース要求に対するHTTP 401レスポンス"
    },
    {
      "indent": 3,
      "text": "Note that browser-based client applications using Cross-Origin Resource Sharing (CORS) [WHATWG.Fetch] only have access to CORS-safelisted response HTTP headers by default. In order for the application to obtain and use the WWW-Authenticate HTTP response header value, the server needs to make it available to the application by including WWW-Authenticate in the Access-Control-Expose-Headers response header list value.",
      "ja": "クロスオリジンリソース共有（CORS）[WHATWG.Fetch] を使用するブラウザベースのクライアントアプリケーションは、デフォルトではCORSセーフリスト化されたHTTPレスポンスヘッダーにのみアクセスできることに注意してください。アプリケーションがWWW-Authenticate HTTPレスポンスヘッダー値を取得して使用できるようにするためには、サーバーはAccess-Control-Expose-Headers レスポンスヘッダーリストの値にWWW-Authenticateを含めることにより、それをアプリケーションが利用できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "This authentication scheme is for origin-server authentication only. Therefore, this authentication scheme MUST NOT be used with the Proxy-Authenticate or Proxy-Authorization header fields.",
      "ja": "この認証スキームは、オリジンサーバー認証専用です。したがって、この認証スキームは、Proxy-AuthenticateまたはProxy-Authorizationヘッダーフィールドで使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the syntax of the Authorization header field for this authentication scheme follows the usage of the Bearer scheme defined in Section 2.1 of [RFC6750]. While it is not the preferred credential syntax of [RFC9110], it is compatible with the general authentication framework therein and is used for consistency and familiarity with the Bearer scheme.",
      "ja": "この認証スキームのAuthorizationヘッダーフィールドの構文は、[RFC6750]のセクション2.1で定義されているBearerスキームの使用法に準拠していることに注意してください。[RFC9110]の推奨されるクレデンシャル構文ではありませんが、その中の一般的な認証フレームワークと互換性があり、Bearerスキームとの一貫性と親和性のために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Compatibility with the Bearer Authentication Scheme",
      "section_title": true,
      "ja": "7.2. Bearer認証スキームとの互換性"
    },
    {
      "indent": 3,
      "text": "Protected resources simultaneously supporting both the DPoP and Bearer schemes need to update how the evaluation process is performed for bearer tokens to prevent downgraded usage of a DPoP-bound access token. Specifically, such a protected resource MUST reject a DPoP-bound access token received as a bearer token per [RFC6750].",
      "ja": "DPoPとBearerの両方のスキームを同時にサポートする保護されたリソースは、DPoPバインドされたアクセストークンのダウングレードされた使用を防ぐために、Bearerトークンの評価プロセスの実行方法を更新する必要があります。具体的には、そのような保護されたリソースは、[RFC6750]に従ってBearerトークンとして受信したDPoPバインドされたアクセストークンを拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Section 11.6.1 of [RFC9110] allows a protected resource to indicate support for multiple authentication schemes (i.e., Bearer and DPoP) with the WWW-Authenticate header field of a 401 (Unauthorized) response.",
      "ja": "[RFC9110]のセクション11.6.1では、保護されたリソースが、401 (Unauthorized) レスポンスのWWW-Authenticateヘッダーフィールドを使用して、複数の認証スキーム（つまりBearerおよびDPoP）のサポートを示すことができます。"
    },
    {
      "indent": 3,
      "text": "A protected resource that supports only [RFC6750] and is unaware of DPoP would most presumably accept a DPoP-bound access token as a bearer token (JWT [RFC7519] says to ignore unrecognized claims, Introspection [RFC7662] says that other parameters might be present while placing no functional requirements on their presence, and [RFC6750] is effectively silent on the content of the access token since it relates to validity). As such, a client can send a DPoP-bound access token using the Bearer scheme upon receipt of a WWW-Authenticate: Bearer challenge from a protected resource (or it can send a DPoP-bound access token if it has prior knowledge of the capabilities of the protected resource). The effect of this likely simplifies the logistics of phased upgrades to protected resources in their support DPoP or prolonged deployments of protected resources with mixed token type support.",
      "ja": "[RFC6750]のみをサポートし、DPoPを認識しない保護されたリソースは、DPoPバインドされたアクセストークンをBearerトークンとして受け入れるでしょう（JWT [RFC7519] は未認識のクレームを無視するように述べており、イントロスペクション [RFC7662] は機能要件を課すことなく他のパラメーターが存在する可能性があると述べており、[RFC6750] は有効性に関連するため、アクセストークンのコンテンツについて実質的に沈黙しています）。そのため、クライアントは、WWW-Authenticate: Bearer チャレンジを保護されたリソースから受信した際にBearerスキームを使用してDPoPバインドされたアクセストークンを送信できます（または、保護されたリソースの機能に関する事前の知識がある場合はDPoPバインドされたアクセストークンを送信できます）。これは、保護されたリソースがDPoPをサポートするための段階的なアップグレード、あるいは混在するトークンタイプをサポートする保護されたリソースの長期的なデプロイメントのロジスティクスを簡素化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a protected resource supporting both Bearer and DPoP schemes elects to respond with multiple WWW-Authenticate challenges, attention should be paid to which challenge(s) should deliver the actual error information. It is RECOMMENDED that the following rules be adhered to:",
      "ja": "BearerとDPoPスキームの両方をサポートする保護されたリソースが、複数のWWW-Authenticateチャレンジで応答することを選択した場合、実際のエラー情報を提供するべきチャレンジに注意を払うべきです。以下のルールを順守することが推奨されます。"
    },
    {
      "indent": 6,
      "text": "* If no authentication information has been included with the request, then the challenges SHOULD NOT include an error code or other error information, as per Section 3.1 of [RFC6750] (Figure 17).",
      "ja": "* リクエストに認証情報が含まれていない場合、[RFC6750]のセクション3.1に従って、チャレンジにはエラーコードやその他のエラー情報を含めるべきではありません（図17）。"
    },
    {
      "indent": 6,
      "text": "* If the mechanism used to attempt authentication could be established unambiguously, then the corresponding challenge SHOULD be used to deliver error information (Figure 18).",
      "ja": "* 認証を試みるために使用されるメカニズムを明確に確立できる場合、対応するチャレンジを使用してエラー情報が提供されるべきです（図18）。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, both Bearer and DPoP challenges MAY be used to deliver error information (Figure 19).",
      "ja": "* それ以外の場合、BearerおよびDPoPチャレンジの両方を使用して、エラー情報が提供されてもよい（図19）。"
    },
    {
      "indent": 3,
      "text": "The following examples use \"\\\" line wrapping per [RFC8792].",
      "ja": "次の例では、[RFC8792] に従って行折り返しを使用します。"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1\nHost: resource.example.org\n\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer, DPoP algs=\"ES256 PS256\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 17: HTTP 401 Response to a Protected Resource Request without Authentication",
      "ja": "図17：認証なしで保護されたリソース要求に対するHTTP 401レスポンス"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1\nHost: resource.example.org\nAuthorization: Bearer INVALID_TOKEN\n\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer error=\"invalid_token\", \\\n    error_description=\"Invalid token\", DPoP algs=\"ES256 PS256\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 18: HTTP 401 Response to a Protected Resource Request with Invalid Authentication",
      "ja": "図18：無効な認証による保護されたリソース要求に対するHTTP 401レスポンス"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1\nHost: resource.example.org\nAuthorization: Bearer Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\nAuthorization: DPoP Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\n\nHTTP/1.1 400 Bad Request\nWWW-Authenticate: Bearer error=\"invalid_request\", \\\n error_description=\"Multiple methods used to include access token\", \\\n DPoP algs=\"ES256 PS256\", error=\"invalid_request\", \\\n error_description=\"Multiple methods used to include access token\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 19: HTTP 400 Response to a Protected Resource Request with Ambiguous Authentication",
      "ja": "図19：あいまいな認証を使用した保護されたリソース要求に対するHTTP 400レスポンス"
    },
    {
      "indent": 0,
      "text": "7.3. Client Considerations",
      "section_title": true,
      "ja": "7.3. クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Authorization including a DPoP proof may not be idempotent (depending on server enforcement of jti, iat, and nonce claims). Consequently, all previously idempotent requests for protected resources that were previously idempotent may no longer be idempotent. It is RECOMMENDED that clients generate a unique DPoP proof, even when retrying idempotent requests in response to HTTP errors generally understood as transient.",
      "ja": "DPoP証明を含む認可は、冪等ではない場合があります（jti、iat、およびnonceクレームのサーバーによる強制に応じて）。その結果、以前は冪等であった保護されたリソースに対するすべてのリクエストが、もはや冪等ではない可能性があります。一般に一時的なものとして理解されるHTTPエラーに応答して冪等なリクエストを再試行する場合でも、クライアントは一意のDPoP証明を生成することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Clients that encounter frequent network errors may experience additional challenges when interacting with servers with stricter nonce validation implementations.",
      "ja": "頻繁なネットワークエラーに遭遇するクライアントは、より厳格なnonce検証実装を持つサーバーと対話する際に追加の課題に直面する可能性があります。"
    },
    {
      "indent": 0,
      "text": "8. Authorization Server-Provided Nonce",
      "section_title": true,
      "ja": "8. 認可サーバーが提供するnonce"
    },
    {
      "indent": 3,
      "text": "This section specifies a mechanism using opaque nonces provided by the server that can be used to limit the lifetime of DPoP proofs. Without employing such a mechanism, a malicious party controlling the client (potentially including the end-user) can create DPoP proofs for use arbitrarily far in the future.",
      "ja": "このセクションでは、DPoP証明の寿命を制限するために使用できる、サーバーによって提供される不透明なnonceを使用したメカニズムを指定します。このようなメカニズムを採用しない場合、クライアントを制御する悪意のある当事者（エンドユーザーを含む可能性がある）は、将来にわたって任意にDPoP証明を作成できます。"
    },
    {
      "indent": 3,
      "text": "Including a nonce value contributed by the authorization server in the DPoP proof MAY be used by authorization servers to limit the lifetime of DPoP proofs. The server determines when to issue a new DPoP nonce challenge and if it is needed, thereby requiring the use of the nonce value in subsequent DPoP proofs. The logic through which the server makes that determination is out of scope of this document.",
      "ja": "認可サーバーによってDPoP証明に含まれるnonce値は、DPoP証明の寿命を制限するために認可サーバーによって使用されてもよいです。サーバーは、新しいDPoP nonceチャレンジを発行するタイミングと、それが必要かどうかを決定し、それによって後続のDPoP証明でnonce値の使用を要求します。サーバーがその決定を行うロジックは、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "An authorization server MAY supply a nonce value to be included by the client in DPoP proofs sent. In this case, the authorization server responds to requests that do not include a nonce with an HTTP 400 (Bad Request) error response per Section 5.2 of [RFC6749] using use_dpop_nonce as the error code value. The authorization server includes a DPoP-Nonce HTTP header in the response supplying a nonce value to be used when sending the subsequent request. Nonce values MUST be unpredictable. This same error code is used when supplying a new nonce value when there was a nonce mismatch. The client will typically retry the request with the new nonce value supplied upon receiving a use_dpop_nonce error with an accompanying nonce value.",
      "ja": "認可サーバーは、クライアントが送信するDPoP証明に含めるnonce値を提供してもよいです。この場合、認可サーバーは、use_dpop_nonce をエラーコード値として使用し、[RFC6749] のセクション5.2に従ってHTTP 400 (Bad Request) エラーレスポンスで、nonceを含まないリクエストに応答します。認可サーバーは、後続のリクエストを送信する際に使用されるnonce値を提供するDPoP-Nonce HTTPヘッダーをレスポンスに含めます。nonce値は予測不可能でなければなりません。この同じエラーコードは、nonceの不一致があった場合に新しいnonce値を提供する際にも使用されます。通常、クライアントは、添付されたnonce値とともにuse_dpop_nonceエラーを受信すると、提供された新しいnonce値でリクエストを再試行します。"
    },
    {
      "indent": 3,
      "text": "For example, in response to a token request without a nonce when the authorization server requires one, the authorization server can respond with a DPoP-Nonce value such as the following to provide a nonce value to include in the DPoP proof:",
      "ja": "たとえば、認可サーバーが必要とする場合に、nonceを含まないトークンリクエストに応答して、認可サーバーはDPoP証明に含めるnonce値を提供するために、次のようなDPoP-Nonce値で応答できます。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 400 Bad Request\nDPoP-Nonce: eyJ7S_zG.eyJH0-Z.HX4w-7v\n\n{\n \"error\": \"use_dpop_nonce\",\n \"error_description\":\n   \"Authorization server requires nonce in DPoP proof\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 20: HTTP 400 Response to a Token Request without a Nonce",
      "ja": "図20：nonceなしでトークンリクエストに対するHTTP 400レスポンス"
    },
    {
      "indent": 3,
      "text": "Other HTTP headers and JSON fields MAY also be included in the error response, but there MUST NOT be more than one DPoP-Nonce header.",
      "ja": "他のHTTPヘッダーとJSONフィールドもエラーレスポンスに含まれてもよいですが、DPoP-Nonceヘッダーが1つ以上存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the nonce, the client is expected to retry its token request using a DPoP proof including the supplied nonce value in the nonce claim of the DPoP proof. An example unencoded JWT payload of such a DPoP proof including a nonce is shown below.",
      "ja": "nonceを受信すると、クライアントは、DPoP証明のnonceクレームに提供されたnonce値を含むDPoP証明を使用してトークンリクエストを再試行することが期待されます。以下に示すのは、そのようなnonceを含むDPoP証明の、エンコードされていないJWTペイロードの例です。"
    },
    {
      "indent": 4,
      "text": "{\n \"jti\": \"-BwC3ESc6acc2lTc\",\n \"htm\": \"POST\",\n \"htu\": \"https://server.example.com/token\",\n \"iat\": 1562262616,\n \"nonce\": \"eyJ7S_zG.eyJH0-Z.HX4w-7v\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 21: DPoP Proof Payload including a Nonce Value",
      "ja": "図21：nonce値を含むDPoP証明ペイロード"
    },
    {
      "indent": 3,
      "text": "The nonce is opaque to the client.",
      "ja": "nonceはクライアントに不透明です。"
    },
    {
      "indent": 3,
      "text": "If the nonce claim in the DPoP proof does not exactly match a nonce recently supplied by the authorization server to the client, the authorization server MUST reject the request. The rejection response MAY include a DPoP-Nonce HTTP header providing a new nonce value to use for subsequent requests.",
      "ja": "DPoP証明のnonceクレームが、認可サーバーからクライアントに最近提供されたnonceと正確に一致しない場合、認可サーバーはリクエストを拒否しなければなりません。拒否レスポンスには、後続のリクエストに使用する新しいnonce値を提供するDPoP-Nonce HTTPヘッダーが含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "The intent is that clients need to keep only one nonce value and servers need to keep a window of recent nonces. That said, transient circumstances may arise in which the stored nonce values for the server and the client differ. However, this situation is self-correcting. With any rejection message, the server can send the client the nonce value it wants to use to the client, and the client can store that nonce value and retry the request with it. Even if the client and/or server discard their stored nonce values, that situation is also self-correcting because new nonce values can be communicated when responding to or retrying failed requests.",
      "ja": "意図としては、クライアントは1つのnonce値のみを保持し、サーバーは最近のnonceのウィンドウを保持する必要があるということです。そうは言っても、サーバーとクライアントで格納されているnonce値が異なる一時的な状況が発生する可能性があります。しかし、この状況は自己修正されます。拒否メッセージが送られると、サーバーはクライアントに対して使用してほしいnonce値を送信でき、クライアントはそのnonce値を格納してリクエストを再試行できます。クライアントおよび/またはサーバーが格納されているnonce値を破棄したとしても、失敗したリクエストに応答または再試行する際に新しいnonce値が伝達されるため、その状況も自己修正されます。"
    },
    {
      "indent": 3,
      "text": "Note that browser-based client applications using CORS [WHATWG.Fetch] only have access to CORS-safelisted response HTTP headers by default. In order for the application to obtain and use the DPoP-Nonce HTTP response header value, the server needs to make it available to the application by including DPoP-Nonce in the Access-Control-Expose-Headers response header list value.",
      "ja": "CORS [WHATWG.Fetch] を使用するブラウザベースのクライアントアプリケーションは、デフォルトではCORSセーフリスト化されたHTTPレスポンスヘッダーにのみアクセスできることに注意してください。アプリケーションがDPoP-Nonce HTTPレスポンスヘッダー値を取得して使用できるようにするためには、サーバーはAccess-Control-Expose-Headers レスポンスヘッダーリストの値にDPoP-Nonceを含めることにより、それをアプリケーションが利用できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Nonce Syntax",
      "section_title": true,
      "ja": "8.1. nonce構文"
    },
    {
      "indent": 3,
      "text": "The nonce syntax in ABNF as used by [RFC6749] (which is the same as the scope-token syntax) is shown below.",
      "ja": "[RFC6749]で使用されるABNFのnonce構文（スコープトークンの構文と同じ）を以下に示します。"
    },
    {
      "indent": 3,
      "text": "nonce = 1*NQCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 22: Nonce ABNF",
      "ja": "図22：nonce ABNF"
    },
    {
      "indent": 0,
      "text": "8.2. Providing a New Nonce Value",
      "section_title": true,
      "ja": "8.2. 新しいnonce値を提供します"
    },
    {
      "indent": 3,
      "text": "It is up to the authorization server when to supply a new nonce value for the client to use. The client is expected to use the existing supplied nonce in DPoP proofs until the server supplies a new nonce value.",
      "ja": "クライアントが使用する新しいnonce値をいつ提供するかは、認可サーバー次第です。クライアントは、サーバーが新しいnonce値を提供するまで、DPoP証明で既存の提供されたnonceを使用することが期待されます。"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY supply the new nonce in the same way that the initial one was supplied: by using a DPoP-Nonce HTTP header in the response. The DPoP-Nonce HTTP header field uses the nonce syntax defined in Section 8.1. Each time this happens, it requires an extra protocol round trip.",
      "ja": "認可サーバーは、最初のnonceが提供されたのと同じ方法で新しいnonceを提供してもよいです。すなわち、レスポンスのDPoP-Nonce HTTPヘッダーを使用することによってです。DPoP-Nonce HTTPヘッダーフィールドは、セクション8.1で定義されているnonce構文を使用します。これが起こるたびに、追加のプロトコルラウンドトリップが必要になります。"
    },
    {
      "indent": 3,
      "text": "A more efficient manner of supplying a new nonce value is also defined by including a DPoP-Nonce HTTP header in the HTTP 200 (OK) response from the previous request. The client MUST use the new nonce value supplied for the next token request and for all subsequent token requests until the authorization server supplies a new nonce.",
      "ja": "新しいnonce値を提供するより効率的な方法も、以前のリクエストからのHTTP 200 (OK) レスポンスにDPoP-Nonce HTTPヘッダーを含めることによって定義されます。クライアントは、認可サーバーが新しいnonceを提供するまで、次のトークンリクエストおよびそれ以降のすべてのトークンリクエストに対して提供された新しいnonce値を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Responses that include the DPoP-Nonce HTTP header should be uncacheable (e.g., using Cache-Control: no-store in response to a GET request) to prevent the response from being used to serve a subsequent request and a stale nonce value from being used as a result.",
      "ja": "DPoP-Nonce HTTPヘッダーを含むレスポンスは、キャッシュ不可能（例：GETリクエストへのレスポンスでCache-Control: no-storeを使用）であるべきです。これは、レスポンスが後続のリクエストの処理に使用されたり、古いnonce値が結果として使用されたりすることを防ぐためです。"
    },
    {
      "indent": 3,
      "text": "An example 200 OK response providing a new nonce value is shown below.",
      "ja": "新しいnonce値を提供するHTTP 200 OKレスポンスの例を以下に示します。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 200 OK\nCache-Control: no-store\nDPoP-Nonce: eyJ7S_zG.eyJbYu3.xQmBj-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 23: HTTP 200 Response Providing the Next Nonce Value",
      "ja": "図23：次のノンセ値を提供するHTTP 200応答"
    },
    {
      "indent": 0,
      "text": "9. Resource Server-Provided Nonce",
      "section_title": true,
      "ja": "9. リソースサーバーが提供するnonce"
    },
    {
      "indent": 3,
      "text": "Resource servers can also choose to provide a nonce value to be included in DPoP proofs sent to them. They provide the nonce using the DPoP-Nonce header in the same way that authorization servers do as described in Sections 8 and 8.2. The error signaling is performed as described in Section 7.1. Resource servers use an HTTP 401 (Unauthorized) error code with an accompanying WWW-Authenticate: DPoP value and DPoP-Nonce value to accomplish this.",
      "ja": "リソースサーバーは、自身に送信されるDPoP証明に含めるnonce値を提供することもできます。これらは、セクション8および8.2で説明されている認可サーバーが行うのと同じ方法で、DPoP-Nonceヘッダーを使用してnonceを提供します。エラー通知はセクション7.1で説明されているとおりに実行されます。リソースサーバーは、これを達成するために、HTTP 401 (Unauthorized) エラーコードと、それに付随するWWW-Authenticate: DPoP値およびDPoP-Nonce値を使用します。"
    },
    {
      "indent": 3,
      "text": "For example, in response to a resource request without a nonce when the resource server requires one, the resource server can respond with a DPoP-Nonce value such as the following to provide a nonce value to include in the DPoP proof. The example below uses \"\\\" line wrapping per [RFC8792].",
      "ja": "たとえば、リソースサーバーが必要な場合に、nonceのないリソースリクエストに応答して、リソースサーバーはDPoP証明に含めるnonce値を提供するために、次のようなDPoP-Nonce値で応答できます。以下の例では、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: DPoP error=\"use_dpop_nonce\", \\\n  error_description=\"Resource server requires nonce in DPoP proof\"\nDPoP-Nonce: eyJ7S_zG.eyJH0-Z.HX4w-7v",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 24: HTTP 401 Response to a Resource Request without a Nonce",
      "ja": "図24：nonceなしのリソースリクエストに対するHTTP 401レスポンス"
    },
    {
      "indent": 3,
      "text": "Note that the nonces provided by an authorization server and a resource server are different and should not be confused with one another since nonces will be only accepted by the server that issued them. Likewise, should a client use multiple authorization servers and/or resource servers, a nonce issued by any of them should be used only at the issuing server. Developers should also be careful to not confuse DPoP nonces with the OpenID Connect [OpenID.Core] ID Token nonce.",
      "ja": "認可サーバーとリソースサーバーによって提供されるnonceは異なっており、nonceは発行元サーバーによってのみ受け入れられるため、互いに混同すべきではありません。同様に、クライアントが複数の認可サーバーやリソースサーバーを使用する場合、それらのいずれかが発行したnonceは、発行元サーバーでのみ使用されるべきです。開発者は、DPoP nonceをOpenID Connect [OpenID.Core] IDトークンnonceと混同しないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Authorization Code Binding to a DPoP Key",
      "section_title": true,
      "ja": "10. DPoP鍵への認可コードバインディング"
    },
    {
      "indent": 3,
      "text": "Binding the authorization code issued to the client's proof-of-possession key can enable end-to-end binding of the entire authorization flow. This specification defines the dpop_jkt authorization request parameter for this purpose. The value of the dpop_jkt authorization request parameter is the JWK Thumbprint [RFC7638] of the proof-of-possession public key using the SHA-256 hash function, which is the same value as used for the jkt confirmation method defined in Section 6.1.",
      "ja": "クライアントの所有証明鍵に発行された認可コードをバインドすることで、認可フロー全体のエンドツーエンドのバインディングが可能になります。この仕様では、この目的のためにdpop_jkt認可リクエストパラメーターを定義します。dpop_jkt認可リクエストパラメーターの値は、SHA-256ハッシュ関数を使用した所有証明公開鍵のJWKサムプリント [RFC7638] であり、セクション6.1で定義されているjkt確認方法と同じ値です。"
    },
    {
      "indent": 3,
      "text": "When a token request is received, the authorization server computes the JWK Thumbprint of the proof-of-possession public key in the DPoP proof and verifies that it matches the dpop_jkt parameter value in the authorization request. If they do not match, it MUST reject the request.",
      "ja": "トークンリクエストが受信されると、認可サーバーはDPoP証明内の所有証明公開鍵のJWKサムプリントを計算し、それが認可リクエスト内のdpop_jktパラメーター値と一致することを確認します。一致しない場合、リクエストを拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An example authorization request using the dpop_jkt authorization request parameter is shown below and uses \"\\\" line wrapping per [RFC8792].",
      "ja": "dpop_jkt認可リクエストパラメーターを使用した認可リクエストの例を以下に示します。この例では、[RFC8792] に従って行折り返しを使用しています。"
    },
    {
      "indent": 3,
      "text": "GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\\\n    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\\n    &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM\\\n    &code_challenge_method=S256\\\n    &dpop_jkt=NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs HTTP/1.1\nHost: server.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 25: Authorization Request Using the dpop_jkt Parameter",
      "ja": "図25：dpop_jktパラメーターを使用した認可リクエスト"
    },
    {
      "indent": 3,
      "text": "Use of the dpop_jkt authorization request parameter is OPTIONAL. Note that the dpop_jkt authorization request parameter MAY also be used in combination with Proof Key for Code Exchange (PKCE) [RFC7636], which is recommended by [SECURITY-TOPICS] as a countermeasure to authorization code injection. The dpop_jkt authorization request parameter only provides similar protections when a unique DPoP key is used for each authorization request.",
      "ja": "dpop_jkt認可リクエストパラメーターの使用はOPTIONALです。dpop_jkt認可リクエストパラメーターは、認可コードインジェクションの対策として[SECURITY-TOPICS]によって推奨されるProof Key for Code Exchange (PKCE) [RFC7636] と組み合わせて使用されてもよいことに注意してください。dpop_jkt認可リクエストパラメーターは、各認可リクエストに一意のDPoP鍵が使用されている場合にのみ、同様の保護を提供します。"
    },
    {
      "indent": 0,
      "text": "10.1. DPoP with Pushed Authorization Requests",
      "section_title": true,
      "ja": "10.1. プッシュされた認可リクエストでのDPoP"
    },
    {
      "indent": 3,
      "text": "When Pushed Authorization Requests (PARs) [RFC9126] are used in conjunction with DPoP, there are two ways in which the DPoP key can be communicated in the PAR request:",
      "ja": "プッシュされた認可リクエスト（PAR）[RFC9126]がDPoPと併用される場合、PARリクエストでDPoP鍵を伝達する方法は2つあります。"
    },
    {
      "indent": 6,
      "text": "* The dpop_jkt parameter can be used as described in Section 10 to bind the issued authorization code to a specific key. In this case, dpop_jkt MUST be included alongside other authorization request parameters in the POST body of the PAR request.",
      "ja": "* dpop_jktパラメーターは、セクション10で説明されているように、発行された認可コードを特定の鍵にバインドするために使用できます。この場合、dpop_jktは、PARリクエストのPOSTボディにある他の認可リクエストパラメーターとともに含めなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Alternatively, the DPoP header can be added to the PAR request. In this case, the authorization server MUST check the provided DPoP proof JWT as defined in Section 4.3. It MUST further behave as if the contained public key's thumbprint was provided using dpop_jkt, i.e., reject the subsequent token request unless a DPoP proof for the same key is provided. This can help to simplify the implementation of the client, as it can \"blindly\" attach the DPoP header to all requests to the authorization server regardless of the type of request. Additionally, it provides a stronger binding, as the DPoP header contains a proof of possession of the private key.",
      "ja": "* あるいは、DPoPヘッダーをPARリクエストに追加できます。この場合、認可サーバーは、セクション4.3で定義されているように、提供されたDPoP証明JWTを検証しなければなりません。さらに、含まれる公開鍵のサムプリントがdpop_jktを使用して提供されたかのように動作しなければなりません。つまり、同じ鍵に対するDPoP証明が提供されない限り、後続のトークンリクエストを拒否します。これは、クライアントがリクエストの種類に関係なく、認可サーバーへのすべてのリクエストに「盲目的に」DPoPヘッダーを添付できるため、クライアントの実装を簡素化するのに役立ちます。加えて、DPoPヘッダーには秘密鍵の所有証明が含まれているため、より強力なバインディングを提供します。"
    },
    {
      "indent": 3,
      "text": "Both mechanisms MUST be supported by an authorization server that supports PAR and DPoP. If both mechanisms are used at the same time, the authorization server MUST reject the request if the JWK Thumbprint in dpop_jkt does not match the public key in the DPoP header.",
      "ja": "両方のメカニズムは、PARおよびDPoPをサポートする認可サーバーによってサポートされなければなりません。両方のメカニズムが同時に使用されている場合、dpop_jkt内のJWKサムプリントがDPoPヘッダー内の公開鍵と一致しない場合、認可サーバーはリクエストを拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Allowing both mechanisms ensures that clients using dpop_jkt do not need to distinguish between front-channel and pushed authorization requests, and at the same time, clients that only have one code path for protecting all calls to authorization server endpoints do not need to distinguish between requests to the PAR endpoint and the token endpoint.",
      "ja": "両方のメカニズムを許可することで、dpop_jktを使用するクライアントがフロントチャネルとプッシュされた認可リクエストを区別する必要がなくなり、同時に、認可サーバーエンドポイントへのすべての呼び出しを保護するためのコードパスを1つだけ持つクライアントが、PARエンドポイントとトークンエンドポイントへのリクエストを区別する必要がなくなります。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In DPoP, the prevention of token replay at a different endpoint (see Section 2) is achieved through authentication of the server per [RFC6125] and the binding of the DPoP proof to a certain URI and HTTP method. However, DPoP has a somewhat different nature of protection than TLS-based methods such as OAuth Mutual TLS [RFC8705] or OAuth Token Binding [TOKEN-BINDING] (see also Sections 11.1 and 11.7). TLS-based mechanisms can leverage a tight integration between the TLS layer and the application layer to achieve strong message integrity, authenticity, and replay protection.",
      "ja": "DPoPでは、異なるエンドポイントでのトークンリプレイの防止（セクション2参照）は、[RFC6125]に従ったサーバーの認証と、DPoP証明を特定のURIおよびHTTPメソッドにバインドすることによって達成されます。しかし、DPoPは、OAuth Mutual TLS [RFC8705] や OAuth Token Binding [TOKEN-BINDING] などのTLSベースの方法とは、保護の性質がやや異なります（セクション11.1および11.7も参照）。TLSベースのメカニズムは、TLS層とアプリケーション層との緊密な統合を活用して、強力なメッセージの整合性、真正性、およびリプレイ保護を実現できます。"
    },
    {
      "indent": 0,
      "text": "11.1. DPoP Proof Replay",
      "section_title": true,
      "ja": "11.1. DPoP証明リプレイ"
    },
    {
      "indent": 3,
      "text": "If an adversary is able to get hold of a DPoP proof JWT, the adversary could replay that token at the same endpoint (the HTTP endpoint and method are enforced via the respective claims in the JWTs). To limit this, servers MUST only accept DPoP proofs for a limited time after their creation (preferably only for a relatively brief period on the order of seconds or minutes).",
      "ja": "敵がDPoP証明JWTを手に入れることができる場合、敵は同じエンドポイントでそのトークンを再生できます（HTTPエンドポイントとメソッドは、JWTのそれぞれのクレームを介して強制されます）。これを制限するために、サーバーはDPoP証明をその作成後限られた期間（できれば数秒または数分程度の比較的短い期間のみ）受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the context of the target URI, servers can store the jti value of each DPoP proof for the time window in which the respective DPoP proof JWT would be accepted to prevent multiple uses of the same DPoP proof. HTTP requests to the same URI for which the jti value has been seen before would be declined. When strictly enforced, such a single-use check provides a very strong protection against DPoP proof replay, but it may not always be feasible in practice, e.g., when multiple servers behind a single endpoint have no shared state.",
      "ja": "ターゲットURIのコンテキストでは、サーバーは、同じDPoP証明の複数回使用を防ぐために、それぞれのDPoP証明JWTが受け入れられる時間枠内において、各DPoP証明のjti値を保存できます。jti値が以前に確認されたのと同じURIへのHTTPリクエストは拒否されます。厳密に強制された場合、このような単一使用チェックはDPoP証明のリプレイに対して非常に強力な保護を提供しますが、例えば、単一のエンドポイントの背後にある複数のサーバーが共有状態を持たない場合など、実際には常に実現可能であるとは限りません。"
    },
    {
      "indent": 3,
      "text": "In order to guard against memory exhaustion attacks, a server that is tracking jti values should reject DPoP proof JWTs with unnecessarily large jti values or store only a hash thereof.",
      "ja": "メモリ枯渇攻撃を防ぐために、jti値を追跡しているサーバーは、不必要に大きなjti値を持つDPoP証明JWTを拒否するか、そのハッシュのみを保存すべきです。"
    },
    {
      "indent": 3,
      "text": "Note: To accommodate for clock offsets, the server MAY accept DPoP proofs that carry an iat time in the reasonably near future (on the order of seconds or minutes). Because clock skews between servers and clients may be large, servers MAY limit DPoP proof lifetimes by using server-provided nonce values containing the time at the server rather than comparing the client-supplied iat time to the time at the server. Nonces created in this way yield the same result even in the face of arbitrarily large clock skews.",
      "ja": "注：クロックオフセットに対応するために、サーバーは、適度に近未来（数秒または数分程度）のiat時間を含むDPoP証明を受け入れてもよいです。サーバーとクライアント間のクロックスキューが大きい可能性があるため、サーバーは、クライアントが提供したiat時間をサーバーの時間と比較するのではなく、サーバーでの時間を含むサーバー提供のnonce値を使用することによって、DPoP証明のライフタイムを制限してもよいです。この方法で作成されたnonceは、任意に大きなクロックスキューに直面しても同じ結果をもたらします。"
    },
    {
      "indent": 3,
      "text": "Server-provided nonces are an effective means for further reducing the chances for successful DPoP proof replay. Unlike cryptographic nonces, it is acceptable for clients to use the same nonce multiple times and for the server to accept the same nonce multiple times. As long as the jti value is tracked and duplicates are rejected for the lifetime of the nonce, there is no additional risk of token replay.",
      "ja": "サーバー提供のnonceは、DPoP証明リプレイの成功の可能性をさらに低減するための効果的な手段です。暗号化nonceとは異なり、クライアントが同じnonceを複数回使用すること、およびサーバーが同じnonceを複数回受け入れることは許容されます。jti値が追跡され、nonceのライフタイム中に重複が拒否される限り、トークンリプレイの追加のリスクはありません。"
    },
    {
      "indent": 0,
      "text": "11.2. DPoP Proof Pre-generation",
      "section_title": true,
      "ja": "11.2. DPoP証明の事前生成"
    },
    {
      "indent": 3,
      "text": "An attacker in control of the client can pre-generate DPoP proofs for specific endpoints arbitrarily far into the future by choosing the iat value in the DPoP proof to be signed by the proof-of-possession key. Note that one such attacker is the person who is the legitimate user of the client. The user may pre-generate DPoP proofs to exfiltrate from the machine possessing the proof-of-possession key upon which they were generated and copy them to another machine that does not possess the key. For instance, a bank employee might pre-generate DPoP proofs on a bank computer and then copy them to another machine for use in the future, thereby bypassing bank audit controls. When DPoP proofs can be pre-generated and exfiltrated, all that is actually being proved in DPoP protocol interactions is possession of a DPoP proof -- not of the proof-of-possession key.",
      "ja": "クライアントを制御する攻撃者は、DPoP証明のiat値を選択することにより、特定のターゲットに対してDPoP証明を任意に将来にわたって事前生成できます。そのような攻撃者の一人として、クライアントの正当なユーザーが挙げられます。ユーザーは、DPoP証明を事前に生成し、それが生成された所有証明鍵を持つマシンからそれを窃取し、鍵を持たない別のマシンにコピーする可能性があります。例えば、銀行員が銀行のコンピューターでDPoP証明を事前生成し、それを将来使用するために別のマシンにコピーすることで、銀行の監査管理を迂回する場合があります。DPoP証明が事前生成され窃取されうる場合、DPoPプロトコルによるやり取りで実際に証明されているのは、DPoP証明の所有であり、所有証明鍵の所有ではありません。"
    },
    {
      "indent": 3,
      "text": "Use of server-provided nonce values that are not predictable by attackers can prevent this attack. By providing new nonce values at times of its choosing, the server can limit the lifetime of DPoP proofs, preventing pre-generated DPoP proofs from being used. When server-provided nonces are used, possession of the proof-of-possession key is being demonstrated -- not just possession of a DPoP proof.",
      "ja": "攻撃者が予測できないサーバー提供のnonce値を使用することで、この攻撃を防止できます。サーバーは、自身の選択したタイミングで新しいnonce値を提供することにより、DPoP証明のライフタイムを制限し、事前生成されたDPoP証明が使用されるのを防ぐことができます。サーバー提供のnonceが使用される場合、DPoP証明の所有だけでなく、所有証明鍵の所有が実証されます。"
    },
    {
      "indent": 3,
      "text": "The ath claim limits the use of pre-generated DPoP proofs to the lifetime of the access token. Deployments that do not utilize the nonce mechanism SHOULD NOT issue long-lived DPoP constrained access tokens, preferring instead to use short-lived access tokens and refresh tokens. Whilst an attacker could pre-generate DPoP proofs to use the refresh token to obtain a new access token, they would be unable to realistically pre-generate DPoP proofs to use a newly issued access token.",
      "ja": "athクレームは、事前に生成されたDPoP証明の使用をアクセストークンのライフタイムに限定します。nonceメカニズムを利用しないデプロイメントは、長期間有効なDPoPによって制限されたアクセストークンを発行すべきではありません。代わりに、短期間有効なアクセストークンとリフレッシュトークンを使用することが推奨されます。攻撃者は、リフレッシュトークンを使用して新しいアクセストークンを取得するためにDPoP証明を事前生成できるかもしれませんが、新しく発行されたアクセストークンを使用するためのDPoP証明を現実的に事前生成することはできません。"
    },
    {
      "indent": 0,
      "text": "11.3. DPoP Nonce Downgrade",
      "section_title": true,
      "ja": "11.3. DPoP nonceダウングレード"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT accept any DPoP proofs without the nonce claim when a DPoP nonce has been provided to the client.",
      "ja": "サーバーは、DPoP nonceがクライアントに提供された場合、nonceクレームなしにDPoP証明を受け入れてはなりません。"
    },
    {
      "indent": 0,
      "text": "11.4. Untrusted Code in the Client Context",
      "section_title": true,
      "ja": "11.4. クライアントコンテキストの信頼できないコード"
    },
    {
      "indent": 3,
      "text": "If an adversary is able to run code in the client's execution context, the security of DPoP is no longer guaranteed. Common issues in web applications leading to the execution of untrusted code are XSS and remote code inclusion attacks.",
      "ja": "敵がクライアントの実行コンテキストでコードを実行できる場合、DPoPのセキュリティは保証されなくなります。信頼されていないコードの実行につながるWebアプリケーションの一般的な問題は、XSSとリモートコードインクルージョン攻撃です。"
    },
    {
      "indent": 3,
      "text": "If the private key used for DPoP is stored in such a way that it cannot be exported, e.g., in a hardware or software security module, the adversary cannot exfiltrate the key and use it to create arbitrary DPoP proofs. The adversary can, however, create new DPoP proofs as long as the client is online and uses these proofs (together with the respective tokens) either on the victim's device or on a device under the attacker's control to send arbitrary requests that will be accepted by servers.",
      "ja": "DPoPに使用される秘密鍵が、例えばハードウェアまたはソフトウェアセキュリティモジュールにエクスポートできない形で保存されている場合、敵は鍵を窃取して任意のDPoP証明を作成することはできません。しかし、クライアントがオンラインである限り、敵は新しいDPoP証明を作成し、これらの証明を（それぞれのトークンとともに）被害者のデバイス上または攻撃者の制御下にあるデバイス上で使用して、サーバーから受け入れられる任意の新しいリクエストを送信することができます。"
    },
    {
      "indent": 3,
      "text": "To send requests even when the client is offline, an adversary can try to pre-compute DPoP proofs using timestamps in the future and exfiltrate these together with the access or refresh token.",
      "ja": "クライアントがオフラインである場合でもリクエストを送信するために、敵は将来のタイムスタンプを使用してDPoP証明を事前に計算し、それらをアクセストークンまたはリフレッシュトークンとともに窃取しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "An adversary might further try to associate tokens issued from the token endpoint with a key pair under the adversary's control. One way to achieve this is to modify existing code, e.g., by replacing cryptographic APIs. Another way is to launch a new authorization grant between the client and the authorization server in an iframe. This grant needs to be \"silent\", i.e., not require interaction with the user. With code running in the client's origin, the adversary has access to the resulting authorization code and can use it to associate their own DPoP keys with the tokens returned from the token endpoint. The adversary is then able to use the resulting tokens on their own device even if the client is offline.",
      "ja": "敵はさらに、トークンエンドポイントから発行されたトークンを、敵のコントロール下にある鍵ペアと関連付けようと試みるかもしれません。これを達成する一つの方法は、既存のコードを改変することです。例えば、暗号APIを置き換えるなどです。もう一つの方法は、iframe内でクライアントと認可サーバーの間に新しい認可グラントを開始することです。このグラントは「サイレント」、すなわちユーザーとの対話を必要としないものである必要があります。クライアントのオリジンでコードが実行されている場合、敵は結果として得られる認可コードにアクセスでき、それを使用して自身のDPoP鍵をトークンエンドポイントから返されたトークンと関連付けることができます。その結果、敵はクライアントがオフラインである場合でも、自身のデバイスでそのトークンを使用できるようになります。"
    },
    {
      "indent": 3,
      "text": "Therefore, protecting clients against the execution of untrusted code is extremely important even if DPoP is used. Besides secure coding practices, Content Security Policy [W3C.CSP] can be used as a second layer of defense against XSS.",
      "ja": "したがって、DPoPを使用する場合でも、信頼できないコードの実行からクライアントを保護することは非常に重要です。安全なコーディングプラクティスに加えて、Content Security Policy [W3C.CSP] は、XSSに対する第二の防御層として使用できます。"
    },
    {
      "indent": 0,
      "text": "11.5. Signed JWT Swapping",
      "section_title": true,
      "ja": "11.5. 署名されたJWTスワッピング"
    },
    {
      "indent": 3,
      "text": "Servers accepting signed DPoP proof JWTs MUST verify that the typ field is dpop+jwt in the headers of the JWTs to ensure that adversaries cannot use JWTs created for other purposes.",
      "ja": "署名されたDPoP証明JWTを受け入れるサーバーは、typフィールドがJWTのヘッダーでdpop+jwtであることを確認しなければなりません。これにより、敵対者が他の目的で作成されたJWTを使用できないようにします。"
    },
    {
      "indent": 0,
      "text": "11.6. Signature Algorithms",
      "section_title": true,
      "ja": "11.6. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Implementers MUST ensure that only asymmetric digital signature algorithms (such as ES256) that are deemed secure can be used for signing DPoP proofs. In particular, the algorithm none MUST NOT be allowed.",
      "ja": "実装者は、安全であると見なされる非対称デジタル署名アルゴリズム（ES256など）のみがDPoP証明の署名に使用できることを確認しなければなりません。特に、アルゴリズム none は許可されてはなりません。"
    },
    {
      "indent": 0,
      "text": "11.7. Request Integrity",
      "section_title": true,
      "ja": "11.7. リクエストの整合性"
    },
    {
      "indent": 3,
      "text": "DPoP does not ensure the integrity of the payload or headers of requests. The DPoP proof only contains claims for the HTTP URI and method, but not the message body or general request headers, for example.",
      "ja": "DPoPは、リクエストのペイロードやヘッダーの整合性を保証しません。DPoP証明には、HTTP URIとメソッドのクレームのみが含まれていますが、例えばメッセージボディや一般的なリクエストヘッダーは含まれません。"
    },
    {
      "indent": 3,
      "text": "This is an intentional design decision intended to keep DPoP simple to use, but as described, it makes DPoP potentially susceptible to replay attacks where an attacker is able to modify message contents and headers. In many setups, the message integrity and confidentiality provided by TLS is sufficient to provide a good level of protection.",
      "ja": "これは、DPoPを使用しやすくすることを目的とした意図的な設計決定ですが、説明されているように、攻撃者がメッセージコンテンツとヘッダーを変更できる場合、DPoPはリプレイ攻撃を受けやすくなります。多くのセットアップでは、TLSが提供するメッセージの整合性と機密性は、適切なレベルの保護を提供するのに十分です。"
    },
    {
      "indent": 3,
      "text": "Note: While signatures covering other parts of requests are out of the scope of this specification, additional information to be signed can be added into DPoP proofs.",
      "ja": "注：リクエストの他の部分をカバーする署名はこの仕様の範囲外ではありませんが、署名する追加情報はDPoP証明に追加できます。"
    },
    {
      "indent": 0,
      "text": "11.8. Access Token and Public Key Binding",
      "section_title": true,
      "ja": "11.8. アクセストークンと公開鍵のバインディング"
    },
    {
      "indent": 3,
      "text": "The binding of the access token to the DPoP public key, as specified in Section 6, uses a cryptographic hash of the JWK representation of the public key. It relies on the hash function having sufficient second-preimage resistance so as to make it computationally infeasible to find or create another key that produces to the same hash output value. The SHA-256 hash function was used because it meets the aforementioned requirement while being widely available.",
      "ja": "セクション6で指定されているように、DPoP公開鍵へのアクセストークンのバインディングは、公開鍵のJWK表現の暗号学的ハッシュを使用します。これは、同じハッシュ出力値を生成する別の鍵を見つけたり作成したりすることが計算上困難になるように、ハッシュ関数が十分な第二原像耐性を持つことに依存しています。SHA-256ハッシュ関数は、前述の要件を満たしつつ広く利用可能であるため、使用されています。"
    },
    {
      "indent": 3,
      "text": "Similarly, the binding of the DPoP proof to the access token uses a hash of that access token as the value of the ath claim in the DPoP proof (see Section 4.2). This relies on the value of the hash being sufficiently unique so as to reliably identify the access token. The collision resistance of SHA-256 meets that requirement.",
      "ja": "同様に、DPoP証明とアクセストークンのバインディングは、DPoP証明のathクレームの値としてそのアクセストークンのハッシュを使用します（セクション4.2参照）。これは、アクセストークンを確実に識別できるように、ハッシュの値が十分に一意であることに依存しています。SHA-256の衝突耐性はその要件を満たしています。"
    },
    {
      "indent": 0,
      "text": "11.9. Authorization Code and Public Key Binding",
      "section_title": true,
      "ja": "11.9. 認可コードと公開鍵のバインディング"
    },
    {
      "indent": 3,
      "text": "Cryptographic binding of the authorization code to the DPoP public key is specified in Section 10. This binding prevents attacks in which the attacker captures the authorization code and creates a DPoP proof using a proof-of-possession key other than the one held by the client and redeems the authorization code using that DPoP proof. By ensuring end to end that only the client's DPoP key can be used, this prevents captured authorization codes from being exfiltrated and used at locations other than the one to which the authorization code was issued.",
      "ja": "認可コードとDPoP公開鍵の暗号学的バインディングは、セクション10で指定されています。このバインディングは、攻撃者が認可コードをキャプチャし、クライアントが保持しているもの以外の鍵を使用してDPoP証明を作成し、そのDPoP証明を使用して認可コードを引き換える攻撃を防止します。クライアントのDPoP鍵のみが使用できることをエンドツーエンドで保証することにより、キャプチャされた認可コードが、発行された場所以外の場所で窃取され使用されることを防ぎます。"
    },
    {
      "indent": 3,
      "text": "Authorization codes can, for instance, be harvested by attackers from places where the HTTP messages containing them are logged. Even when efforts are made to make authorization codes one-time-use, in practice, there is often a time window during which attackers can replay them. For instance, when authorization servers are implemented as scalable replicated services, some replicas may temporarily not yet have the information needed to prevent replay. DPoP binding of the authorization code solves these problems.",
      "ja": "たとえば、認可コードは、それらを含むHTTPメッセージがログに記録される場所から攻撃者によって収集される可能性があります。認可コードを一度限りの使用にする努力がなされても、実際には、攻撃者がそれらをリプレイできる時間枠がしばしば存在します。例えば、認可サーバーがスケーラブルな複製サービスとして実装されている場合、一部のレプリカは一時的にリプレイを防ぐために必要な情報を持っていない可能性があります。認可コードのDPoPバインディングは、これらの問題を解決します。"
    },
    {
      "indent": 3,
      "text": "If an authorization server does not (or cannot) strictly enforce the single-use limitation for authorization codes and an attacker can access the authorization code (and if PKCE is used, the code_verifier), the attacker can create a forged token request, binding the resulting token to an attacker-controlled key. For example, using XSS, attackers might obtain access to the authorization code and PKCE parameters. Use of the dpop_jkt parameter prevents this attack.",
      "ja": "認可サーバーが認可コードの単一使用制限を厳密に強制しない（またはできない）場合で、攻撃者が認可コード（およびPKCEが使用されている場合はcode_verifier）にアクセスできる場合、攻撃者は偽造されたトークンリクエストを作成し、結果のトークンを攻撃者が制御する鍵にバインドできます。例えば、XSSを使用して、攻撃者は認可コードとPKCEパラメーターにアクセスできる可能性があります。dpop_jktパラメーターを使用することで、この攻撃は防止されます。"
    },
    {
      "indent": 3,
      "text": "The binding of the authorization code to the DPoP public key uses a JWK Thumbprint of the public key, just as the access token binding does. The same JWK Thumbprint considerations apply.",
      "ja": "DPoP公開鍵への認可コードのバインディングは、アクセストークンバインディングと同様に、公開鍵のJWKサムプリントを使用します。同じJWKサムプリントの考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "11.10. Hash Algorithm Agility",
      "section_title": true,
      "ja": "11.10. ハッシュアルゴリズムの俊敏性"
    },
    {
      "indent": 3,
      "text": "The jkt confirmation method member, the ath JWT claim, and the dpop_jkt authorization request parameter defined herein all use the output of the SHA-256 hash function as their value. The use of a single hash function by this specification was intentional and aimed at simplicity and avoidance of potential security and interoperability issues arising from common mistakes implementing and deploying parameterized algorithm agility schemes. However, the use of a different hash function is not precluded if future circumstances change and make SHA-256 insufficient for the requirements of this specification. Should that need arise, it is expected that a short specification will be produced that updates this one. Using the output of an appropriate hash function as the value, that specification will likely define a new confirmation method member, a new JWT claim, and a new authorization request parameter. These items will be used in place of, or alongside, their respective counterparts in the same message structures and flows of the larger protocol defined by this specification.",
      "ja": "ここで定義されているjkt確認方法メンバー、ath JWTクレーム、およびdpop_jkt認可リクエストパラメーターはすべて、SHA-256ハッシュ関数の出力を値として使用します。この仕様における単一のハッシュ関数の使用は意図的であり、パラメーター化されたアルゴリズムアジリティスキームの実装および展開における一般的な誤りから生じる潜在的なセキュリティおよび相互運用性の問題を単純化し、回避することを目的としていました。ただし、将来の状況が変化し、SHA-256が本仕様の要件にとって不十分になった場合、異なるハッシュ関数の使用が排除されるわけではありません。その必要が生じた場合、本仕様を更新する短い仕様が作成されることが予想されます。適切なハッシュ関数の出力を値として使用することで、その仕様は新しい確認方法メンバー、新しいJWTクレーム、および新しい認可リクエストパラメーターを定義する可能性が高いです。これらの項目は、本仕様によって定義されるより大きなプロトコルの同じメッセージ構造とフローにおいて、それぞれの対応物の代わりとして、またはそれらと並行して使用されます。"
    },
    {
      "indent": 0,
      "text": "11.11. Binding to Client Identity",
      "section_title": true,
      "ja": "11.11. クライアントの識別子へのバインディング"
    },
    {
      "indent": 3,
      "text": "In cases where DPoP is used with client authentication, it is only bound to authentication by being coincident in the same TLS tunnel. Since the DPoP proof is not directly bound to the authentication cryptographically, it's possible that the authentication or the DPoP messages were copied into the tunnel. While including the URI in the DPoP can partially mitigate some of this risk, modifying the authentication mechanism to provide cryptographic binding between authentication and DPoP could provide better protection. However, providing additional binding with authentication through the modification of authentication mechanisms or other means is beyond the scope of this specification.",
      "ja": "DPoPがクライアント認証とともに使用される場合、それは同じTLSトンネルで一致することによってのみ認証にバインドされます。DPoP証明が認証に暗号学的に直接バインドされていないため、認証またはDPoPメッセージがトンネルにコピーされる可能性があります。DPoPにURIを含めることは、このリスクの一部を部分的に軽減できますが、認証メカニズムを変更して認証とDPoPの間に暗号学的バインディングを提供すると、より良い保護を提供できます。ただし、認証メカニズムの変更またはその他の手段を通じて、認証を伴う追加のバインディングを提供することは、この仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1. OAuth Access Token Types Registration",
      "section_title": true,
      "ja": "12.1. OAuthアクセストークンタイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following access token type in the \"OAuth Access Token Types\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAuthアクセストークンタイプ」レジストリ[IANA.OAuth.Params]に次のアクセストークンタイプを登録しています。"
    },
    {
      "indent": 3,
      "text": "Name:",
      "ja": "名前："
    },
    {
      "indent": 12,
      "text": "DPoP",
      "ja": "DPoP"
    },
    {
      "indent": 3,
      "text": "Additional Token Endpoint Response Parameters:",
      "ja": "追加のトークンエンドポイントレスポンスパラメーター："
    },
    {
      "indent": 12,
      "text": "(none)",
      "ja": "（なし）"
    },
    {
      "indent": 3,
      "text": "HTTP Authentication Scheme(s):",
      "ja": "HTTP認証スキーム："
    },
    {
      "indent": 12,
      "text": "DPoP",
      "ja": "DPoP"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.2. OAuth Extensions Error Registration",
      "section_title": true,
      "ja": "12.2. OAuth拡張エラー登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following error values in the \"OAuth Extensions Error\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAuth拡張エラー」レジストリ[IANA.OAuth.Params]に次のエラー値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Invalid DPoP proof:",
      "ja": "無効なDPoP証明："
    },
    {
      "indent": 6,
      "text": "Name:",
      "ja": "名前："
    },
    {
      "indent": 15,
      "text": "invalid_dpop_proof",
      "ja": "invalid_dpop_proof"
    },
    {
      "indent": 6,
      "text": "Usage Location:",
      "ja": "使用場所："
    },
    {
      "indent": 15,
      "text": "token error response, resource access error response",
      "ja": "トークンエラーレスポンス、リソースアクセスエラーレスポンス"
    },
    {
      "indent": 6,
      "text": "Protocol Extension:",
      "ja": "プロトコル拡張："
    },
    {
      "indent": 15,
      "text": "Demonstrating Proof of Possession (DPoP)",
      "ja": "証明鍵に基づく所有証明 (DPoP)"
    },
    {
      "indent": 6,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 15,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 3,
      "text": "Use DPoP nonce:",
      "ja": "dpop nonceを使用してください："
    },
    {
      "indent": 6,
      "text": "Name:",
      "ja": "名前："
    },
    {
      "indent": 15,
      "text": "use_dpop_nonce",
      "ja": "use_dpop_nonce"
    },
    {
      "indent": 6,
      "text": "Usage Location:",
      "ja": "使用場所："
    },
    {
      "indent": 15,
      "text": "token error response, resource access error response",
      "ja": "トークンエラーレスポンス、リソースアクセスエラーレスポンス"
    },
    {
      "indent": 6,
      "text": "Protocol Extension:",
      "ja": "プロトコル拡張："
    },
    {
      "indent": 15,
      "text": "Demonstrating Proof of Possession (DPoP)",
      "ja": "証明鍵に基づく所有証明 (DPoP)"
    },
    {
      "indent": 6,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 15,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.3. OAuth Parameters Registration",
      "section_title": true,
      "ja": "12.3. OAuthパラメーター登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following authorization request parameter in the \"OAuth Parameters\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAuthパラメーター」レジストリ[IANA.OAuth.Params]に次の認可リクエストパラメーターを登録しています。"
    },
    {
      "indent": 3,
      "text": "Name:",
      "ja": "名前："
    },
    {
      "indent": 12,
      "text": "dpop_jkt",
      "ja": "dpop_jkt"
    },
    {
      "indent": 3,
      "text": "Parameter Usage Location:",
      "ja": "パラメーターの使用場所："
    },
    {
      "indent": 12,
      "text": "authorization request",
      "ja": "認可リクエスト"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Section 10 of RFC 9449",
      "ja": "RFC 9449のセクション10"
    },
    {
      "indent": 0,
      "text": "12.4. HTTP Authentication Schemes Registration",
      "section_title": true,
      "ja": "12.4. HTTP認証スキーム登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following scheme in the \"HTTP Authentication Schemes\" registry [IANA.HTTP.AuthSchemes] established by [RFC9110], Section 16.4.1.",
      "ja": "IANAは、[RFC9110]のセクション16.4.1によって確立された「HTTP認証スキーム」レジストリ[IANA.HTTP.AuthSchemes]に次のスキームを登録しました。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name:",
      "ja": "認証スキーム名："
    },
    {
      "indent": 12,
      "text": "DPoP",
      "ja": "DPoP"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Section 7.1 of RFC 9449",
      "ja": "RFC 9449のセクション7.1"
    },
    {
      "indent": 0,
      "text": "12.5. Media Type Registration",
      "section_title": true,
      "ja": "12.5. メディアタイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the application/dpop+jwt media type [RFC2046] in the \"Media Types\" registry [IANA.MediaTypes] in the manner described in [RFC6838], which is used to indicate that the content is a DPoP JWT.",
      "ja": "IANAは、[RFC6838]に記載されている方法で、「メディアタイプ」レジストリ[IANA.MediaTypes]にapplication/dpop+jwtメディアタイプ[RFC2046]を登録しました。"
    },
    {
      "indent": 3,
      "text": "Type name:",
      "ja": "タイプ名："
    },
    {
      "indent": 12,
      "text": "application",
      "ja": "アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name:",
      "ja": "サブタイプ名："
    },
    {
      "indent": 12,
      "text": "dpop+jwt",
      "ja": "dpop+jwt"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必要なパラメーター："
    },
    {
      "indent": 12,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションのパラメーター："
    },
    {
      "indent": 12,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:",
      "ja": "考慮事項のエンコード："
    },
    {
      "indent": 12,
      "text": "binary. A DPoP JWT is a JWT; JWT values are encoded as a series of base64url-encoded values (some of which may be the empty string) separated by period ('.') characters.",
      "ja": "バイナリ。DPoP JWTはJWTです。JWT値は、一連のbase64urlエンコード値（その一部は空の文字列である可能性があります）としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Security considerations:",
      "ja": "セキュリティ上の考慮事項："
    },
    {
      "indent": 12,
      "text": "See Section 11 of RFC 9449",
      "ja": "RFC 9449のセクション11を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations:",
      "ja": "相互運用性の考慮事項："
    },
    {
      "indent": 12,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Published specification:",
      "ja": "公開された仕様："
    },
    {
      "indent": 12,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type:",
      "ja": "このメディアタイプを使用するアプリケーション："
    },
    {
      "indent": 12,
      "text": "Applications using RFC 9449 for application-level proof of possession",
      "ja": "アプリケーションレベルの所有証明にRFC 9449を使用したアプリケーション"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations:",
      "ja": "フラグメント識別子の考慮事項："
    },
    {
      "indent": 12,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "File extension(s):",
      "ja": "ファイル拡張子："
    },
    {
      "indent": 15,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s):",
      "ja": "Macintoshファイルタイプコード："
    },
    {
      "indent": 15,
      "text": "n/a",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細については、連絡先への個人およびメールアドレス："
    },
    {
      "indent": 12,
      "text": "Michael B. Jones, michael_b_jones@hotmail.com",
      "ja": "マイケルB.ジョーンズ、Michael_b_jones@hotmail.com"
    },
    {
      "indent": 3,
      "text": "Intended usage:",
      "ja": "意図された使用法："
    },
    {
      "indent": 12,
      "text": "COMMON",
      "ja": "一般"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage:",
      "ja": "使用に関する制限："
    },
    {
      "indent": 12,
      "text": "none",
      "ja": "なし"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者："
    },
    {
      "indent": 12,
      "text": "Michael B. Jones, michael_b_jones@hotmail.com",
      "ja": "マイケルB.ジョーンズ、Michael_b_jones@hotmail.com"
    },
    {
      "indent": 3,
      "text": "Change controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 0,
      "text": "12.6. JWT Confirmation Methods Registration",
      "section_title": true,
      "ja": "12.6. JWT確認方法登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following JWT cnf member value in the \"JWT Confirmation Methods\" registry [IANA.JWT] established by [RFC7800].",
      "ja": "IANAは、[RFC7800]によって確立された「JWT確認方法」レジストリ[IANA.JWT]に次のJWT CNFメンバー値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Value:",
      "ja": "確認方法値："
    },
    {
      "indent": 12,
      "text": "jkt",
      "ja": "jkt"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Description:",
      "ja": "確認方法説明："
    },
    {
      "indent": 12,
      "text": "JWK SHA-256 Thumbprint",
      "ja": "JWK SHA-256 Thumbprint"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Section 6 of RFC 9449",
      "ja": "RFC 9449のセクション6"
    },
    {
      "indent": 0,
      "text": "12.7. JSON Web Token Claims Registration",
      "section_title": true,
      "ja": "12.7. JSON Webトークンは登録を主張します"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following Claims in the \"JSON Web Token Claims\" registry [IANA.JWT] established by [RFC7519].",
      "ja": "IANAは、[RFC7519]によって確立された「JSON Webトークンクレーム」レジストリ[IANA.JWT]に次のクレームを登録しています。"
    },
    {
      "indent": 3,
      "text": "HTTP method:",
      "ja": "HTTPメソッド："
    },
    {
      "indent": 6,
      "text": "Claim Name:",
      "ja": "クレーム名："
    },
    {
      "indent": 15,
      "text": "htm",
      "ja": "HTM"
    },
    {
      "indent": 6,
      "text": "Claim Description:",
      "ja": "クレームの説明："
    },
    {
      "indent": 15,
      "text": "The HTTP method of the request",
      "ja": "リクエストのHTTPメソッド"
    },
    {
      "indent": 6,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 15,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "Section 4.2 of RFC 9449",
      "ja": "RFC 9449のセクション4.2"
    },
    {
      "indent": 3,
      "text": "HTTP URI:",
      "ja": "http uri："
    },
    {
      "indent": 6,
      "text": "Claim Name:",
      "ja": "クレーム名："
    },
    {
      "indent": 15,
      "text": "htu",
      "ja": "htu"
    },
    {
      "indent": 6,
      "text": "Claim Description:",
      "ja": "クレームの説明："
    },
    {
      "indent": 15,
      "text": "The HTTP URI of the request (without query and fragment parts)",
      "ja": "リクエストのhttp uri（クエリとフラグメントパーツなし）"
    },
    {
      "indent": 6,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 15,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "Section 4.2 of RFC 9449",
      "ja": "RFC 9449のセクション4.2"
    },
    {
      "indent": 3,
      "text": "Access token hash:",
      "ja": "アクセストークンハッシュ："
    },
    {
      "indent": 6,
      "text": "Claim Name:",
      "ja": "クレーム名："
    },
    {
      "indent": 15,
      "text": "ath",
      "ja": "アス"
    },
    {
      "indent": 6,
      "text": "Claim Description:",
      "ja": "クレームの説明："
    },
    {
      "indent": 15,
      "text": "The base64url-encoded SHA-256 hash of the ASCII encoding of the associated access token's value",
      "ja": "関連するアクセストークンの値のASCIIエンコードのbase64urlエンコードSHA-256ハッシュ"
    },
    {
      "indent": 6,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 15,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "Section 4.2 of RFC 9449",
      "ja": "RFC 9449のセクション4.2"
    },
    {
      "indent": 0,
      "text": "12.7.1. \"nonce\" Registration Update",
      "section_title": true,
      "ja": "12.7.1. 「NonCe」登録更新"
    },
    {
      "indent": 3,
      "text": "The Internet Security Glossary [RFC4949] provides a useful definition of nonce as a random or non-repeating value that is included in data exchanged by a protocol, usually for the purpose of guaranteeing liveness and thus detecting and protecting against replay attacks.",
      "ja": "インターネットセキュリティ用語集[RFC4949]は、通常、livenivesを保証し、したがってリプレイ攻撃から検出および保護する目的で、プロトコルによって交換されるデータに含まれるランダムまたは非繰り返しの値としてのNonCEの有用な定義を提供します。"
    },
    {
      "indent": 3,
      "text": "However, the initial registration of the nonce claim by [OpenID.Core] used language that was contextually specific to that application, which was potentially limiting to its general applicability.",
      "ja": "ただし、[OpenID.Core]によるNONCE請求の初期登録は、そのアプリケーションに文脈的に固有の言語を使用しました。"
    },
    {
      "indent": 3,
      "text": "Therefore, IANA has updated the entry for nonce in the \"JSON Web Token Claims\" registry [IANA.JWT] with an expanded definition to reflect that the claim can be used appropriately in other contexts and with the addition of this document as a reference, as follows.",
      "ja": "したがって、IANAは、「JSON Webトークンクレーム」レジストリ[IANA.JWT]のNONCEのエントリを更新しました。拡張された定義で、クレームは他のコンテキストで適切に使用できることを反映し、このドキュメントを参照として追加できることを反映しています。次のように。"
    },
    {
      "indent": 3,
      "text": "Claim Name:",
      "ja": "クレーム名："
    },
    {
      "indent": 12,
      "text": "nonce",
      "ja": "nonce"
    },
    {
      "indent": 3,
      "text": "Claim Description:",
      "ja": "クレームの説明："
    },
    {
      "indent": 12,
      "text": "Value used to associate a Client session with an ID Token (MAY also be used for nonce values in other applications of JWTs)",
      "ja": "クライアントセッションをIDトークンに関連付けるために使用される値（JWTSの他のアプリケーションのNonCE値にも使用できます）"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "OpenID Foundation Artifact Binding Working Group, openid-specs-ab@lists.openid.net",
      "ja": "OpenID Foundation Artifact Binding Working Group、OpenID-Specs-ab@lists.openid.net"
    },
    {
      "indent": 3,
      "text": "Specification Document(s):",
      "ja": "仕様文書："
    },
    {
      "indent": 12,
      "text": "Section 2 of [OpenID.Core] and RFC 9449",
      "ja": "[OpenID.Core]およびRFC 9449のセクション2"
    },
    {
      "indent": 0,
      "text": "12.8. Hypertext Transfer Protocol (HTTP) Field Name Registration",
      "section_title": true,
      "ja": "12.8. ハイパーテキスト転送プロトコル（HTTP）フィールド名登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following HTTP header fields, as specified by this document, in the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" [IANA.HTTP.Fields] established by [RFC9110]:",
      "ja": "IANAは、このドキュメントで指定されているように、[RFC9110]によって確立された「Iana.http.Fields] [Iana.http.Fields]：[HyperText Transfer Protocol（HTTP）フィールド名レジストリ]に次のHTTPヘッダーフィールドを登録しました。"
    },
    {
      "indent": 3,
      "text": "DPoP:",
      "ja": "DEPOP："
    },
    {
      "indent": 6,
      "text": "Field Name:",
      "ja": "フィールド名："
    },
    {
      "indent": 15,
      "text": "DPoP",
      "ja": "DEPOP"
    },
    {
      "indent": 6,
      "text": "Status:",
      "ja": "状態："
    },
    {
      "indent": 15,
      "text": "permanent",
      "ja": "永続パーマネント恒久常任不変永住永久的な一定不変"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 3,
      "text": "DPoP-Nonce:",
      "ja": "dpop-nonce："
    },
    {
      "indent": 6,
      "text": "Field Name:",
      "ja": "フィールド名："
    },
    {
      "indent": 15,
      "text": "DPoP-Nonce",
      "ja": "dpop-nonce"
    },
    {
      "indent": 6,
      "text": "Status:",
      "ja": "状態："
    },
    {
      "indent": 15,
      "text": "permanent",
      "ja": "永続パーマネント恒久常任不変永住永久的な一定不変"
    },
    {
      "indent": 6,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 15,
      "text": "RFC 9449",
      "ja": "RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.9. OAuth Authorization Server Metadata Registration",
      "section_title": true,
      "ja": "12.9. OAuth Authorization Serverメタデータ登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following value in the \"OAuth Authorization Server Metadata\" registry [IANA.OAuth.Params] established by [RFC8414].",
      "ja": "IANAは、[RFC8414]によって確立された「OAuth Authorization Server Metadata」レジストリ[iana.oauth.params]に次の値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Metadata Name:",
      "ja": "メタデータ名："
    },
    {
      "indent": 12,
      "text": "dpop_signing_alg_values_supported",
      "ja": "dpop_singe_alg_values_supported"
    },
    {
      "indent": 3,
      "text": "Metadata Description:",
      "ja": "メタデータの説明："
    },
    {
      "indent": 12,
      "text": "JSON array containing a list of the JWS algorithms supported for DPoP proof JWTs",
      "ja": "DPOP証明JWTSでサポートされているJWSアルゴリズムのリストを含むJSONアレイJWTS"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Section 5.1 of RFC 9449",
      "ja": "RFC 9449のセクション5.1"
    },
    {
      "indent": 0,
      "text": "12.10. OAuth Dynamic Client Registration Metadata",
      "section_title": true,
      "ja": "12.10. OAUTH動的クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following value in the IANA \"OAuth Dynamic Client Registration Metadata\" registry [IANA.OAuth.Params] established by [RFC7591].",
      "ja": "IANAは、[RFC7591]によって確立されたIANA \"Oauth Dynamic Client Registration Metadata\" Registry [Iana.oauth.params]に次の値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name:",
      "ja": "クライアントメタデータ名："
    },
    {
      "indent": 12,
      "text": "dpop_bound_access_tokens",
      "ja": "dpop_bound_access_tokens"
    },
    {
      "indent": 3,
      "text": "Client Metadata Description:",
      "ja": "クライアントメタデータの説明："
    },
    {
      "indent": 12,
      "text": "Boolean value specifying whether the client always uses DPoP for token requests",
      "ja": "クライアントが常にトークンリクエストにDPOPを使用するかどうかを指定するブール値"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Section 5.2 of RFC 9449",
      "ja": "RFC 9449のセクション5.2"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n           Resource Identifier (URI): Generic Syntax\", STD 66,\n           RFC 3986, DOI 10.17487/RFC3986, January 2005,\n           <https://www.rfc-editor.org/info/rfc3986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n           Specifications: ABNF\", STD 68, RFC 5234,\n           DOI 10.17487/RFC5234, January 2008,\n           <https://www.rfc-editor.org/info/rfc5234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n           Verification of Domain-Based Application Service Identity\n           within Internet Public Key Infrastructure Using X.509\n           (PKIX) Certificates in the Context of Transport Layer\n           Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March\n           2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6749]  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n           RFC 6749, DOI 10.17487/RFC6749, October 2012,\n           <https://www.rfc-editor.org/info/rfc6749>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n           Framework: Bearer Token Usage\", RFC 6750,\n           DOI 10.17487/RFC6750, October 2012,\n           <https://www.rfc-editor.org/info/rfc6750>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7515]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n           Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n           2015, <https://www.rfc-editor.org/info/rfc7515>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7517]  Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n           DOI 10.17487/RFC7517, May 2015,\n           <https://www.rfc-editor.org/info/rfc7517>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7519]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token\n           (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015,\n           <https://www.rfc-editor.org/info/rfc7519>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7638]  Jones, M. and N. Sakimura, \"JSON Web Key (JWK)\n           Thumbprint\", RFC 7638, DOI 10.17487/RFC7638, September\n           2015, <https://www.rfc-editor.org/info/rfc7638>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7800]  Jones, M., Bradley, J., and H. Tschofenig, \"Proof-of-\n           Possession Key Semantics for JSON Web Tokens (JWTs)\",\n           RFC 7800, DOI 10.17487/RFC7800, April 2016,\n           <https://www.rfc-editor.org/info/rfc7800>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SHS]      National Institute of Standards and Technology, \"Secure\n           Hash Standard (SHS)\", FIPS PUB 180-4,\n           DOI 10.6028/NIST.FIPS.180-4, August 2015,\n           <http://dx.doi.org/10.6028/NIST.FIPS.180-4>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BREACH]   CVE, \"CVE-2013-3587\", <https://cve.mitre.org/cgi-bin/\n           cvename.cgi?name=CVE-2013-3587>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Cloudbleed]\n           Graham-Cumming, J., \"Incident report on memory leak caused\n           by Cloudflare parser bug\", February 2017,\n           <https://blog.cloudflare.com/incident-report-on-memory-\n           leak-caused-by-cloudflare-parser-bug/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CRIME]    CVE, \"CVE-2012-4929\", <https://cve.mitre.org/cgi-bin/\n           cvename.cgi?name=cve-2012-4929>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[GitHub.Tokens]\n           Hanley, M., \"Security alert: Attack campaign involving\n           stolen OAuth user tokens issued to two third-party\n           integrators\", April 2022, <https://github.blog/2022-04-15-\n           security-alert-stolen-oauth-user-tokens/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Heartbleed]\n           \"CVE-2014-0160\", <https://cve.mitre.org/cgi-bin/\n           cvename.cgi?name=cve-2014-0160>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.HTTP.AuthSchemes]\n           IANA, \"Hypertext Transfer Protocol (HTTP) Authentication\n           Scheme Registry\",\n           <https://www.iana.org/assignments/http-authschemes/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.HTTP.Fields]\n           IANA, \"Hypertext Transfer Protocol (HTTP) Field Name\n           Registry\",\n           <https://www.iana.org/assignments/http-fields/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.JOSE.ALGS]\n           IANA, \"JSON Web Signature and Encryption Algorithms\",\n           <https://www.iana.org/assignments/jose/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.JWT] IANA, \"JSON Web Token Claims\",\n           <https://www.iana.org/assignments/jwt/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.MediaTypes]\n           IANA, \"Media Types\",\n           <https://www.iana.org/assignments/media-types/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IANA.OAuth.Params]\n           IANA, \"OAuth Parameters\",\n           <https://www.iana.org/assignments/oauth-parameters/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OpenID.Core]\n           Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and\n           C. Mortimore, \"OpenID Connect Core 1.0 incorporating\n           errata set 1\", November 2014,\n           <https://openid.net/specs/openid-connect-core-1_0.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2046]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n           Extensions (MIME) Part Two: Media Types\", RFC 2046,\n           DOI 10.17487/RFC2046, November 1996,\n           <https://www.rfc-editor.org/info/rfc2046>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4122]  Leach, P., Mealling, M., and R. Salz, \"A Universally\n           Unique IDentifier (UUID) URN Namespace\", RFC 4122,\n           DOI 10.17487/RFC4122, July 2005,\n           <https://www.rfc-editor.org/info/rfc4122>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n           FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,\n           <https://www.rfc-editor.org/info/rfc4949>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n           Specifications and Registration Procedures\", BCP 13,\n           RFC 6838, DOI 10.17487/RFC6838, January 2013,\n           <https://www.rfc-editor.org/info/rfc6838>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7523]  Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token\n           (JWT) Profile for OAuth 2.0 Client Authentication and\n           Authorization Grants\", RFC 7523, DOI 10.17487/RFC7523, May\n           2015, <https://www.rfc-editor.org/info/rfc7523>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7591]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and\n           P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\",\n           RFC 7591, DOI 10.17487/RFC7591, July 2015,\n           <https://www.rfc-editor.org/info/rfc7591>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, \"Proof Key\n           for Code Exchange by OAuth Public Clients\", RFC 7636,\n           DOI 10.17487/RFC7636, September 2015,\n           <https://www.rfc-editor.org/info/rfc7636>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7662]  Richer, J., Ed., \"OAuth 2.0 Token Introspection\",\n           RFC 7662, DOI 10.17487/RFC7662, October 2015,\n           <https://www.rfc-editor.org/info/rfc7662>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8414]  Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0\n           Authorization Server Metadata\", RFC 8414,\n           DOI 10.17487/RFC8414, June 2018,\n           <https://www.rfc-editor.org/info/rfc8414>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8705]  Campbell, B., Bradley, J., Sakimura, N., and T.\n           Lodderstedt, \"OAuth 2.0 Mutual-TLS Client Authentication\n           and Certificate-Bound Access Tokens\", RFC 8705,\n           DOI 10.17487/RFC8705, February 2020,\n           <https://www.rfc-editor.org/info/rfc8705>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8707]  Campbell, B., Bradley, J., and H. Tschofenig, \"Resource\n           Indicators for OAuth 2.0\", RFC 8707, DOI 10.17487/RFC8707,\n           February 2020, <https://www.rfc-editor.org/info/rfc8707>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8725]  Sheffer, Y., Hardt, D., and M. Jones, \"JSON Web Token Best\n           Current Practices\", BCP 225, RFC 8725,\n           DOI 10.17487/RFC8725, February 2020,\n           <https://www.rfc-editor.org/info/rfc8725>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8792]  Watsen, K., Auerswald, E., Farrel, A., and Q. Wu,\n           \"Handling Long Lines in Content of Internet-Drafts and\n           RFCs\", RFC 8792, DOI 10.17487/RFC8792, June 2020,\n           <https://www.rfc-editor.org/info/rfc8792>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9110]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9126]  Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D.,\n           and F. Skokan, \"OAuth 2.0 Pushed Authorization Requests\",\n           RFC 9126, DOI 10.17487/RFC9126, September 2021,\n           <https://www.rfc-editor.org/info/rfc9126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SECURITY-TOPICS]\n           Lodderstedt, T., Bradley, J., Labunets, A., and D. Fett,\n           \"OAuth 2.0 Security Best Current Practice\", Work in\n           Progress, Internet-Draft, draft-ietf-oauth-security-\n           topics-23, 5 June 2023,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-\n           security-topics-23>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TOKEN-BINDING]\n           Jones, M., Campbell, B., Bradley, J., and W. Denniss,\n           \"OAuth 2.0 Token Binding\", Work in Progress, Internet-\n           Draft, draft-ietf-oauth-token-binding-08, 19 October 2018,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-\n           token-binding-08>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[W3C.CSP]  West, M., \"Content Security Policy Level 3\", W3C Working\n           Draft, July 2023, <https://www.w3.org/TR/CSP3/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[W3C.WebCryptoAPI]\n           Watson, M., \"Web Cryptography API\", W3C Recommendation,\n           January 2017,\n           <https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[WHATWG.Fetch]\n           WHATWG, \"Fetch Living Standard\", July 2023,\n           <https://fetch.spec.whatwg.org/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Brock Allen, Annabelle Backman, Dominick Baier, Spencer Balogh, Vittorio Bertocci, Jeff Corrigan, Domingos Creado, Philippe De Ryck, Andrii Deinega, William Denniss, Vladimir Dzhuvinov, Mike Engan, Nikos Fotiou, Mark Haine, Dick Hardt, Joseph Heenan, Bjorn Hjelm, Jacob Ideskog, Jared Jennings, Benjamin Kaduk, Pieter Kasselman, Neil Madden, Rohan Mahy, Karsten Meyer zu Selhausen, Nicolas Mora, Steinar Noem, Mark Nottingham, Rob Otto, Aaron Parecki, Michael Peck, Roberto Polli, Paul Querna, Justin Richer, Joseph Salowey, Rifaat Shekh-Yusef, Filip Skokan, Dmitry Telegin, Dave Tonge, Jim Willeke, and others for their valuable input, feedback, and general support of this work.",
      "ja": "ブロック・アレン、アナベル・バックマン、ドミニック・バイアー、スペンサー・バログ、ヴィッツーリオ・ベルトッキ、ジェフ・コリガン、ドミンゴス・クレアド、フィリップ・デ・リック、アンドリ・デネガ、ウィリアム・デニス、ヴラジミール・dzhuvinov、マイク・エング、ニコス・フティウ、マーク・ハード・ヘイ・ヘイ・ヘイ・ヘイ・ヘイ・ヘイイン、ジョセフ・ヒーナン、ビョルン・フジェルム、ジェイコブ・イドスコグ、ジャレッド・ジェニングス、ベンジャミン・カドゥク、ピーター・カッセルマン、ニール・マッデン、ロハン・マヒー、カルステン・マイヤー・ズ・セルハウゼン、ニコラス・モラ、スタインアー・ノーム、マーク・ノッティンガム、ポール・Querna、Justin Richer、Joseph Salowey、Rifaat Shekh-Yusef、Filip Skokan、Dmitry Telegin、Dave Tonge、Jim Willekeなど、この作業の貴重なインプット、フィードバック、一般的なサポート。"
    },
    {
      "indent": 3,
      "text": "This document originated from discussions at the 4th OAuth Security Workshop in Stuttgart, Germany. We thank the organizers of this workshop (Ralf Küsters and Guido Schmitz).",
      "ja": "この文書は、ドイツのシュトゥットガルトで開催された第4 OAuthセキュリティワークショップでの議論から生じています。このワークショップの主催者（RalfKüstersとGuido Schmitz）に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Daniel Fett\nAuthlete\nEmail: mail@danielfett.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Brian Campbell\nPing Identity\nEmail: bcampbell@pingidentity.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Bradley\nYubico\nEmail: ve7jtb@ve7jtb.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt\nTuconic\nEmail: torsten@lodderstedt.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Jones\nSelf-Issued Consulting\nEmail: michael_b_jones@hotmail.com\nURI:   https://self-issued.info/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Waite\nPing Identity\nEmail: david@alkaline-solutions.com",
      "raw": true,
      "ja": ""
    }
  ]
}